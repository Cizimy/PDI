This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-26T05:30:29.870Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
templates/clsCallStack.cls
templates/clsCrypto.cls
templates/clsLock.cls
templates/clsLogger.cls
templates/clsPerformanceMonitor.cls
templates/ConnectionPool.cls
templates/DatabaseConnectionErrorHandler.cls
templates/DateValidator.cls
templates/DefaultLoggerSettings.cls
templates/FileLogger.cls
templates/FileNotFoundErrorHandler.cls
templates/FileSystemOperations.cls
templates/IDatabaseConfig.cls
templates/IErrorHandler.cls
templates/IFileOperations.cls
templates/ILogger.cls
templates/ILoggerSettings.cls
templates/InvalidInputErrorHandler.cls
templates/IUserNotifier.cls
templates/IValidator.cls
templates/MockLogger.cls
templates/modAppInitializer.bas
templates/modCommon.bas
templates/modConfig.bas
templates/modDatabaseUtils.bas
templates/modDateUtils.bas
templates/modError.bas
templates/modErrorCodes.bas
templates/modFileIO.bas
templates/modMathUtils.bas
templates/modStackTrace.bas
templates/modStringUtils.bas
templates/modTestRunner.bas
templates/modTestUtility.bas
templates/modWindowsAPI.bas
templates/MsgBoxNotifier.cls
templates/StringValidator.cls

================================================================
Files
================================================================

================
File: templates/clsCallStack.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsCallStack"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsCallStack"

' ======================
' メンバ変数
' ======================
Private mIsInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    modStackTrace.InitializeModule
    Set mLock = New clsLock
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    mIsInitialized = False
End Sub

' ======================
' パブリックメソッド
' ======================

''' <summary>
''' 呼び出し履歴にエントリを追加
''' </summary>
''' <param name="ModuleName">モジュール名</param>
''' <param name="ProcedureName">プロシージャ名</param>
''' <remarks>
''' スタックトレースの最大深さを超えた場合、エラーを発生させずに無視します
''' </remarks>
Public Sub Push(ByVal ModuleName As String, ByVal ProcedureName As String)
    If Not mIsInitialized Then Exit Sub
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    modStackTrace.PushStackEntry ModuleName, ProcedureName
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "Push操作中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "Push"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Sub

''' <summary>
''' 呼び出し履歴から最後のエントリを取得して削除
''' </summary>
''' <returns>最後に追加されたプロシージャの完全修飾名、またはスタックが空の場合は空文字列</returns>
Public Function Pop() As String
    If Not mIsInitialized Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Pop = modStackTrace.PopStackEntry()
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "Pop操作中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "Pop"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Function

''' <summary>
''' 現在のスタックトレースを文字列として取得
''' </summary>
''' <returns>スタックトレースの文字列表現</returns>
Public Property Get StackTrace() As String
    If Not mIsInitialized Then Exit Property
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    StackTrace = modStackTrace.GetStackTrace()
    
    mLock.ReleaseLock
    Exit Property

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "スタックトレース取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "StackTrace"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Property

''' <summary>
''' スタック内のエントリ数を取得
''' </summary>
''' <returns>現在のスタックの深さ</returns>
Public Property Get Count() As Long
    Count = modStackTrace.StackDepth
End Property

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' スタックの状態を検証（テスト用）
    ''' </summary>
    ''' <returns>スタックが有効な状態の場合True</returns>
    Private Function ValidateStackState() As Boolean
        ValidateStackState = modStackTrace.ValidateStackState()
    End Function
    
    ''' <summary>
    ''' スタックをクリア（テスト用）
    ''' </summary>
    Private Sub ClearStack()
        modStackTrace.ClearStack
    End Sub
    
    ''' <summary>
    ''' モジュールをリセット（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        mIsInitialized = False
        modStackTrace.ResetModule
        mIsInitialized = True
    End Sub
#End If

================
File: templates/clsCrypto.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsCrypto"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' 定数定義
Private Const MS_ENHANCED_PROV As String = "Microsoft Enhanced Cryptographic Provider v1.0"
Private Const PROV_RSA_FULL As Long = 1
Private Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Private Const CALG_SHA_256 As Long = &H800C
Private Const HP_HASHVAL As Long = 2
Private Const HP_HASHSIZE As Long = 4

' メンバ変数
Private mCryptoProvider As LongPtr
Private mInitialized As Boolean
Private mAesKey As LongPtr
Private mPerformanceMonitor As clsPerformanceMonitor
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mPerformanceMonitor = New clsPerformanceMonitor
    Set mLock = New clsLock
    InitializeCrypto
End Sub

Private Sub Class_Terminate()
    If mInitialized Then
        If mAesKey <> 0 Then
            CryptDestroyKey mAesKey
        End If
        CryptReleaseContext mCryptoProvider, 0
    End If
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
End Sub

' ======================
' 内部メソッド
' ======================
Private Sub InitializeCrypto()
    If modWindowsAPI.CryptAcquireContext(mCryptoProvider, vbNullString, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) <> 0 Then
        mInitialized = True
    Else
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoProviderInitFailed
            .Description = "暗号化プロバイダーの初期化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "InitializeCrypto"
        End With
        modError.HandleError errInfo
    End If
End Sub

Private Function DeriveAESKey(ByVal key As String) As Boolean
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' 既存のキーを破棄
    If mAesKey <> 0 Then
        CryptDestroyKey mAesKey
        mAesKey = 0
    End If
    
    ' キーのハッシュを作成
    Dim hHash As LongPtr
    If CryptCreateHash(mCryptoProvider, CALG_SHA_256, 0, 0, hHash) = 0 Then
        GoTo Cleanup
    End If
    
    ' キー文字列をハッシュ化
    If CryptHashData(hHash, ByVal key, Len(key), 0) = 0 Then
        CryptDestroyHash hHash
        GoTo Cleanup
    End If
    
    ' ハッシュからAESキーを生成
    If CryptDeriveKey(mCryptoProvider, CALG_AES_256, hHash, CRYPT_EXPORTABLE, mAesKey) = 0 Then
        CryptDestroyHash hHash
        GoTo Cleanup
    End If
    
    ' ハッシュオブジェクトの破棄
    CryptDestroyHash hHash
    
    ' CBCモードを設定
    Dim mode As Long
    mode = CRYPT_MODE_CBC
    If CryptSetKeyParam(mAesKey, KP_MODE, mode, 0) = 0 Then
        GoTo Cleanup
    End If
    
    DeriveAESKey = True
    
Cleanup:
    mLock.ReleaseLock
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrCryptoKeyDerivationFailed
        .Description = "AESキーの生成に失敗しました。"
        .Category = ECSecurity
        .Source = "clsCrypto"
        .ProcedureName = "DeriveAESKey"
    End With
    modError.HandleError errInfo
    DeriveAESKey = False
    Resume Cleanup
End Function

' ======================
' パブリックメソッド
' ======================
Public Function EncryptString(ByVal plainText As String, ByVal key As String) As String
    mPerformanceMonitor.StartMeasurement "String Encryption"
    
    mLock.AcquireLock
    
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' キーの検証
    If Len(key) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoKeyNotSpecified
            .Description = "空の暗号化キーが指定されました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' AESキーの生成
    If Not DeriveAESKey(key) Then
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' データの準備
    Dim dataLen As Long
    Dim blockSize As Long
    blockSize = 16 ' AESブロックサイズ
    
    ' パディングを含むデータ長を計算
    dataLen = Len(plainText)
    If (dataLen Mod blockSize) <> 0 Then
        dataLen = dataLen + (blockSize - (dataLen Mod blockSize))
    End If
    
    ' バッファの準備
    Dim buffer() As Byte
    ReDim buffer(0 To dataLen - 1)
    CopyMemory buffer(0), ByVal StrPtr(plainText), Len(plainText) * 2
    
    ' 暗号化
    If CryptEncrypt(mAesKey, 0, True, 0, buffer(0), dataLen, dataLen) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoEncryptionFailed
            .Description = "データの暗号化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim result As String
    result = Base64Encode(buffer)
    
    mPerformanceMonitor.EndMeasurement "String Encryption"
    mLock.ReleaseLock
    EncryptString = result
End Function

Public Function DecryptString(ByVal cipherText As String, ByVal key As String) As String
    mPerformanceMonitor.StartMeasurement "String Decryption"
    
mLock.AcquireLock
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' キーの検証
    If Len(key) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoKeyNotSpecified
            .Description = "空の暗号化キーが指定されました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' AESキーの生成
    If Not DeriveAESKey(key) Then
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' Base64デコード
    Dim buffer() As Byte
    buffer = Base64Decode(cipherText)
   
     ' データ長の取得
    Dim dataLen As Long
    dataLen = UBound(buffer) - LBound(buffer) + 1
    ' 復号化
    If CryptDecrypt(mAesKey, 0, True, 0, buffer(0), dataLen) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoDecryptionFailed
            .Description = "データの復号化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim result As String
    result = Left$(StrConv(buffer, vbUnicode), dataLen)
    
    mPerformanceMonitor.EndMeasurement "String Decryption"
    mLock.ReleaseLock
    DecryptString = result
End Function

Public Function GenerateHash(ByVal inputString As String) As String
    mPerformanceMonitor.StartMeasurement "Hash Generation"
    mLock.AcquireLock
    
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim hHash As LongPtr
    Dim hashLen As Long
    Dim hashValue() As Byte
    Dim result As String
    
    ' ハッシュオブジェクトの作成
    If modWindowsAPI.CryptCreateHash(mCryptoProvider, CALG_SHA_256, 0, 0, hHash) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashCreateFailed
            .Description = "ハッシュオブジェクトの作成に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' データのハッシュ化
    If modWindowsAPI.CryptHashData(hHash, ByVal inputString, Len(inputString), 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "データのハッシュ化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュサイズの取得
    If modWindowsAPI.CryptGetHashParam(hHash, HP_HASHSIZE, hashLen, 4, 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "ハッシュサイズの取得に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュ値の取得
    ReDim hashValue(0 To hashLen - 1)
    If modWindowsAPI.CryptGetHashParam(hHash, HP_HASHVAL, hashValue(0), hashLen, 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "ハッシュ値の取得に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュオブジェクトの破棄
    modWindowsAPI.CryptDestroyHash hHash
    
    ' バイト配列を16進数文字列に変換
    result = ""
    Dim i As Long
    For i = 0 To hashLen - 1
        result = result & Right$("0" & Hex$(hashValue(i)), 2)
    Next i
    
    mPerformanceMonitor.EndMeasurement "Hash Generation"
    mLock.ReleaseLock
    GenerateHash = result
    
End Function

' ======================
' ユーティリティメソッド
' ======================
Private Function Base64Encode(ByVal text As String) As String
    Dim xmlDoc As Object
    Dim xmlNode As Object
    
    Set xmlDoc = CreateObject("MSXML2.DOMDocument")
    Set xmlNode = xmlDoc.createElement("b64")
    
    xmlNode.DataType = "bin.base64"
    xmlNode.nodeTypedValue = StringToBytes(text)
    
    Base64Encode = xmlNode.text
    
    Set xmlNode = Nothing
    Set xmlDoc = Nothing
End Function

Private Function Base64Decode(ByVal base64 As String) As String
    Dim xmlDoc As Object
    Dim xmlNode As Object
    
    Set xmlDoc = CreateObject("MSXML2.DOMDocument")
    Set xmlNode = xmlDoc.createElement("b64")
    
    xmlNode.DataType = "bin.base64"
    xmlNode.text = base64
    
    Base64Decode = BytesToString(xmlNode.nodeTypedValue)
    
    Set xmlNode = Nothing
    Set xmlDoc = Nothing
End Function

Private Function StringToBytes(ByVal text As String) As Byte()
    Dim bytes() As Byte
    bytes = text
    StringToBytes = bytes
End Function

Private Function BytesToString(ByRef bytes() As Byte) As String
    BytesToString = bytes
End Function

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    Private Function ValidateProvider() As Boolean
        ' 暗号化プロバイダーの状態を検証（テスト用）
        ValidateProvider = mInitialized And mCryptoProvider <> 0
    End Function
    
    Private Sub ResetProvider()
        ' 暗号化プロバイダーをリセット（テスト用）
        If mInitialized Then
            CryptReleaseContext mCryptoProvider, 0
            mInitialized = False
        End If
        InitializeCrypto
    End Sub
#End If

================
File: templates/clsLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' 定数定義
Private Const INFINITE As Long = -1
Private Const WAIT_OBJECT_0 As Long = 0
Private Const ERROR_ALREADY_EXISTS As Long = 183&
Private Const MUTEX_NAME As String = "Global\MyApp_ModCommon_Mutex"

' メンバ変数
Private mMutexHandle As LongPtr
Private mIsLocked As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mMutexHandle = modWindowsAPI.CreateMutex(0&, 0&, MUTEX_NAME)
    mIsLocked = False
End Sub

Private Sub Class_Terminate()
    If mIsLocked Then modWindowsAPI.ReleaseMutex mMutexHandle
    If mMutexHandle <> 0 Then modWindowsAPI.CloseHandle mMutexHandle
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub AcquireLock()
    If mMutexHandle = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrLockMutexCreateFailed
            .Description = "Mutexの作成に失敗しました。"
            .Category = ECSystem
            .Source = "clsLock"
            .ProcedureName = "AcquireLock"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
    
    ' ロックの取得を試みる
    Dim result As Long
    result = modWindowsAPI.WaitForSingleObject(mMutexHandle, INFINITE)
    
    If result = WAIT_OBJECT_0 Then
        mIsLocked = True
    Else
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrLockAcquireFailed
            .Description = "ロックの取得に失敗しました。"
            .Category = ECSystem
            .Source = "clsLock"
            .ProcedureName = "AcquireLock"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
End Sub

Public Sub ReleaseLock()
    If mIsLocked Then
        If modWindowsAPI.ReleaseMutex(mMutexHandle) = 0 Then
            Dim errInfo As ErrorInfo
            With errInfo
                .Code = ErrLockReleaseFailed
                .Description = "ロックの解放に失敗しました。"
                .Category = ECSystem
                .Source = "clsLock"
                .ProcedureName = "ReleaseLock"
                .StackTrace = modStackTrace.GetStackTrace()
                .OccurredAt = Now
            End With
            modError.HandleError errInfo
        End If
        mIsLocked = False
    End If
End Sub

' ======================
' プロパティ
' ======================
Public Property Get IsLocked() As Boolean
    IsLocked = mIsLocked
End Property

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = (mMutexHandle <> 0)
    End Function
    
    Public Sub ForceRelease()
        If mMutexHandle <> 0 Then
            If mIsLocked Then modWindowsAPI.ReleaseMutex mMutexHandle
            modWindowsAPI.CloseHandle mMutexHandle
            mMutexHandle = 0
            mIsLocked = False
        End If
    End Sub
#End If

================
File: templates/clsLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsLogger"

' ======================
' メンバ変数
' ======================
Private mSettings As ILoggerSettings
Private mLogQueue As Queue
Private mDatabaseConfig As IDatabaseConfig
Private mConnectionPool As ConnectionPool
Private mLock As clsLock
Private mTimerID As LongPtr
Private mPerformanceMonitor As clsPerformanceMonitor
Private mIsInitialized As Boolean

' ======================
' イベント
' ======================
Public Event Logged(ByVal logMessage As String, ByVal logLevel As LogLevel)

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLogQueue = New Queue
    Set mConnectionPool = New ConnectionPool
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
End Sub

Private Sub Class_Terminate()
    If mTimerID <> 0 Then
        KillTimer 0, mTimerID
        mTimerID = 0
    End If
    
    Set mLogQueue = Nothing
    Set mConnectionPool = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    Set mDatabaseConfig = Nothing
    Set mSettings = Nothing
    
    mIsInitialized = False
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Configure(ByVal settings As ILoggerSettings, ByVal dbConfig As IDatabaseConfig)
    Set mSettings = settings
    Set mDatabaseConfig = dbConfig
    
    ' コネクションプールの初期化
    If Not mSettings Is Nothing And Not mDatabaseConfig Is Nothing Then
        mConnectionPool.Initialize mDatabaseConfig.GetConnectionString()
    End If
    
    ' タイマーの設定
    If mTimerID <> 0 Then
        KillTimer 0, mTimerID
    End If
    mTimerID = SetTimer(0, 0, mSettings.TimerInterval, AddressOf TimerProc)
    
    mIsInitialized = True
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal moduleName As String, ByVal message As String, Optional ByVal errorCode As ErrorCode)
    If Not mIsInitialized Then Exit Sub
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "Logger_Log"
    End If
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' ログレベルチェック
    If errorCode >= mSettings.LogLevel Then
        ' ログメッセージをキューに追加
        Dim logEntry As Variant
        logEntry = Array(moduleName, message, errorCode, Now)
        mLogQueue.Enqueue logEntry
    End If
    
Cleanup:
    mLock.ReleaseLock
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "Logger_Log"
    End If
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

Private Property Let ILogger_LogLevel(ByVal level As LogLevel)
    If Not mSettings Is Nothing Then
        mSettings.LogLevel = level
    End If
End Property

Private Property Get ILogger_LogLevel() As LogLevel
    If Not mSettings Is Nothing Then
        ILogger_LogLevel = mSettings.LogLevel
    End If
End Property

Private Property Let ILogger_LogDestination(ByVal destination As LogDestination)
    If Not mSettings Is Nothing Then
        mSettings.LogDestination = destination
    End If
End Property

Private Property Get ILogger_LogDestination() As LogDestination
    If Not mSettings Is Nothing Then
        ILogger_LogDestination = mSettings.LogDestination
    End If
End Property

' ======================
' プライベートメソッド
' ======================
Private Sub ProcessLogQueue()
    If Not mIsInitialized Then Exit Sub
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    While mLogQueue.Count > 0
        Dim logEntry As Variant
        logEntry = mLogQueue.Dequeue
        
        ' ログ出力先に応じた処理
        Select Case mSettings.LogDestination
            Case LOG_DESTINATION_FILE
                WriteToFile logEntry
            Case LOG_DESTINATION_DATABASE
                WriteToDatabase logEntry
            Case LOG_DESTINATION_EVENTLOG
                WriteToEventLog logEntry
            Case LOG_DESTINATION_CONSOLE
                WriteToConsole logEntry
        End Select
        
        ' イベント発行
        RaiseEvent Logged(logEntry(1), logEntry(2))
    Wend
    
Cleanup:
    mLock.ReleaseLock
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ログキュー処理中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ProcessLogQueue"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

Private Sub WriteToFile(ByVal logEntry As Variant)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open mSettings.LogFilePath For Append As #fileNum
    Print #fileNum, Format$(logEntry(3), "yyyy/mm/dd hh:nn:ss") & " " & _
                   "[" & logEntry(0) & "] " & _
                   IIf(logEntry(2) <> 0, "(Code: " & logEntry(2) & ") ", "") & _
                   logEntry(1)
    Close #fileNum
    mLock.ReleaseLock
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileAccessDenied
        .Description = "ファイルへのログ出力に失敗しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "WriteToFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Private Sub WriteToDatabase(ByVal logEntry As Variant)
    On Error GoTo ErrorHandler
    
    Dim conn As Object
    Set conn = Nothing
    mLock.AcquireLock
    
    mPerformanceMonitor.StartMeasurement "Database Connection"
    Set conn = mConnectionPool.GetConnection()
    mLock.ReleaseLock
    
    If Not conn Is Nothing Then
        mPerformanceMonitor.StartMeasurement "Database Insert"
        Dim cmd As Object
        Set cmd = CreateObject("ADODB.Command")
        With cmd
            .ActiveConnection = conn
            .CommandText = "INSERT INTO " & mSettings.LogTableName & " (LogTime, ModuleName, LogLevel, Message) VALUES (?, ?, ?, ?)"
            .Parameters.Append .CreateParameter("LogTime", 7, 1, , logEntry(3))
            .Parameters.Append .CreateParameter("ModuleName", 200, 1, 255, logEntry(0))
            .Parameters.Append .CreateParameter("LogLevel", 3, 1, , logEntry(2))
            .Parameters.Append .CreateParameter("Message", 200, 1, 4000, logEntry(1))
            .Execute
        End With
        
        mLock.AcquireLock
        mConnectionPool.ReleaseConnection conn
        mLock.ReleaseLock
        mPerformanceMonitor.EndMeasurement "Database Connection"
        mPerformanceMonitor.EndMeasurement "Database Insert"
    End If
    Exit Sub
    
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Database Connection"
    If Not conn Is Nothing Then
        mLock.AcquireLock
        mPerformanceMonitor.EndMeasurement "Database Insert"
        mConnectionPool.ReleaseConnection conn
        mLock.ReleaseLock
    End If
    
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDbQueryFailed
        .Description = "データベースへのログ出力に失敗しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "WriteToDatabase"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub WriteToEventLog(ByVal logEntry As Variant)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    Dim objShell As Object
    Set objShell = Nothing
    
    Try:
        ' WScript.Shellオブジェクトの作成
        Set objShell = CreateObject("WScript.Shell")
        If objShell Is Nothing Then
            Err.Raise ErrEventLogCreateFailed, "WriteToEventLog", "WScript.Shellオブジェクトの作成に失敗しました。"
        End If
        
        ' イベントの種別を決定
        Dim eventType As Integer
        Select Case logEntry(2)
            Case LOG_LEVEL_ERROR, LOG_LEVEL_FATAL
                eventType = 1 ' ERROR
            Case LOG_LEVEL_WARNING
                eventType = 2 ' WARNING
            Case Else
                eventType = 4 ' INFORMATION
        End Select
    
    
        ' イベントログへの書き込み
        If Len(mSettings.LogEventSource) = 0 Then
            Err.Raise ErrEventLogSourceInvalid, "WriteToEventLog", "イベントログソースが指定されていません。"
        End If
        
        objShell.LogEvent eventType, logEntry(1), mSettings.LogEventSource
    
    Cleanup:
        If Not objShell Is Nothing Then Set objShell = Nothing
        mLock.ReleaseLock
        Exit Sub
    
    ErrorHandler:
        Dim errDetail As ErrorInfo
        With errDetail
            .Code = IIf(Err.Number = ErrEventLogCreateFailed, ErrEventLogCreateFailed, ErrEventLogWriteFailed)
            .Description = "イベントログへの書き込みに失敗しました: " & Err.Description
            .Category = ECSystem
            .Source = MODULE_NAME
            .ProcedureName = "WriteToEventLog"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
        GoTo Cleanup
End Sub

Private Sub WriteToConsole(ByVal logEntry As Variant)
    mLock.AcquireLock
    
    Debug.Print Format$(logEntry(3), "yyyy/mm/dd hh:nn:ss") & " " & _
                "[" & logEntry(0) & "] " & _
                IIf(logEntry(2) <> 0, "(Code: " & logEntry(2) & ") ", "") & _
                logEntry(1)
    mLock.ReleaseLock
End Sub

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' ログキューのエントリ数を取得（テスト用）
    ''' </summary>
    Private Function GetQueueCount() As Long
        GetQueueCount = mLogQueue.Count
    End Function
    
    ''' <summary>
    ''' ログキューをクリア（テスト用）
    ''' </summary>
    Private Sub ClearQueue()
        Set mLogQueue = New Queue
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
    
    ''' <summary>
    ''' タイマー処理をシミュレート（テスト用）
    ''' </summary>
    Private Sub SimulateTimer()
        ProcessLogQueue
    End Sub
#End If

================
File: templates/clsPerformanceMonitor.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsPerformanceMonitor"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' メモリ情報構造体
Private Type PROCESS_MEMORY_COUNTERS
    cb As Long
    PageFaultCount As Long
    PeakWorkingSetSize As Currency
    WorkingSetSize As Currency
    QuotaPeakPagedPoolUsage As Currency
    QuotaPagedPoolUsage As Currency
    QuotaPeakNonPagedPoolUsage As Currency
    QuotaNonPagedPoolUsage As Currency
    PagefileUsage As Currency
    PeakPagefileUsage As Currency
End Type

' パフォーマンス測定データ型
Private Type PerformanceData
    StartTime As Currency
    EndTime As Currency
    ElapsedTime As Double
    MemoryUsage As Currency
    PeakMemoryUsage As Currency
    Description As String
End Type

' メンバ変数
Private mFrequency As Currency
Private mMeasurements As Collection
Private mIsEnabled As Boolean
Private mCurrentOperation As String
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    modWindowsAPI.QueryPerformanceFrequency mFrequency
    Set mMeasurements = New Collection
    Set mLock = New clsLock
    mIsEnabled = True
End Sub

Private Sub Class_Terminate()
    Set mMeasurements = Nothing
    Set mLock = Nothing
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub StartMeasurement(ByVal description As String)
    If Not mIsEnabled Then Exit Sub
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim perfData As PerformanceData
    Dim memInfo As PROCESS_MEMORY_COUNTERS
    
    ' 現在の時刻を取得
    modWindowsAPI.QueryPerformanceCounter perfData.StartTime
    
    ' メモリ使用量を取得
    memInfo.cb = LenB(memInfo)
    modWindowsAPI.GetProcessMemoryInfo modWindowsAPI.GetCurrentProcess(), memInfo, LenB(memInfo)
    perfData.MemoryUsage = memInfo.WorkingSetSize
    
    perfData.Description = description
    mCurrentOperation = description
    
    ' コレクションに追加
    mMeasurements.Add perfData, description
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "パフォーマンス測定の開始中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "clsPerformanceMonitor"
        .ProcedureName = "StartMeasurement"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Public Sub EndMeasurement(ByVal description As String)
    If Not mIsEnabled Then Exit Sub
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim perfData As PerformanceData
    Dim memInfo As PROCESS_MEMORY_COUNTERS
    Dim i As Long
    
    ' 対応する測定データを検索
    For i = mMeasurements.Count To 1 Step -1
        If TypeName(mMeasurements(i)) = "PerformanceData" Then
            perfData = mMeasurements(i)
            If perfData.Description = description Then
                ' 終了時刻を記録
                modWindowsAPI.QueryPerformanceCounter perfData.EndTime
                
                ' メモリ情報を更新
                memInfo.cb = LenB(memInfo)
                modWindowsAPI.GetProcessMemoryInfo modWindowsAPI.GetCurrentProcess(), memInfo, LenB(memInfo)
                perfData.PeakMemoryUsage = memInfo.PeakWorkingSetSize
                
                ' 経過時間を計算（ミリ秒単位）
                perfData.ElapsedTime = (perfData.EndTime - perfData.StartTime) * 1000 / mFrequency
                
                ' コレクションを更新
                mMeasurements.Remove i
                mMeasurements.Add perfData, description
                Exit For
            End If
        End If
    Next i
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "パフォーマンス測定の終了中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "clsPerformanceMonitor"
        .ProcedureName = "EndMeasurement"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Public Function GetMeasurement(ByVal description As String) As String
    If Not mIsEnabled Then Exit Function
    
    mLock.AcquireLock
    
    Dim perfData As PerformanceData
    Dim result As String
    
    On Error Resume Next
    perfData = mMeasurements(description)
    If Err.Number = 0 Then
        result = "Performance Report for: " & description & vbCrLf & _
                "Elapsed Time: " & Format$(perfData.ElapsedTime, "0.000") & " ms" & vbCrLf & _
                "Initial Memory: " & Format$(perfData.MemoryUsage / 1024 / 1024, "0.00") & " MB" & vbCrLf & _
                "Peak Memory: " & Format$(perfData.PeakMemoryUsage / 1024 / 1024, "0.00") & " MB"
    End If
    On Error GoTo 0
    
    mLock.ReleaseLock
    GetMeasurement = result
End Function

Public Function GetAllMeasurements() As String
    If Not mIsEnabled Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As String
    Dim perfData As PerformanceData
    Dim i As Long
    
    result = "Performance Monitoring Report" & vbCrLf & _
            "=========================" & vbCrLf
    
    For i = 1 To mMeasurements.Count
        perfData = mMeasurements(i)
        result = result & vbCrLf & GetMeasurement(perfData.Description)
    Next i
    
    mLock.ReleaseLock
    GetAllMeasurements = result
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "パフォーマンス測定データの取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "clsPerformanceMonitor"
        .ProcedureName = "GetAllMeasurements"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Function

Public Sub ClearMeasurements()
    mLock.AcquireLock
    Set mMeasurements = New Collection
    mLock.ReleaseLock
End Sub

' ======================
' プロパティ
' ======================
Public Property Get IsEnabled() As Boolean
    IsEnabled = mIsEnabled
End Property

Public Property Let IsEnabled(ByVal Value As Boolean)
    mIsEnabled = Value
End Property

Public Property Get CurrentOperation() As String
    CurrentOperation = mCurrentOperation
End Property

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' パフォーマンスカウンターの有効性を検証（テスト用）
    ''' </summary>
    Private Function ValidatePerformanceCounter() As Boolean
        Dim counter As Currency
        ValidatePerformanceCounter = (modWindowsAPI.QueryPerformanceCounter(counter) <> 0) And (mFrequency <> 0)
    End Function
    
    ''' <summary>
    ''' 測定データの数を取得（テスト用）
    ''' </summary>
    Private Function GetMeasurementCount() As Long
        mLock.AcquireLock
        GetMeasurementCount = mMeasurements.Count
        mLock.ReleaseLock
    End Function
    
    ''' <summary>
    ''' テスト用の測定データを追加（テスト用）
    ''' </summary>
    Private Sub SimulateMeasurement(ByVal description As String, ByVal elapsedTime As Double)
        mLock.AcquireLock
        Dim perfData As PerformanceData
        perfData.Description = description
        perfData.ElapsedTime = elapsedTime
        perfData.MemoryUsage = 1000000 ' 1MB
        perfData.PeakMemoryUsage = 2000000 ' 2MB
        mMeasurements.Add perfData, description
        mLock.ReleaseLock
    End Sub
#End If

================
File: templates/ConnectionPool.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ConnectionPool"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "ConnectionPool"

' ======================
' 定数定義
' ======================
Private Const MAX_POOL_SIZE As Long = 5
Private Const CONNECTION_TIMEOUT As Long = 30 ' 秒

' ======================
' メンバ変数
' ======================
Private Type ConnectionInfo
    Connection As Object
    InUse As Boolean
    LastUsed As Date
End Type

Private mConnections() As ConnectionInfo
Private mConnectionString As String
Private mPoolSize As Long
Private mLock As clsLock
Private mPerformanceMonitor As clsPerformanceMonitor
Private mConfig As IDatabaseConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ReDim mConnections(1 To MAX_POOL_SIZE)
    mPoolSize = 0
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
End Sub

Private Sub Class_Terminate()
    Dim i As Long
    For i = 1 To MAX_POOL_SIZE
        If Not mConnections(i).Connection Is Nothing Then
            If mConnections(i).Connection.State = 1 Then ' adStateOpen
                mConnections(i).Connection.Close
            End If
            Set mConnections(i).Connection = Nothing
        End If
    Next i
    Set mLock = Nothing
    Set mConfig = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' パブリックメソッド
' ======================

''' <summary>
''' コネクションプールを初期化します
''' </summary>
''' <param name="config">データベース設定を提供するインターフェース</param>
Public Sub Initialize(ByVal config As IDatabaseConfig)
    Set mConfig = config
    mConnectionString = mConfig.GetConnectionString
End Sub

''' <summary>
''' コネクションを取得します
''' </summary>
''' <returns>データベース接続オブジェクト</returns>
Public Function GetConnection() As Object
    On Error GoTo ErrorHandler
    mPerformanceMonitor.StartMeasurement "Get Database Connection"
    
    mLock.AcquireLock
    
    ' 未使用のコネクションを探す
    Dim i As Long
    For i = 1 To mPoolSize
        If Not mConnections(i).InUse Then
            ' コネクションの状態をチェック
            If ValidateConnection(mConnections(i).Connection) Then
                mConnections(i).InUse = True
                mConnections(i).LastUsed = Now
                Set GetConnection = mConnections(i).Connection
                GoTo Cleanup
            Else
                ' 無効なコネクションを破棄して再作成
                Set mConnections(i).Connection = CreateNewConnection()
                If Not mConnections(i).Connection Is Nothing Then
                    mConnections(i).InUse = True
                    mConnections(i).LastUsed = Now
                    Set GetConnection = mConnections(i).Connection
                    GoTo Cleanup
                End If
            End If
        End If
    Next i
    
    ' 新しいコネクションを作成（プールサイズが上限に達していない場合）
    If mPoolSize < MAX_POOL_SIZE Then
        mPoolSize = mPoolSize + 1
        Set mConnections(mPoolSize).Connection = CreateNewConnection()
        If Not mConnections(mPoolSize).Connection Is Nothing Then
            mConnections(mPoolSize).InUse = True
            mConnections(mPoolSize).LastUsed = Now
            Set GetConnection = mConnections(mPoolSize).Connection
            GoTo Cleanup
        End If
    End If
    
    ' 利用可能なコネクションがない場合はエラー
    Err.Raise vbObjectError + 1, MODULE_NAME, "利用可能なコネクションがありません。"
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Get Database Connection"
    Exit Function
    
ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_DATABASE_CONNECTION_FAILED
        .Description = "コネクション取得中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnection"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    If Not mLock Is Nothing Then mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Get Database Connection"
    Set GetConnection = Nothing
End Function

''' <summary>
''' コネクションを解放します
''' </summary>
''' <param name="connection">解放するコネクション</param>
Public Sub ReleaseConnection(ByVal connection As Object)
    If connection Is Nothing Then Exit Sub
    
    mLock.AcquireLock
    
    Dim i As Long
    For i = 1 To mPoolSize
        If mConnections(i).Connection Is connection Then
            mConnections(i).InUse = False
            mConnections(i).LastUsed = Now
            Exit For
        End If
    Next i
    
    mLock.ReleaseLock
End Sub

' ======================
' プライベートメソッド
' ======================

''' <summary>
''' 新しいデータベース接続を作成します
''' </summary>
Private Function CreateNewConnection() As Object
    On Error GoTo ErrorHandler
    mPerformanceMonitor.StartMeasurement "Create Database Connection"
    
    mLock.AcquireLock
    
    Dim conn As Object
    Set conn = CreateObject("ADODB.Connection")
    conn.ConnectionString = mConnectionString
    conn.ConnectionTimeout = CONNECTION_TIMEOUT
    
    ' データベース接続の作成
    conn.Open
    
    Set CreateNewConnection = conn
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Create Database Connection"
    Exit Function
    
ErrorHandler:
    Set CreateNewConnection = Nothing
    Resume Cleanup
End Function

''' <summary>
''' コネクションが有効かどうかを確認します
''' </summary>
Private Function ValidateConnection(ByVal connection As Object) As Boolean
    If connection Is Nothing Then
        ValidateConnection = False
        Exit Function
    End If
    
    On Error Resume Next
    ValidateConnection = (connection.State = 1) ' adStateOpen
    If Err.Number <> 0 Then
        ValidateConnection = False
    End If
    On Error GoTo 0
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' コネクションプールの現在のサイズを取得（テスト用）
    ''' </summary>
    Private Property Get PoolSize() As Long
        PoolSize = mPoolSize
    End Property
    
    ''' <summary>
    ''' アクティブなコネクション数を取得（テスト用）
    ''' </summary>
    Private Property Get ActiveConnections() As Long
        Dim count As Long
        Dim i As Long
        For i = 1 To mPoolSize
            If mConnections(i).InUse Then count = count + 1
        Next i
        ActiveConnections = count
    End Property
    
    ''' <summary>
    ''' コネクションプールをクリア（テスト用）
    ''' </summary>
    Private Sub ClearPool()
        Class_Terminate
        Class_Initialize
    End Sub
#End If

================
File: templates/DatabaseConnectionErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DatabaseConnectionErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DatabaseConnectionErrorHandler"

' ======================
' 定数定義
' ======================
Private Const DEFAULT_RETRY_INTERVAL As Long = 1000 ' ミリ秒
Private Const MAX_RETRY_COUNT As Long = 3

' ======================
' プライベート変数
' ======================
Private mConnectionString As String
Private mConfig As IDatabaseConfig
Private mLock As clsLock

Implements IErrorHandler

' ======================
' シングルトンインスタンス
' ======================
Private Shared instance As DatabaseConnectionErrorHandler

' ======================
' 初期化処理
' ======================
Public Sub Initialize(ByVal config As IDatabaseConfig)
    If config Is Nothing Then Exit Sub
    Set mConfig = config
    Set mLock = New clsLock
    mConnectionString = mConfig.GetConnectionString
End Sub


' ======================
' ファクトリメソッド
' ======================
Public Function Create() As DatabaseConnectionErrorHandler
    On Error GoTo ErrorHandler
    
    If instance Is Nothing Then
        Set instance = New DatabaseConnectionErrorHandler
        instance.Initialize config
    End If
    Set Create = instance
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースエラーハンドラの作成中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "Create"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set Create = Nothing
End Function

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As ErrorInfo) As Boolean
    Dim proceed As Boolean
    proceed = False  ' デフォルトでは処理を中断
    
    mLock.AcquireLock
    
    ' エラー情報をログに記録
    LogError errorDetail
    mLock.ReleaseLock
    
    ' リトライ処理の実行
    If AttemptRetry(errorDetail) Then
        proceed = True  ' リトライ成功
    Else
        ' リトライ失敗時はユーザーに通知
        NotifyUser errorDetail, vbCritical
    End If
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Function AttemptRetry(ByRef errorDetail As ErrorInfo) As Boolean
    On Error GoTo ErrorHandler
    
    Dim isLocked As Boolean
    Dim retryCount As Long
    Dim success As Boolean
    
    For retryCount = 1 To MAX_RETRY_COUNT
        ' リトライ間隔を設ける
        Wait DEFAULT_RETRY_INTERVAL
        
        If TryDatabaseConnection Then
            success = True
            Exit For
        End If
        
        mLock.AcquireLock
        isLocked = True
        
        ' リトライ試行をログに記録
        Dim loggerSettings As DefaultLoggerSettings
        Set loggerSettings = New DefaultLoggerSettings
        loggerSettings.Initialize mConnectionString
        With New clsLogger
            .Configure loggerSettings
            .Log MODULE_NAME, _
                 "データベース接続リトライ " & retryCount & "/" & MAX_RETRY_COUNT, _
                 errorDetail.Code
        End With
        
        mLock.ReleaseLock
        isLocked = False
    Next retryCount
    
    AttemptRetry = success
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベース接続のリトライ中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "AttemptRetry"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    GoTo Cleanup

Cleanup:
    If isLocked Then
        mLock.ReleaseLock
    End If
    AttemptRetry = False
    Exit Function
End Function

Private Function TryDatabaseConnection() As Boolean
    On Error GoTo ErrorHandler
    
    Dim conn As Object
    Set conn = CreateObject("ADODB.Connection")
       conn.Open mConnectionString
    
    ' 接続テストのためのシンプルなクエリを実行
        conn.Execute "SELECT 1"
        
        conn.Close
        TryDatabaseConnection = True
        Exit Function
        
    ErrorHandler:
        Dim errNum As Long
        errNum = Err.Number
        
        ' エラー種別に応じた処理
        Select Case errNum
            Case -2147467259  ' ネットワークエラー
                LogSpecificError "ネットワーク接続エラー: サーバーに接続できません。", ECNetwork
            Case -2147217843  ' タイムアウト
                LogSpecificError "データベース接続がタイムアウトしました。", ECNetwork
            Case -2147217865  ' 認証エラー
                LogSpecificError "データベース認証エラー: ユーザー名またはパスワードが無効です。", ECSecurity
            Case Else
                LogSpecificError "データベース接続エラー: " & Err.Description, ECDatabase
        End Select
        
        If Not conn Is Nothing Then
            If conn.State = 1 Then  ' adStateOpen
                conn.Close
            End If
    End If
    Set conn = Nothing
    TryDatabaseConnection = False
        Exit Function
    End Function
    
    Private Sub LogSpecificError(ByVal message As String, ByVal category As ErrorCodeCategory)
        Dim errDetail As ErrorInfo
        With errDetail
            .Code = ErrDbConnectionFailed
            .Description = message
            .Category = category
            .Source = MODULE_NAME
            .ProcedureName = "TryDatabaseConnection"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
    End Sub

Private Sub LogError(ByRef errorDetail As ErrorInfo)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' エラーログの出力
    Dim loggerSettings As DefaultLoggerSettings
    Set loggerSettings = New DefaultLoggerSettings
    loggerSettings.Initialize mConnectionString
    With New clsLogger
        .Configure loggerSettings
    
    .Log MODULE_NAME, _
             "データベース接続エラー: " & errorDetail.Description, _
             errorDetail.Code
    End With
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースエラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As ErrorInfo, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    ' ユーザーへの通知
    Dim notifier As IUserNotifier
    Set notifier = New MsgBoxNotifier
    
    notifier.Notify errorDetail, style, "データベースエラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースエラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub Wait(ByVal milliseconds As Long)
    ' Sleep APIを使用して待機
    modWindowsAPI.Sleep milliseconds
End Sub

================
File: templates/DateValidator.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DateValidator"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DateValidator"

' ======================
' インターフェース実装
' ======================
Implements IValidator

' ======================
' プライベート変数
' ======================
Private mErrorMessage As String
Private mMinDate As Date
Private mMaxDate As Date
Private mAllowFutureDate As Boolean
Private mAllowPastDate As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mMinDate = DateSerial(1900, 1, 1)
    mMaxDate = DateSerial(9999, 12, 31)
    mAllowFutureDate = True
    mAllowPastDate = True
    mErrorMessage = ""
End Sub

' ======================
' プロパティ
' ======================
Public Property Let MinDate(ByVal value As Date)
    mMinDate = value
End Property

Public Property Get MinDate() As Date
    MinDate = mMinDate
End Property

Public Property Let MaxDate(ByVal value As Date)
    mMaxDate = value
End Property

Public Property Get MaxDate() As Date
    MaxDate = mMaxDate
End Property

Public Property Let AllowFutureDate(ByVal value As Boolean)
    mAllowFutureDate = value
End Property

Public Property Get AllowFutureDate() As Boolean
    AllowFutureDate = mAllowFutureDate
End Property

Public Property Let AllowPastDate(ByVal value As Boolean)
    mAllowPastDate = value
End Property

Public Property Get AllowPastDate() As Boolean
    AllowPastDate = mAllowPastDate
End Property

Private Property Get IValidator_ErrorMessage() As String
    IValidator_ErrorMessage = mErrorMessage
End Property

' ======================
' メソッド
' ======================
Private Function IValidator_Validate(ByVal value As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    ' 日付型チェック
    If Not IsDate(value) Then
        mErrorMessage = "有効な日付形式ではありません。"
        IValidator_Validate = False
        Exit Function
    End If
    
    Dim dateValue As Date
    dateValue = CDate(value)
    
    ' 範囲チェック
    If dateValue < mMinDate Then
        mErrorMessage = "日付が古すぎます。" & Format$(mMinDate, "yyyy/mm/dd") & "以降の日付を指定してください。"
        IValidator_Validate = False
        Exit Function
    End If
    
    If dateValue > mMaxDate Then
        mErrorMessage = "日付が新しすぎます。" & Format$(mMaxDate, "yyyy/mm/dd") & "以前の日付を指定してください。"
        IValidator_Validate = False
        Exit Function
    End If
    
    ' 未来日付チェック
    If Not mAllowFutureDate And dateValue > Date Then
        mErrorMessage = "未来の日付は指定できません。"
        IValidator_Validate = False
        Exit Function
    End If
    
    ' 過去日付チェック
    If Not mAllowPastDate And dateValue < Date Then
        mErrorMessage = "過去の日付は指定できません。"
        IValidator_Validate = False
        Exit Function
    End If
    
    mErrorMessage = ""
    IValidator_Validate = True
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "日付の検証中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IValidator_Validate"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    mErrorMessage = "検証中に予期せぬエラーが発生しました。"
    IValidator_Validate = False
End Function

' ======================
' ファクトリメソッド
' ======================
Public Function CreateBirthDateValidator() As DateValidator
    Set CreateBirthDateValidator = New DateValidator
    With CreateBirthDateValidator
        .MinDate = DateSerial(1900, 1, 1)
        .MaxDate = Date
        .AllowFutureDate = False
    End With
End Function

Public Function CreateExpiryDateValidator() As DateValidator
    Set CreateExpiryDateValidator = New DateValidator
    With CreateExpiryDateValidator
        .MinDate = Date
        .MaxDate = DateAdd("yyyy", 100, Date)
        .AllowPastDate = False
    End With
End Function

================
File: templates/DefaultLoggerSettings.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DefaultLoggerSettings"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILoggerSettings

' ======================
' メンバ変数
' ======================
Private mLogLevel As LogLevelEnum
Private mLogDestination As ILogDestination
Private mLogFilePath As String
Private mLogTableName As String
Private mLogEventSource As String
Private mTimerInterval As Long
Private mConnectionString As String

' ======================
' 初期化・終了処理
' ======================
''' <summary>
''' ロガー設定を初期化します。
''' </summary>
''' <param name="connectionString">データベース接続文字列（オプション）。
''' 指定しない場合、ファイルログのみが有効になります。</param>
''' <param name="logLevel">ログレベル（オプション、デフォルト：INFO）</param>
''' <param name="logFilePath">ログファイルパス（オプション、デフォルト：アプリケーションパス）</param>
''' <param name="logTableName">ログテーブル名（オプション、デフォルト：AppLog）</param>
''' <param name="logEventSource">イベントソース名（オプション、デフォルト：アプリケーション名）</param>
''' <param name="timerInterval">タイマー間隔（オプション、デフォルト：1000ms）</param>
Public Sub Initialize(ByVal connectionString As String, _
                     Optional ByVal logLevel As LogLevelEnum = LOG_LEVEL_INFO, _
                     Optional ByVal logFilePath As String = "", _
                     Optional ByVal logTableName As String = "AppLog", _
                     Optional ByVal logEventSource As String = "", _
                     Optional ByVal timerInterval As Long = 1000)
    On Error GoTo ErrorHandler
    
    mLogLevel = logLevel
    Set mLogDestination = New FileLogDestination
    mLogFilePath = IIf(logFilePath = "", App.Path & "\" & DEFAULT_LOG_FILE, logFilePath)
    mLogTableName = logTableName
    mLogEventSource = IIf(logEventSource = "", APPLICATION_NAME, logEventSource)
    mTimerInterval = timerInterval
    mConnectionString = connectionString
    
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "ロガー設定の初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "DefaultLoggerSettings"
        .ProcedureName = "Class_Initialize"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub Class_Initialize()
    ' デフォルト設定で初期化
    Initialize "", LOG_LEVEL_INFO, "", "AppLog", "", 1000
End Sub

Private Sub Class_Terminate()
    Set mLogDestination = Nothing
End Sub

' ======================
' ILoggerSettings実装
' ======================
Private Property Get ILoggerSettings_LogLevel() As LogLevelEnum
    ILoggerSettings_LogLevel = mLogLevel
End Property

Private Property Get ILoggerSettings_LogDestination() As ILogDestination
    Set ILoggerSettings_LogDestination = mLogDestination
End Property

Private Property Get ILoggerSettings_LogFilePath() As String
    ILoggerSettings_LogFilePath = mLogFilePath
End Property

Private Property Get ILoggerSettings_LogTableName() As String
    ILoggerSettings_LogTableName = mLogTableName
End Property

Private Property Get ILoggerSettings_LogEventSource() As String
    ILoggerSettings_LogEventSource = mLogEventSource
End Property

Private Property Get ILoggerSettings_TimerInterval() As Long
    ILoggerSettings_TimerInterval = mTimerInterval
End Property

Private Property Get ILoggerSettings_ConnectionString() As String
    ILoggerSettings_ConnectionString = mConnectionString
End Property

' ======================
' パブリックプロパティ
' ======================
Public Property Let LogLevel(ByVal Value As LogLevelEnum)
    mLogLevel = Value
End Property

Public Property Set LogDestination(ByVal Value As ILogDestination)
    Set mLogDestination = Value
End Property

Public Property Let LogFilePath(ByVal Value As String)
    mLogFilePath = Value
End Property

Public Property Let LogTableName(ByVal Value As String)
    mLogTableName = Value
End Property

Public Property Let LogEventSource(ByVal Value As String)
    mLogEventSource = Value
End Property

Public Property Let TimerInterval(ByVal Value As Long)
    mTimerInterval = Value
End Property

Public Property Let ConnectionString(ByVal Value As String)
    mConnectionString = Value
End Property

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
''' <summary>
''' デバッグ用の設定を作成（テスト用）
''' 詳細なログ出力と高頻度な更新を行う設定を生成します
''' </summary>
Private Function CreateDebugSettings() As DefaultLoggerSettings
    On Error GoTo ErrorHandler
    
    Set CreateDebugSettings = New DefaultLoggerSettings
    With CreateDebugSettings
        .LogLevel = LOG_LEVEL_DEBUG
        Set .LogDestination = New ConsoleLogDestination
        .TimerInterval = 100 ' より頻繁な更新
    End With
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "デバッグ用ロガー設定の作成中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "DefaultLoggerSettings"
        .ProcedureName = "CreateDebugSettings"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set CreateDebugSettings = Nothing
End Function

''' <summary>
''' 本番用の設定を作成（テスト用）
''' 標準的なログレベルと低頻度な更新を行う設定を生成します
''' </summary>
Private Function CreateProductionSettings() As DefaultLoggerSettings
    On Error GoTo ErrorHandler
    
    Set CreateProductionSettings = New DefaultLoggerSettings
    With CreateProductionSettings
        .LogLevel = LOG_LEVEL_INFO
        Set .LogDestination = New FileLogDestination
        .TimerInterval = 5000 ' より低頻度な更新
    End With
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "本番用ロガー設定の作成中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "DefaultLoggerSettings"
        .ProcedureName = "CreateProductionSettings"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set CreateProductionSettings = Nothing
End Function

''' <summary>
''' データベースログ用の設定を作成（テスト用）
''' データベースへのログ出力に特化した設定を生成します
''' </summary>
Private Function CreateDatabaseSettings() As DefaultLoggerSettings
    On Error GoTo ErrorHandler
    
    Set CreateDatabaseSettings = New DefaultLoggerSettings
    With CreateDatabaseSettings
        .LogLevel = LOG_LEVEL_INFO
        Set .LogDestination = New DatabaseLogDestination
        .LogTableName = "SystemLog"
        .TimerInterval = 2000
    End With
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "データベース用ロガー設定の作成中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = "DefaultLoggerSettings"
        .ProcedureName = "CreateDatabaseSettings"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set CreateDatabaseSettings = Nothing
End Function
#End If

================
File: templates/FileLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileLogger"

' ======================
' インターフェース実装
' ======================
Implements ILogger

' ======================
' プライベート変数
' ======================
Private mLogLevel As LogLevel
Private mLogDestination As LogDestination
Private mLogFilePath As String
Private mLock As clsLock
Private mPerformanceMonitor As clsPerformanceMonitor

' ======================
' 初期化・終了処理
' ======================
Public Sub Initialize(ByVal settings As ILoggerSettings)
    mLogLevel = LevelInfo
    mLogDestination = DestFile
    mLogFilePath = settings.LogFilePath
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
End Sub

Private Sub Class_Initialize()
    ' 初期化は Initialize メソッドで行う
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal moduleName As String, _
                       ByVal message As String, _
                       Optional ByVal errorCode As ErrorCode)
    ' ログレベルチェック
    If Not ShouldLog(errorCode) Then Exit Sub
    
    ' ログ出力の排他制御
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim logMessage As String
    logMessage = BuildLogMessage(moduleName, message, errorCode)
    
    mPerformanceMonitor.StartMeasurement "File Write Operation"
    ' modFileIOを使用してファイルに書き込み
    modFileIO.WriteTextFile mLogFilePath, logMessage & vbCrLf, True
    
CleanUp:
    mLock.ReleaseLock
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "File Write Operation"
    End If
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileAccessDenied
        .Description = "ログファイルへの書き込み中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "File Write Operation"
    End If
    Resume CleanUp
End Sub

Private Property Let ILogger_LogLevel(ByVal level As LogLevel)
    mLogLevel = level
End Property

Private Property Get ILogger_LogLevel() As LogLevel
    ILogger_LogLevel = mLogLevel
End Property

Private Property Let ILogger_LogDestination(ByVal destination As LogDestination)
    mLogDestination = destination
End Property

Private Property Get ILogger_LogDestination() As LogDestination
    ILogger_LogDestination = mLogDestination
End Property

' ======================
' プライベートメソッド
' ======================
Private Function GetLogLevelForErrorCode(ByVal errorCode As ErrorCode) As LogLevel
    Select Case errorCode
        Case ErrUnexpected, ErrSystemOutOfMemory
            GetLogLevelForErrorCode = LevelFatal
        Case ErrDbConnectionFailed, ErrNetworkError
            GetLogLevelForErrorCode = LevelError
        Case ErrFileNotFound, ErrInvalidInput
            GetLogLevelForErrorCode = LevelWarning
        Case Else
            GetLogLevelForErrorCode = LevelInfo
    End Select
End Function

Private Function ShouldLog(ByVal errorCode As ErrorCode) As Boolean
    ' エラーコードからログレベルを判断
    Dim level As LogLevel    
    level = GetLogLevelForErrorCode(errorCode)    
    ShouldLog = (level >= mLogLevel)
End Function

Private Function BuildLogMessage(ByVal moduleName As String, _
                               ByVal message As String, _
                               ByVal errorCode As ErrorCode) As String
    Dim builder As String
    
    ' タイムスタンプ
    builder = Format$(Now, DEFAULT_DATETIME_FORMAT) & " "
    
    ' ログレベル
    builder = builder & "[" & GetLogLevelText(errorCode) & "] "
    
    ' モジュール名
    builder = builder & "[" & moduleName & "] "
    
    ' エラーコード（存在する場合）
    If errorCode <> 0 Then
        builder = builder & "(Code: " & errorCode & ") "
    End If
    
    ' メッセージ本体
    builder = builder & message
    
    BuildLogMessage = builder
End Function

Private Function GetLogLevelText(ByVal errorCode As ErrorCode) As String
    ' エラーコードに対応するログレベルを取得し、テキストに変換
    Dim level As LogLevel
    level = GetLogLevelForErrorCode(errorCode
)
    
    Select Case level
        Case LevelFatal
            GetLogLevelText = "FATAL"
        Case LevelError
            GetLogLevelText = "ERROR"
        Case LevelWarning
            GetLogLevelText = "WARNING"
        Case LevelInfo
            GetLogLevelText = "INFO"
    End Select
End Function

================
File: templates/FileNotFoundErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileNotFoundErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileNotFoundErrorHandler"

' ======================
' プライベート変数
' ======================
Private mLock As clsLock

Implements IErrorHandler

' ======================
' シングルトンインスタンス
' ======================
Private Shared instance As FileNotFoundErrorHandler

' ======================
' 初期化処理
' ======================
Private Sub Class_Initialize()
    Set mLock = New clsLock
End Sub

' ======================
' ファクトリメソッド
' ======================
Public Function Create() As FileNotFoundErrorHandler
    On Error GoTo ErrorHandler
    
    If instance Is Nothing Then
        Set instance = New FileNotFoundErrorHandler
    End If
    Set Create = instance
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "ファイルエラーハンドラの作成中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "Create"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set Create = Nothing
End Function

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As typErrorDetail) As Boolean
    Dim proceed As Boolean
    proceed = False  ' デフォルトでは処理を中断
    
    mLock.AcquireLock
    
    ' エラー情報をログに記録
    LogError errorDetail
    mLock.ReleaseLock
    
    ' ユーザーに通知
    NotifyUser errorDetail, vbExclamation
    
    ' 代替ファイルパスの確認や、ファイル作成の試行など、
    ' ファイル不在時の回復処理をここに実装可能
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByRef errorDetail As typErrorDetail)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' エラーログの出力
    With New clsLogger
        .Configure New DefaultLoggerSettings
    
        .Log MODULE_NAME, _
             "ファイルが見つかりません: " & errorDetail.Description, _
             errorDetail.ErrorCode
    End With
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "ファイルエラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As typErrorDetail, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    ' ユーザーへの通知
    Dim notifier As IUserNotifier
    Set notifier = New MsgBoxNotifier  ' または適切な通知実装を使用
    
    notifier.Notify errorDetail, style, "ファイルエラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "ファイルエラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

================
File: templates/FileSystemOperations.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileSystemOperations"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileSystemOperations"

' ======================
' インターフェース実装
' ======================
Implements IFileOperations

' ======================
' プライベート変数
' ======================
Private mLock As clsLock
Private mIsInitialized As Boolean
Private mPerformanceMonitor As clsPerformanceMonitor

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 必要なモジュールの初期化を確認
    If Not modFileIO.IsInitialized Then
        modFileIO.InitializeModule
    End If
    modFileIO.SetFileSystemLock mLock
    
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    mIsInitialized = False
End Sub

Private Sub InitializeIfNeeded()
    If Not mIsInitialized Then
        Class_Initialize
    End If
End Sub

' ======================
' IFileOperations実装
' ======================
Private Function IFileOperations_ReadTextFile(ByVal filePath As String, _
                                            Optional ByVal encoding As String) As String
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Read Text File"
    On Error GoTo ErrorHandler
    IFileOperations_ReadTextFile = modFileIO.ReadTextFile(filePath, encoding)
    mPerformanceMonitor.EndMeasurement "Read Text File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Read Text File"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_WriteTextFile(ByVal filePath As String, _
                                             ByVal content As String, _
                                             Optional ByVal append As Boolean = False, _
                                             Optional ByVal encoding As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Write Text File"
    On Error GoTo ErrorHandler
    IFileOperations_WriteTextFile = modFileIO.WriteTextFile(filePath, content, append, encoding)
    mPerformanceMonitor.EndMeasurement "Write Text File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Write Text File"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_ReadBinaryFile(ByVal filePath As String) As Byte()
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Read Binary File"
    On Error GoTo ErrorHandler
    IFileOperations_ReadBinaryFile = modFileIO.ReadBinaryFile(filePath)
    mPerformanceMonitor.EndMeasurement "Read Binary File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Read Binary File"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_WriteBinaryFile(ByVal filePath As String, _
                                               ByRef data() As Byte) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Write Binary File"
    On Error GoTo ErrorHandler
    IFileOperations_WriteBinaryFile = modFileIO.WriteBinaryFile(filePath, data)
    mPerformanceMonitor.EndMeasurement "Write Binary File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Write Binary File"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_FileExists(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    IFileOperations_FileExists = modFileIO.FileExists(filePath)
End Function

Private Function IFileOperations_FolderExists(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    IFileOperations_FolderExists = modFileIO.FolderExists(folderPath)
End Function

Private Function IFileOperations_CreateFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Create Folder"
    On Error GoTo ErrorHandler
    IFileOperations_CreateFolder = modFileIO.CreateFolder(folderPath)
    mPerformanceMonitor.EndMeasurement "Create Folder"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Create Folder"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_DeleteFile(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Delete File"
    On Error GoTo ErrorHandler
    IFileOperations_DeleteFile = modFileIO.DeleteFile(filePath)
    mPerformanceMonitor.EndMeasurement "Delete File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Delete File"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_DeleteFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Delete Folder"
    On Error GoTo ErrorHandler
    IFileOperations_DeleteFolder = modFileIO.DeleteFolder(folderPath)
    mPerformanceMonitor.EndMeasurement "Delete Folder"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Delete Folder"
    Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Function IFileOperations_GetAbsolutePath(ByVal relativePath As String, _
                                               Optional ByVal basePath As String) As String
    InitializeIfNeeded
    IFileOperations_GetAbsolutePath = modFileIO.GetAbsolutePath(relativePath, basePath)
End Function

' ======================
' パブリックメソッド
' ======================
Public Function CreateInstance() As IFileOperations
    Set CreateInstance = New FileSystemOperations
End Function

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        Class_Terminate
        Class_Initialize
    End Sub
    
    ''' <summary>
    ''' 初期化状態を取得（テスト用）
    ''' </summary>
    Private Property Get IsInitialized() As Boolean
        IsInitialized = mIsInitialized
    End Property
#End If

================
File: templates/IDatabaseConfig.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IDatabaseConfig"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

''' <summary>
''' データベース接続設定へのアクセスを提供するインターフェース
''' </summary>

''' <summary>
''' データベース接続文字列を取得します
''' </summary>
''' <returns>データベース接続文字列</returns>
Public Function GetConnectionString() As String
End Function

================
File: templates/IErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' エラーハンドラーインターフェース
' ======================

''' <summary>
''' エラーを処理します
''' </summary>
''' <param name="errorDetail">エラー詳細情報</param>
''' <returns>処理を継続する場合はTrue、中断する場合はFalse</returns>
''' <remarks>
''' このインターフェースを実装するクラスは、以下の点に注意してエラー処理を実装する必要があります：
''' 
''' 1. エラーログの記録
'''    - エラー情報は必ずログに記録してください
'''    - ログ出力自体が失敗した場合の代替手段を用意してください（例：Debug.Print）
''' 
''' 2. リソースの適切な解放
'''    - エラー発生時でもリソースが確実に解放されるようにしてください
'''    - Using/With構文やOn Error構文を適切に使用してください
''' 
''' 3. エラーの伝播
'''    - 上位層に伝播すべきエラーかどうかを適切に判断してください
'''    - 回復可能なエラーの場合は、適切な回復処理を実装してください
''' 
''' 4. ユーザーへの通知
'''    - エラーの重要度に応じて、適切な通知方法を選択してください
'''    - 機密情報が含まれないよう注意してください
''' 
''' 5. エラー情報の補完
'''    - スタックトレースなど、デバッグに有用な情報を付加してください
'''    - エラーコードやカテゴリを適切に設定してください
''' </remarks>
Public Function HandleError(ByRef errorDetail As ErrorInfo) As Boolean
End Function

================
File: templates/IFileOperations.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IFileOperations"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' ファイル操作インターフェース
' ======================

''' <remarks>
''' このインターフェースを実装するクラスは、以下のエラー処理を実装する必要があります：
'''
''' 1. 共通のエラー処理要件
'''    - ファイルパスの検証（存在確認、アクセス権限、パス長など）
'''    - ファイルロックの適切な管理
'''    - リソースの確実な解放（ファイルハンドルなど）
'''    - エラー情報の適切なログ記録
'''    - エラーの種類に応じた適切なエラーコードの設定
'''
''' 2. エラー発生時の戻り値
'''    - Boolean型を返すメソッド：失敗時はFalseを返す
'''    - String型を返すメソッド：エラー時は空文字列を返す
'''    - バイト配列を返すメソッド：エラー時は空配列を返す
'''
''' 3. エラーの種類と対応
'''    - ErrFileNotFound: ファイルが存在しない
'''    - ErrFileAccessDenied: アクセス権限がない
'''    - ErrFileInvalidFormat: ファイル形式が不正
'''    - その他のシステムエラー
''' </remarks>

' テキストファイル操作
''' <summary>
''' テキストファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>ファイルの内容、エラー時は空文字列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルの存在確認
''' - エンコーディングの検証
''' - ファイルロックの確認
''' - メモリ不足への対応
''' </remarks>
Public Function ReadTextFile(ByVal filePath As String, _
                           Optional ByVal encoding As String) As String
End Function

''' <summary>
''' テキストファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="content">書き込む内容</param>
''' <param name="append">追記モード（オプション）</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - 書き込み権限の確認
''' - ディスク容量の確認
''' - 既存ファイルのバックアップ
''' - 書き込み失敗時の復旧処理
''' </remarks>
Public Function WriteTextFile(ByVal filePath As String, _
                            ByVal content As String, _
                            Optional ByVal append As Boolean = False, _
                            Optional ByVal encoding As String) As Boolean
End Function

' バイナリファイル操作
''' <summary>
''' バイナリファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <returns>ファイルのバイトデータ、エラー時は空配列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルサイズの検証
''' - メモリ使用量の監視
''' - 破損ファイルの検出
''' </remarks>
Public Function ReadBinaryFile(ByVal filePath As String) As Byte()
End Function

''' <summary>
''' バイナリファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="data">書き込むバイトデータ</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - データの整合性チェック
''' - 部分書き込みの防止
''' - 書き込み失敗時のロールバック
''' </remarks>
Public Function WriteBinaryFile(ByVal filePath As String, _
                              ByRef data() As Byte) As Boolean
End Function

' ファイルシステム操作
''' <summary>
''' ファイルの存在を確認します
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <returns>存在する場合True、それ以外はFalse</returns>
''' <remarks>
''' エラー処理要件：
''' - パスの妥当性検証
''' - アクセス権限の確認
''' - ネットワークパスの考慮
''' </remarks>
Public Function FileExists(ByVal filePath As String) As Boolean
End Function

''' <summary>
''' フォルダの存在を確認します
''' </summary>
''' <param name="folderPath">フォルダパス</param>
''' <returns>存在する場合True、それ以外はFalse</returns>
''' <remarks>
''' エラー処理要件：
''' - パスの妥当性検証
''' - アクセス権限の確認
''' - シンボリックリンクの考慮
''' </remarks>
Public Function FolderExists(ByVal folderPath As String) As Boolean
End Function

''' <summary>
''' フォルダを作成します
''' </summary>
''' <param name="folderPath">フォルダパス</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - 親フォルダの存在確認
''' - 作成権限の確認
''' - 既存フォルダの処理
''' </remarks>
Public Function CreateFolder(ByVal folderPath As String) As Boolean
End Function

''' <summary>
''' ファイルを削除します
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - 削除権限の確認
''' - ファイルロックの確認
''' - 読み取り専用属性の処理
''' </remarks>
Public Function DeleteFile(ByVal filePath As String) As Boolean
End Function

''' <summary>
''' フォルダを削除します
''' </summary>
''' <param name="folderPath">フォルダパス</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - フォルダの空確認
''' - 削除権限の確認
''' - サブフォルダの処理
''' </remarks>
Public Function DeleteFolder(ByVal folderPath As String) As Boolean
End Function

' パス操作
''' <summary>
''' 相対パスから絶対パスを取得します
''' </summary>
''' <param name="relativePath">相対パス</param>
''' <param name="basePath">基準パス（オプション）</param>
''' <returns>絶対パス、エラー時は空文字列</returns>
''' <remarks>
''' エラー処理要件：
''' - パスの妥当性検証
''' - 循環参照の検出
''' - パス長の制限チェック
''' </remarks>
Public Function GetAbsolutePath(ByVal relativePath As String, _
                              Optional ByVal basePath As String) As String
End Function

================
File: templates/ILogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ILogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' ロガーインターフェース
' ======================

''' <remarks>
''' このインターフェースを実装するクラスは、以下のエラー処理を実装する必要があります：
'''
''' 1. 出力先別のエラー処理
'''    - ファイル出力
'''      * ファイルのロック状態確認
'''      * ディスク容量の確認
'''      * アクセス権限の確認
'''      * 出力失敗時の代替出力先（例：一時ファイル）の使用
'''
'''    - データベース出力
'''      * 接続状態の確認
'''      * トランザクション管理
'''      * デッドロック対策
'''      * 接続失敗時の再試行
'''
'''    - イベントログ出力
'''      * イベントソースの存在確認
'''      * 書き込み権限の確認
'''      * イベントログ容量の確認
'''
'''    - コンソール出力
'''      * 出力バッファのオーバーフロー対策
'''      * 文字コードの互換性確認
'''
''' 2. エラー発生時の動作
'''    - エラーの重大度に応じた適切な処理
'''    - 代替出力先への切り替え
'''    - エラー情報自体のログ記録
'''    - 上位層へのエラー通知
'''
''' 3. パフォーマンスとリソース管理
'''    - ログキューのオーバーフロー対策
'''    - リソースの適切な解放
'''    - 非同期出力時のエラー処理
'''
''' 4. データ検証
'''    - メッセージ長の制限
'''    - 不正な文字の除去
'''    - NULLや空文字の適切な処理
''' </remarks>

''' <summary>
''' ログを記録します
''' </summary>
''' <param name="moduleName">モジュール名</param>
''' <param name="message">ログメッセージ</param>
''' <param name="errorCode">エラーコード（オプション）</param>
''' <remarks>
''' エラー処理要件：
''' - パラメータの検証（NULL、空文字、最大長など）
''' - 出力先の状態確認
''' - エラー発生時の代替処理
''' - リトライメカニズムの実装
''' </remarks>
Public Sub Log(ByVal moduleName As String, _
               ByVal message As String, _
               Optional ByVal errorCode As ErrorCode)
End Sub

''' <summary>
''' ログレベルを設定します
''' </summary>
''' <param name="level">ログレベル</param>
''' <remarks>
''' エラー処理要件：
''' - 無効なログレベルの検証
''' - 設定変更時のログ出力
''' - 現在処理中のログへの影響考慮
''' </remarks>
Public Property Let LogLevel(ByVal level As LogLevel)
End Property

''' <summary>
''' 現在のログレベルを取得します
''' </summary>
''' <returns>ログレベル</returns>
''' <remarks>
''' エラー処理要件：
''' - 初期化状態の確認
''' - デフォルト値の適切な提供
''' </remarks>
Public Property Get LogLevel() As LogLevel
End Property

''' <summary>
''' ログの出力先を設定します
''' </summary>
''' <param name="destination">ログの出力先</param>
''' <remarks>
''' エラー処理要件：
''' - 出力先の有効性確認
''' - 出力先の状態確認
''' - 切り替え時の未処理ログの扱い
''' - 設定変更のトランザクション管理
''' </remarks>
Public Property Let LogDestination(ByVal destination As LogDestination)
End Property

''' <summary>
''' 現在のログ出力先を取得します
''' </summary>
''' <returns>ログの出力先</returns>
''' <remarks>
''' エラー処理要件：
''' - 初期化状態の確認
''' - 出力先の状態確認
''' - デフォルト値の適切な提供
''' </remarks>
Public Property Get LogDestination() As LogDestination
End Property

================
File: templates/ILoggerSettings.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ILoggerSettings"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' ロガー設定インターフェース
' ======================

''' <remarks>
''' このインターフェースを実装するクラスは、以下のエラー処理を実装する必要があります：
'''
''' 1. 設定値の検証
'''    - NULL値のチェック
'''    - 範囲外の値の検出
'''    - 不正なフォーマットの検出
'''    - 依存関係のある設定値の整合性確認
'''
''' 2. 設定ファイルの処理
'''    - ファイルの存在確認
'''    - 読み取り権限の確認
'''    - 破損ファイルの検出と修復
'''    - デフォルト値の適切な提供
'''
''' 3. 設定変更の管理
'''    - 変更のトランザクション管理
'''    - 変更履歴の記録
'''    - 設定の整合性維持
'''    - 他のコンポーネントへの通知
'''
''' 4. エラー発生時の動作
'''    - デフォルト値の使用
'''    - エラーのログ記録
'''    - 上位層への通知
'''    - リカバリ処理の実行
''' </remarks>

''' <summary>
''' ログレベルを取得します
''' </summary>
''' <returns>ログレベル</returns>
''' <remarks>
''' エラー処理要件：
''' - 未初期化状態の検出
''' - 無効な設定値の検出
''' - デフォルト値の提供
''' </remarks>
Public Property Get LogLevel() As LogLevelEnum
End Property

''' <summary>
''' ログ出力先を取得します
''' </summary>
''' <returns>ログ出力先</returns>
''' <remarks>
''' エラー処理要件：
''' - 出力先の有効性確認
''' - 出力先の状態確認
''' - 必要なリソースの確認
''' </remarks>
Public Property Get LogDestination() As ILogDestination
End Property

''' <summary>
''' ログファイルパスを取得します
''' </summary>
''' <returns>ログファイルパス</returns>
''' <remarks>
''' エラー処理要件：
''' - パスの妥当性検証
''' - アクセス権限の確認
''' - ディスク容量の確認
''' - 代替パスの提供
''' </remarks>
Public Property Get LogFilePath() As String
End Property

''' <summary>
''' ログテーブル名を取得します
''' </summary>
''' <returns>ログテーブル名</returns>
''' <remarks>
''' エラー処理要件：
''' - テーブル名の妥当性確認
''' - テーブルの存在確認
''' - テーブル構造の検証
''' - 権限の確認
''' </remarks>
Public Property Get LogTableName() As String
End Property

''' <summary>
''' ログイベントソースを取得します
''' </summary>
''' <returns>イベントソース名</returns>
''' <remarks>
''' エラー処理要件：
''' - イベントソースの存在確認
''' - 登録権限の確認
''' - ソース名の妥当性検証
''' - 代替ソースの提供
''' </remarks>
Public Property Get LogEventSource() As String
End Property

''' <summary>
''' タイマー間隔を取得します
''' </summary>
''' <returns>タイマー間隔（ミリ秒）</returns>
''' <remarks>
''' エラー処理要件：
''' - 範囲チェック（最小値、最大値）
''' - システムリソースの考慮
''' - パフォーマンスへの影響評価
''' </remarks>
Public Property Get TimerInterval() As Long
End Property

''' <summary>
''' データベース接続文字列を取得します
''' </summary>
''' <returns>接続文字列</returns>
''' <remarks>
''' エラー処理要件：
''' - 接続文字列の妥当性確認
''' - 機密情報の保護
''' - 接続テストの実行
''' - フォールバック設定の提供
''' </remarks>
Public Property Get ConnectionString() As String
End Property

================
File: templates/InvalidInputErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "InvalidInputErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "InvalidInputErrorHandler"

' ======================
' プライベート変数
' ======================
Private mLock As clsLock

Implements IErrorHandler

' ======================
' シングルトンインスタンス
' ======================
Private Shared instance As InvalidInputErrorHandler

' ======================
' 初期化処理
' ======================
Private Sub Class_Initialize()
    Set mLock = New clsLock
End Sub

' ======================
' ファクトリメソッド
' ======================
Public Function Create() As InvalidInputErrorHandler
    On Error GoTo ErrorHandler
    
    If instance Is Nothing Then
        Set instance = New InvalidInputErrorHandler
    End If
    Set Create = instance
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "入力エラーハンドラの作成中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "Create"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set Create = Nothing
End Function

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As typErrorDetail) As Boolean
    Dim proceed As Boolean
    proceed = False  ' 入力エラーは基本的に処理を中断
    
    mLock.AcquireLock
    
    ' エラー情報をログに記録
    LogError errorDetail
    mLock.ReleaseLock
    
    ' ユーザーに通知
    NotifyUser errorDetail, vbExclamation
    
    ' 入力値の自動補正や、デフォルト値の適用など、
    ' 入力エラー時の回復処理をここに実装可能
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByRef errorDetail As typErrorDetail)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' エラーログの出力
    With New clsLogger
        .Configure New DefaultLoggerSettings
    
        .Log MODULE_NAME, _
             "無効な入力: " & errorDetail.Description, _
             errorDetail.ErrorCode
    End With
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "入力エラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As typErrorDetail, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    ' ユーザーへの通知
    Dim notifier As IUserNotifier
    Set notifier = New MsgBoxNotifier  ' または適切な通知実装を使用
    
    notifier.Notify errorDetail, style, "入力エラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "入力エラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

' ======================
' 入力値検証用のヘルパーメソッド
' ======================
Public Function ValidateNumericRange(ByVal value As Variant, _
                                   ByVal minValue As Double, _
                                   ByVal maxValue As Double) As Boolean
    On Error GoTo ErrorHandler
    
    If Not IsNumeric(value) Then
        ValidateNumericRange = False
        Exit Function
    End If
    
    Dim numValue As Double
    numValue = CDbl(value)
    
    ValidateNumericRange = (numValue >= minValue And numValue <= maxValue)
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_INVALID_INPUT
        .Description = "数値範囲の検証中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ValidateNumericRange"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    ValidateNumericRange = False
End Function

Public Function ValidateStringLength(ByVal value As String, _
                                   ByVal minLength As Long, _
                                   ByVal maxLength As Long) As Boolean
    Dim length As Long
    length = Len(value)
    
    ValidateStringLength = (length >= minLength And length <= maxLength)
End Function

Public Function ValidateRequired(ByVal value As Variant) As Boolean
    If IsNull(value) Then
        ValidateRequired = False
        Exit Function
    End If
    
    If VarType(value) = vbString Then
        ValidateRequired = (Len(Trim(CStr(value))) > 0)
    Else
        ValidateRequired = True
    End If
End Function

================
File: templates/IUserNotifier.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IUserNotifier"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' ユーザー通知インターフェース
' ======================

''' <remarks>
''' このインターフェースを実装するクラスは、以下のエラー処理を実装する必要があります：
'''
''' 1. UI表示に関するエラー処理
'''    - ウィンドウハンドルの検証
'''    - モーダルダイアログのデッドロック防止
'''    - 画面解像度やDPIの考慮
'''    - 多重表示の防止
'''
''' 2. メッセージ内容の処理
'''    - 長文メッセージの適切な表示
'''    - 特殊文字のエスケープ
'''    - 多言語対応
'''    - 機密情報のマスク
'''
''' 3. ユーザー応答の処理
'''    - タイムアウト処理
'''    - 無効な応答の検出
'''    - デフォルト値の提供
'''    - キャンセル操作の適切な処理
'''
''' 4. システム状態への配慮
'''    - バッチ処理中の考慮
'''    - 非対話モードの検出
'''    - システムリソースの確認
'''    - 他のダイアログとの競合回避
''' </remarks>

''' <summary>
''' エラー情報をユーザーに通知します
''' </summary>
''' <param name="errorDetail">エラー詳細情報</param>
''' <param name="buttons">表示するボタンの種類（オプション）</param>
''' <param name="title">ダイアログのタイトル（オプション）</param>
''' <returns>ユーザーの選択結果</returns>
''' <remarks>
''' エラー処理要件：
''' - エラー詳細のNULLチェック
''' - メッセージ長の制限
''' - UI表示失敗時の代替通知手段
''' - ユーザー応答のタイムアウト処理
''' </remarks>
Public Function Notify(ByRef errorDetail As typErrorDetail, _
                      Optional ByVal buttons As VbMsgBoxStyle = vbOKOnly, _
                      Optional ByVal title As String = "エラー") As VbMsgBoxResult
End Function

''' <summary>
''' 通知の表示方法を設定します
''' </summary>
''' <param name="style">通知スタイル</param>
''' <remarks>
''' エラー処理要件：
''' - 無効なスタイル値の検出
''' - スタイル変更時の整合性確認
''' - 現在表示中の通知への影響考慮
''' </remarks>
Public Property Let NotificationStyle(ByVal style As VbMsgBoxStyle)
End Property

''' <summary>
''' 現在の通知表示方法を取得します
''' </summary>
''' <returns>通知スタイル</returns>
''' <remarks>
''' エラー処理要件：
''' - 未初期化状態の検出
''' - デフォルトスタイルの提供
''' - システム状態との整合性確認
''' </remarks>
Public Property Get NotificationStyle() As VbMsgBoxStyle
End Property

''' <summary>
''' デフォルトのダイアログタイトルを設定します
''' </summary>
''' <param name="title">タイトル</param>
''' <remarks>
''' エラー処理要件：
''' - タイトル文字列の検証
''' - 長さ制限の確認
''' - 不正な文字の検出
''' - 設定変更の永続化
''' </remarks>
Public Property Let DefaultTitle(ByVal title As String)
End Property

''' <summary>
''' 現在のデフォルトダイアログタイトルを取得します
''' </summary>
''' <returns>タイトル</returns>
''' <remarks>
''' エラー処理要件：
''' - 未設定時のデフォルト値提供
''' - 文字エンコーディングの考慮
''' - キャッシュの整合性確認
''' </remarks>
Public Property Get DefaultTitle() As String
End Property

================
File: templates/IValidator.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IValidator"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' バリデーターインターフェース
' ======================

''' <remarks>
''' このインターフェースを実装するクラスは、以下のエラー処理を実装する必要があります：
'''
''' 1. 入力値の検証
'''    - NULL値の処理
'''    - データ型の検証
'''    - 範囲チェック
'''    - フォーマット検証
'''    - 文字エンコーディングの考慮
'''
''' 2. ビジネスルールの検証
'''    - 依存関係のチェック
'''    - 整合性の確認
'''    - カスタムルールの適用
'''    - 条件付きバリデーション
'''
''' 3. パフォーマンスとリソース
'''    - 大量データの効率的な検証
'''    - メモリ使用量の最適化
'''    - キャッシュの活用
'''    - タイムアウト処理
'''
''' 4. エラー情報の管理
'''    - 詳細なエラー情報の提供
'''    - 多言語対応
'''    - エラーの階層化
'''    - エラーの集約
'''
''' 5. セキュリティ考慮事項
'''    - 入力値のサニタイズ
'''    - インジェクション攻撃の防止
'''    - 機密情報の保護
'''    - アクセス制御の確認
''' </remarks>

''' <summary>
''' 値の妥当性を検証します
''' </summary>
''' <param name="value">検証する値</param>
''' <returns>妥当な場合True</returns>
''' <remarks>
''' エラー処理要件：
''' - 入力値のNULLチェック
''' - データ型の互換性確認
''' - メモリ制限の考慮
''' - 再帰的な検証の制御
''' - 検証ルールの整合性確認
''' 
''' 実装時の注意点：
''' 1. 検証失敗時は必ずErrorMessageを設定すること
''' 2. 複数のエラーが検出された場合は適切に集約すること
''' 3. パフォーマンスに影響を与える検証は最後に実行すること
''' 4. 副作用を発生させないこと
''' </remarks>
Public Function Validate(ByVal value As Variant) As Boolean
End Function

''' <summary>
''' 検証エラーメッセージを取得します
''' </summary>
''' <returns>エラーメッセージ</returns>
''' <remarks>
''' エラー処理要件：
''' - メッセージの初期化状態確認
''' - 文字列長の制限
''' - 特殊文字のエスケープ
''' - 多言語対応
''' 
''' 実装時の注意点：
''' 1. エラーがない場合は空文字列を返すこと
''' 2. メッセージは具体的で理解しやすい内容にすること
''' 3. 機密情報を含めないこと
''' 4. フォーマット指定子を適切に使用すること
''' </remarks>
Public Property Get ErrorMessage() As String
End Property

''' <summary>
''' 検証ルールを追加します
''' </summary>
''' <param name="rule">検証ルール</param>
''' <remarks>
''' エラー処理要件：
''' - ルールの妥当性確認
''' - 重複ルールの検出
''' - ルール間の依存関係確認
''' - メモリ使用量の監視
''' </remarks>
Public Sub AddRule(ByVal rule As Variant)
End Sub

''' <summary>
''' 検証ルールをクリアします
''' </summary>
''' <remarks>
''' エラー処理要件：
''' - リソースの適切な解放
''' - 実行中の検証への影響考慮
''' - 状態の整合性維持
''' </remarks>
Public Sub ClearRules()
End Sub

''' <summary>
''' 検証の詳細結果を取得します
''' </summary>
''' <returns>検証結果の詳細情報</returns>
''' <remarks>
''' エラー処理要件：
''' - 結果の初期化状態確認
''' - メモリ使用量の考慮
''' - 大量データの効率的な処理
''' </remarks>
Public Function GetValidationDetails() As Variant
End Function

================
File: templates/MockLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "MockLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' 警告: このクラスは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "MockLogger"

' ======================
' メンバ変数
' ======================
Private Type LogEntry
    ModuleName As String
    Message As String
    ErrorCode As ErrorCode
    Timestamp As Date
End Type

' エラー情報を格納する型
Private Type LogOperationResult
    Success As Boolean
    Value As Variant
    ErrorDetail As typErrorDetail
End Type

Private mLogEntries As Collection
Private mLogLevel As LogLevelEnum
Private mLogDestination As LogDestination
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLogEntries = New Collection
    Set mLock = New clsLock
    mLogLevel = LOG_LEVEL_INFO
    mLogDestination = DestNone
End Sub

Private Sub Class_Terminate()
    Set mLogEntries = Nothing
    Set mLock = Nothing
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal moduleName As String, ByVal message As String, Optional ByVal errorCode As ErrorCode)
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim entry As LogEntry
    With entry
        .ModuleName = moduleName
        .Message = message
        .ErrorCode = errorCode
        .Timestamp = Now
    End With
    
    mLogEntries.Add entry
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "モックロガーへのログ追加中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Private Property Let ILogger_LogLevel(ByVal level As LogLevelEnum)
    mLogLevel = level
End Property

Private Property Get ILogger_LogLevel() As LogLevelEnum
    ILogger_LogLevel = mLogLevel
End Property

Private Property Let ILogger_LogDestination(ByVal destination As LogDestination)
    mLogDestination = destination
End Property

Private Property Get ILogger_LogDestination() As LogDestination
    ILogger_LogDestination = mLogDestination
End Property

' ======================
' テストサポートメソッド（開発環境専用）
' ======================

''' <summary>
''' ログエントリの総数を取得（テスト用）
''' </summary>
Private Property Get LogCount() As Long
    mLock.AcquireLock
    LogCount = mLogEntries.Count
    mLock.ReleaseLock
End Property

''' <summary>
''' 指定されたインデックスのログエントリを取得（テスト用）
''' </summary>
''' <param name="index">取得するログエントリのインデックス</param>
''' <returns>フォーマット済みのログエントリ文字列、無効なインデックスの場合は空文字列</returns>
Private Function GetLogEntry(ByVal index As Long) As LogOperationResult
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As LogOperationResult
    result.Success = True
    
    If index < 1 Or index > mLogEntries.Count Then
        result.Success = False
        With result.ErrorDetail
            .ErrorCode = ERR_INVALID_PARAMETER
            .Description = "無効なインデックスが指定されました: " & index
            .Category = ECValidation
            .Source = MODULE_NAME
            .ProcedureName = "GetLogEntry"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        GetLogEntry = result
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim entry As LogEntry
    entry = mLogEntries(index)
    
    result.Value = Format$(entry.Timestamp, "yyyy/mm/dd hh:nn:ss") & " " & _
                  "[" & entry.ModuleName & "] " & _
                  IIf(entry.ErrorCode <> 0, "(Code: " & entry.ErrorCode & ") ", "") & _
                  entry.Message
    GetLogEntry = result
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    result.Success = False
    With result.ErrorDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "ログエントリの取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GetLogEntry"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    GetLogEntry = result
    mLock.ReleaseLock
End Function

''' <summary>
''' すべてのログエントリをクリア（テスト用）
''' </summary>
Private Sub ClearLogs()
    mLock.AcquireLock
    Set mLogEntries = New Collection
    mLock.ReleaseLock
End Sub

''' <summary>
''' 特定のモジュールからのログエントリ数を取得（テスト用）
''' </summary>
''' <param name="moduleName">対象のモジュール名</param>
''' <returns>指定されたモジュールのログエントリ数</returns>
Private Function GetLogCountForModule(ByVal moduleName As String) As LogOperationResult
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As LogOperationResult
    result.Success = True
    
    Dim count As Long
    Dim i As Long
    Dim entry As LogEntry
    
    For i = 1 To mLogEntries.Count
        entry = mLogEntries(i)
        If entry.ModuleName = moduleName Then
            count = count + 1
        End If
    Next i
    
    result.Value = count
    GetLogCountForModule = result
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    result.Success = False
    With result.ErrorDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "モジュール別ログ数の取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GetLogCountForModule"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    GetLogCountForModule = result
    mLock.ReleaseLock
End Function

''' <summary>
''' 特定のエラーコードのログエントリ数を取得（テスト用）
''' </summary>
''' <param name="errorCode">対象のエラーコード</param>
''' <returns>指定されたエラーコードのログエントリ数</returns>
Private Function GetLogCountForErrorCode(ByVal errorCode As ErrorCode) As LogOperationResult
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As LogOperationResult
    result.Success = True
    
    Dim count As Long
    Dim i As Long
    Dim entry As LogEntry
    
    For i = 1 To mLogEntries.Count
        entry = mLogEntries(i)
        If entry.ErrorCode = errorCode Then
            count = count + 1
        End If
    Next i
    
    result.Value = count
    GetLogCountForErrorCode = result
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    result.Success = False
    With result.ErrorDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "エラーコード別ログ数の取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GetLogCountForErrorCode"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    GetLogCountForErrorCode = result
    mLock.ReleaseLock
End Function

''' <summary>
''' 最後のログエントリを取得（テスト用）
''' </summary>
''' <returns>最後のログエントリ、ログが空の場合は空文字列</returns>
Private Function GetLastLogEntry() As LogOperationResult
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As LogOperationResult
    result.Success = True
    
    If mLogEntries.Count = 0 Then
        result.Success = False
        With result.ErrorDetail
            .ErrorCode = ERR_NO_DATA
            .Description = "ログエントリが存在しません"
            .Category = ECValidation
            .Source = MODULE_NAME
            .ProcedureName = "GetLastLogEntry"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        GetLastLogEntry = result
        mLock.ReleaseLock
        Exit Function
    End If
    
    GetLastLogEntry = GetLogEntry(mLogEntries.Count)
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    result.Success = False
    With result.ErrorDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "最後のログエントリの取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GetLastLogEntry"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    GetLastLogEntry = result
    mLock.ReleaseLock
End Function

================
File: templates/modAppInitializer.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modAppInitializer"

' ======================
' 初期化状態管理
' ======================
Private Type InitializationState
    ConfigInitialized As Boolean
    LoggingInitialized As Boolean
    DatabaseInitialized As Boolean
    ErrorHandlersInitialized As Boolean
End Type

Private mInitState As InitializationState

' ======================
' 公開メソッド
' ======================
Public Sub InitializeApplication()
    On Error GoTo ErrorHandler
    
    ' 設定の初期化（最初に実行）
    If Not mInitState.ConfigInitialized Then
        modConfig.InitializeModule
        mInitState.ConfigInitialized = True
    End If
    
    ' ロギングシステムの初期化
    If Not mInitState.LoggingInitialized Then
        InitializeLogging
        mInitState.LoggingInitialized = True
    End If
    
    ' データベース関連の初期化
    If Not mInitState.DatabaseInitialized Then
        InitializeDatabase
        mInitState.DatabaseInitialized = True
    End If
    
    ' エラーハンドラーの初期化（最後に実行）
    If Not mInitState.ErrorHandlersInitialized Then
        InitializeErrorHandlers
        mInitState.ErrorHandlersInitialized = True
    End If
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "アプリケーションの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeApplication"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub InitializeLogging()
    On Error GoTo ErrorHandler
    
    ' ロガー設定の初期化
    Dim loggerSettings As DefaultLoggerSettings
    Set loggerSettings = New DefaultLoggerSettings
    loggerSettings.Initialize modConfig.Settings.DatabaseConnectionString
    
    ' デフォルトロガーの設定
    With New clsLogger
        .Configure loggerSettings, modConfig
        .Log MODULE_NAME, "ロギングシステムが初期化されました", 0
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ロギングシステムの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeLogging"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub InitializeDatabase()
    On Error GoTo ErrorHandler
    
    ' データベースユーティリティの初期化
    modDatabaseUtils.InitializeModule
    
    ' データベース接続プールの初期化
    With New ConnectionPool
        ' IDatabaseConfigインターフェースを通じて接続文字列を取得
        .Initialize modConfig
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースシステムの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "InitializeDatabase"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub InitializeErrorHandlers()
    On Error GoTo ErrorHandler
    
    ' エラーハンドラーの初期化
    ' この時点で設定とロギングは初期化済みであることが保証される
    With DatabaseConnectionErrorHandler.Create(modConfig)
        ' 必要な初期化処理があれば実行
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "エラーハンドラーの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeErrorHandlers"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

================
File: templates/modCommon.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modCommon"

' ======================
' アプリケーション定数
' ======================
Public Const APPLICATION_NAME As String = "MyApp"
Public Const APPLICATION_VERSION As String = "1.0.0"
Public Const DEFAULT_LOG_FILE As String = "app.log"
Public Const DEFAULT_DATE_FORMAT As String = "yyyy/MM/dd"
Public Const DEFAULT_DATETIME_FORMAT As String = "yyyy/MM/dd HH:nn:ss"
Public Const MAX_RETRY_COUNT As Integer = 3

' ======================
' ログ関連の定義
' ======================
Public Enum LogLevel
    LevelDebug
    LevelInfo
    LevelWarning
    LevelError
    LevelFatal
End Enum

Public Enum LogDestination
    DestNone
    DestFile
    DestDatabase
    DestEventLog
    DestConsole
    DestEmail
End Enum

' ======================
' セキュリティレベル
' ======================
Public Enum SecurityLevel
    LevelLow = 1
    LevelMedium = 2
    LevelHigh = 3
    LevelExtreme = 4
End Enum

' ======================
' ファイルアクセスモード
' ======================
Public Enum FileAccessMode
    ModeReadOnly = 1
    ModeReadWrite = 2
    ModeAppend = 3
    ModeExclusive = 4
End Enum

' ======================
' 型定義
' ======================
Public Type ErrorInfo
    Code As ErrorCode
    Category As ErrorCodeCategory
    Description As String
    Source As String
    ProcedureName As String
    StackTrace As String
    OccurredAt As Date
    AdditionalInfo As String
End Type

Public Type FileInfo
    Name As String
    Path As String
    Size As Long
    Created As Date
    LastModified As Date
    FileType As String
    Attributes As Long
End Type

' ======================
' モジュール変数
' ======================
Private mPerformanceMonitor As clsPerformanceMonitor
Private mIsInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = mIsInitialized
End Property

Public Sub InitializeModule()
    If mIsInitialized Then Exit Sub
    
    ' スタックトレースモジュールの初期化
    modStackTrace.InitializeModule
    
    ' パフォーマンスモニターの初期化
    Set mPerformanceMonitor = New clsPerformanceMonitor
    Set mLock = New clsLock
    
    ' 設定の初期化
    modConfig.InitializeModule
    
    mIsInitialized = True
End Sub

Public Sub TerminateModule()
    If Not mIsInitialized Then Exit Sub
    
    ' 設定の終了処理
    modConfig.TerminateModule
    
    ' パフォーマンスモニターの解放
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
    
    mIsInitialized = False
End Sub

' ======================
' エラーハンドリング
' ======================
Public Sub HandleError(ByRef errInfo As ErrorInfo)
    If Not mIsInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' パフォーマンスモニタリング開始
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "ErrorHandling_" & errInfo.Code
    End If
    
    ' エラー情報の補完
    With errInfo
        If .OccurredAt = #12:00:00 AM# Then .OccurredAt = Now
        If .Category = 0 Then .Category = modErrorCodes.GetErrorCategory(.Code)
        If Len(.StackTrace) = 0 Then .StackTrace = modStackTrace.GetStackTrace()
    End With
    
    ' エラー処理をmodErrorに委譲
    modError.HandleError errInfo
    
    ' パフォーマンスモニタリング終了
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ErrorHandling_" & errInfo.Code
    End If
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    If Not mLock Is Nothing Then mLock.ReleaseLock
    Err.Raise Err.Number, Err.Source, "HandleError中にエラーが発生しました: " & Err.Description
End Sub

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    Private Sub ResetModule()
        ' モジュールの状態を初期化（テスト用）
        TerminateModule
        InitializeModule
    End Sub
    
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        ' パフォーマンスモニターの参照を取得（テスト用）
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
#End If

================
File: templates/modConfig.bas
================
Option Explicit
Implements IDatabaseConfig

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modConfig"

' ======================
' 定数定義
' ======================
Private Const CONFIG_FILE_PATH As String = "config.ini"
Private Const MAX_BUFFER_SIZE As Long = 1024
Private Const DEFAULT_SECTION As String = "Settings"

' ======================
' 型定義
' ======================
Private Type ConfigurationSettings
    LogLevel As LogLevel
    LogDestination As LogDestination
    LogFilePath As String
    DatabaseConnectionString As String
    SecurityLevel As SecurityLevel
    PerformanceMonitoringEnabled As Boolean
    DiagnosticsEnabled As Boolean
    EncryptionKey As String
End Type

' ======================
' プライベート変数
' ======================
Private settings As ConfigurationSettings
Private settingsLock As clsLock
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set settingsLock = New clsLock
    Set performanceMonitor = New clsPerformanceMonitor
    
    LoadDefaultSettings
    LoadConfigurationFromFile
    
    isInitialized = True
    
    ' パフォーマンスモニタリング開始
    If settings.PerformanceMonitoringEnabled Then
        performanceMonitor.StartMeasurement "ConfigInitialization"
    End If
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    ' パフォーマンスモニタリング終了
    If settings.PerformanceMonitoringEnabled Then
        performanceMonitor.EndMeasurement "ConfigInitialization"
    End If
    
    Set settingsLock = Nothing
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開プロパティ
' ======================
Public Property Get Settings() As ConfigurationSettings
    If Not isInitialized Then InitializeModule
    
    settingsLock.AcquireLock
    Settings = settings
    settingsLock.ReleaseLock
End Property

Public Property Let Settings(ByVal Value As ConfigurationSettings)
    If Not isInitialized Then InitializeModule
    
    settingsLock.AcquireLock
    settings = Value
    settingsLock.ReleaseLock
    
    ' 設定の永続化
    SaveConfigurationToFile
End Property

' ======================
' 公開メソッド
' ======================
Public Function GetConfigValue(ByVal section As String, ByVal key As String, _
                             Optional ByVal defaultValue As String = "") As String
    If Not isInitialized Then InitializeModule
    
    Dim buffer As String
    Dim result As Long
    
    buffer = String$(MAX_BUFFER_SIZE, 0)
    result = modWindowsAPI.GetPrivateProfileString(section, key, defaultValue, buffer, Len(buffer), GetConfigFilePath())
    
    If result > 0 Then
        GetConfigValue = Left$(buffer, result)
    Else
        GetConfigValue = defaultValue
    End If
End Function

Public Function SetConfigValue(ByVal section As String, ByVal key As String, _
                             ByVal Value As String) As Boolean
    If Not isInitialized Then InitializeModule
    
    SetConfigValue = (modWindowsAPI.WritePrivateProfileString(section, key, Value, GetConfigFilePath()) <> 0)
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LoadDefaultSettings()
    With settings
        .LogLevel = LevelInfo
        .LogDestination = DestFile
        .LogFilePath = DEFAULT_LOG_FILE
        .SecurityLevel = LevelMedium
        .PerformanceMonitoringEnabled = True
        .DiagnosticsEnabled = True
    End With
End Sub

Private Sub LoadConfigurationFromFile()
    On Error GoTo ErrorHandler
    
    With settings
        ' ログ設定
        .LogLevel = CInt(GetConfigValue(DEFAULT_SECTION, "LogLevel", CStr(LevelInfo)))
        .LogDestination = CInt(GetConfigValue(DEFAULT_SECTION, "LogDestination", CStr(DestFile)))
        .LogFilePath = GetConfigValue(DEFAULT_SECTION, "LogFilePath", DEFAULT_LOG_FILE)
        
        ' データベース設定
        .DatabaseConnectionString = GetConfigValue("Database", "ConnectionString", "")
        
        ' セキュリティ設定
        .SecurityLevel = CInt(GetConfigValue("Security", "Level", CStr(LevelMedium)))
        .EncryptionKey = GetConfigValue("Security", "EncryptionKey", "")
        
        ' 診断設定
        .PerformanceMonitoringEnabled = CBool(GetConfigValue("Diagnostics", "PerformanceMonitoring", "True"))
        .DiagnosticsEnabled = CBool(GetConfigValue("Diagnostics", "Enabled", "True"))
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileInvalidFormat
        .Description = "設定ファイルの読み込み中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "LoadConfigurationFromFile"
        .StackTrace = GetCurrentCallStack
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Next
End Sub

Private Sub SaveConfigurationToFile()
    On Error GoTo ErrorHandler
    
    With settings
        ' ログ設定
        SetConfigValue DEFAULT_SECTION, "LogLevel", CStr(.LogLevel)
        SetConfigValue DEFAULT_SECTION, "LogDestination", CStr(.LogDestination)
        SetConfigValue DEFAULT_SECTION, "LogFilePath", .LogFilePath
        
        ' データベース設定
        SetConfigValue "Database", "ConnectionString", .DatabaseConnectionString
        
        ' セキュリティ設定
        SetConfigValue "Security", "Level", CStr(.SecurityLevel)
        SetConfigValue "Security", "EncryptionKey", .EncryptionKey
        
        ' 診断設定
        SetConfigValue "Diagnostics", "PerformanceMonitoring", CStr(.PerformanceMonitoringEnabled)
        SetConfigValue "Diagnostics", "Enabled", CStr(.DiagnosticsEnabled)
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileAccessDenied
        .Description = "設定ファイルの保存中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "SaveConfigurationToFile"
        .StackTrace = GetCurrentCallStack
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Next
End Sub

Private Function GetConfigFilePath() As String
    GetConfigFilePath = App.Path & "\" & CONFIG_FILE_PATH
End Function

' ======================
' ヘルパー関数
' ======================
Private Function GetCurrentCallStack() As String
    Dim callStack As New clsCallStack
    
    ' 現在のプロシージャ情報をスタックに追加
    callStack.Push MODULE_NAME, "GetCurrentCallStack"
    
    ' スタックトレースを取得
    GetCurrentCallStack = callStack.StackTrace
End Function

' ======================
' IDatabaseConfig インターフェースの実装
' ======================
Private Function IDatabaseConfig_GetConnectionString() As String
    If Not isInitialized Then InitializeModule
    
    IDatabaseConfig_GetConnectionString = Me.Settings.DatabaseConnectionString
End Function

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    Public Function ValidateSettings() As Boolean
        With settings
            ValidateSettings = _
                .LogLevel >= LevelDebug And .LogLevel <= LevelFatal And _
                .LogDestination >= DestNone And .LogDestination <= DestEmail And _
                .SecurityLevel >= LevelLow And .SecurityLevel <= LevelExtreme
        End With
    End Function
#End If

================
File: templates/modDatabaseUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modDatabaseUtils"

' ======================
' 定数定義
' ======================
Private Const MAX_RETRY_COUNT As Long = 3
Private Const ERR_MODULE_NOT_INITIALIZED As String = "モジュールが初期化されていません。"
Private Const RETRY_INTERVAL_MS As Long = 1000

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean
Private lock As clsLock
Private defaultConnection As Object ' ADODB.Connection
Private mConfig As IDatabaseConfig ' データベース設定

' ======================
' 初期化・終了処理
' ======================
''' <summary>モジュールを初期化します</summary>
''' <param name="config">データベース設定を提供するインターフェース（必須）</param>
Public Sub InitializeModule(ByVal config As IDatabaseConfig)
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    If config Is Nothing Then
        Err.Raise vbObjectError + 1001, MODULE_NAME, _
            "データベース設定が指定されていません。"
    End If
    Set mConfig = config
    Set lock = New clsLock
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    CloseConnection
    Set performanceMonitor = Nothing
    Set lock = Nothing
    Set mConfig = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' データベース接続文字列を取得します
''' </summary>
''' <returns>接続文字列</returns>
Public Function GetConnectionString() As String
    If Not isInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    On Error GoTo ErrorHandler

    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "GetConnectionString"
    End If
    
    lock.AcquireLock
    
    ' IDatabaseConfigから接続文字列を取得
    GetConnectionString = mConfig.GetConnectionString

    lock.ReleaseLock
    
    If GetConnectionString = "" Then
        Dim errDetail As typErrorDetail
        With errDetail
            .ErrorCode = ERR_DATABASE_CONNECTION_FAILED
            .Description = "データベース接続文字列が設定されていません。"
            .Category = ECDatabase
            .Source = MODULE_NAME
            .ProcedureName = "GetConnectionString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
        If Not performanceMonitor Is Nothing Then
            performanceMonitor.EndMeasurement "GetConnectionString"
        End If
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "GetConnectionString"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail2 As typErrorDetail
    With errDetail2
        .ErrorCode = ERR_DATABASE_CONNECTION_FAILED
        .Description = "接続文字列の取得中にエラーが発生しました: " & Err.Description
            .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnectionString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
    End With
    modError.HandleError errDetail2
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "GetConnectionString"
    End If
    GetConnectionString = ""
End Function

''' <summary>
''' データベース接続を取得します
''' </summary>
''' <returns>データベース接続オブジェクト</returns>
Public Function GetConnection() As Object ' ADODB.Connection
    If Not isInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "GetConnection"
    End If
    
    On Error GoTo ErrorHandler
    
    lock.AcquireLock
    
    ' 既存の接続を確認
    If Not defaultConnection Is Nothing Then
        If defaultConnection.State = 1 Then ' adStateOpen
            Set GetConnection = defaultConnection
            GoTo CleanupAndExit
        End If
    End If
    
    ' 新しい接続を作成
    Dim connStr As String
    connStr = GetConnectionString()
    If connStr = "" Then Exit Function
    
    Set defaultConnection = CreateObject("ADODB.Connection")
    defaultConnection.ConnectionString = connStr
    defaultConnection.Open
    
    Set GetConnection = defaultConnection

    GoTo CleanupAndExit

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_DATABASE_CONNECTION_FAILED
        .Description = "データベース接続の取得中にエラーが発生しました: " & Err.Description
            .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnection"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set GetConnection = Nothing

CleanupAndExit:
    lock.ReleaseLock
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "GetConnection"
    End If
    Exit Function

End Function

''' <summary>
''' データベース接続を閉じます
''' </summary>
Public Sub CloseConnection()
    If Not defaultConnection Is Nothing Then
        lock.AcquireLock
        
        On Error Resume Next
        If defaultConnection.State = 1 Then ' adStateOpen
            defaultConnection.Close
        End If
        Set defaultConnection = Nothing
        
        lock.ReleaseLock
        On Error GoTo 0
    End If
End Sub

''' <summary>
''' データベース接続をテストします
''' </summary>
''' <returns>接続成功の場合True</returns>
Public Function TestConnection() As Boolean
    If Not isInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    Dim conn As Object
    Set conn = GetConnection()
    
    TestConnection = Not (conn Is Nothing)
    
    If Not conn Is Nothing Then
        If conn.State = 1 Then ' adStateOpen
            TestConnection = True
        End If
    End If
End Function

''' <summary>
''' SQLクエリを実行し、結果を取得します
''' </summary>
''' <param name="sql">SQLクエリ</param>
''' <param name="params">パラメータ配列（オプション）</param>
''' <returns>レコードセット</returns>
Public Function ExecuteQuery(ByVal sql As String, _
                           Optional ByRef params As Variant) As Object ' ADODB.Recordset
    If Not isInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "ExecuteQuery"
    End If
    
    On Error GoTo ErrorHandler
    
    Dim conn As Object
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Function
    
    Dim cmd As Object
    Set cmd = CreateObject("ADODB.Command")
    With cmd
        Set .ActiveConnection = conn
        .CommandText = sql
        .CommandType = 1 ' adCmdText
        
        ' パラメータの設定
        If Not IsMissing(params) Then
            If IsArray(params) Then
                Dim i As Long
                For i = LBound(params) To UBound(params)
                    .Parameters.Append .CreateParameter("p" & i, GetParameterType(params(i)), 1, , params(i))
                Next i
            End If
        End If
        
        Set ExecuteQuery = .Execute
    End With
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "ExecuteQuery"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_DATABASE_QUERY_FAILED
        .Description = "クエリの実行中にエラーが発生しました: " & Err.Description
            .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "ExecuteQuery"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "ExecuteQuery"
    End If
    Set ExecuteQuery = Nothing
End Function

' ======================
' プライベート関数
' ======================
Private Function GetParameterType(ByVal value As Variant) As Integer
    Select Case VarType(value)
        Case vbInteger, vbLong
            GetParameterType = 3 ' adInteger
        Case vbSingle, vbDouble
            GetParameterType = 5 ' adDouble
        Case vbString
            GetParameterType = 200 ' adVarChar
        Case vbDate
            GetParameterType = 7 ' adDate
        Case vbBoolean
            GetParameterType = 11 ' adBoolean
        Case Else
            GetParameterType = 12 ' adVariant
    End Select
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: templates/modDateUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modDateUtils"

' ======================
' 定数定義
' ======================
Private Const DEFAULT_DATE_FORMAT As String = "yyyy/mm/dd"
Private Const DEFAULT_TIME_FORMAT As String = "hh:nn:ss"
Private Const DEFAULT_DATETIME_FORMAT As String = "yyyy/mm/dd hh:nn:ss"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 日付の妥当性を確認します
''' </summary>
''' <param name="testDate">確認する日付</param>
''' <returns>有効な日付の場合True</returns>
Public Function IsValidDate(ByVal testDate As Variant) As Boolean
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "IsValidDate"
    End If
    
    On Error Resume Next
    IsValidDate = IsDate(testDate)
    On Error GoTo 0
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "IsValidDate"
    End If
End Function

''' <summary>
''' 日付に指定された期間を加算します
''' </summary>
''' <param name="interval">期間の単位</param>
''' <param name="number">加算する数</param>
''' <param name="dateValue">対象の日付</param>
''' <returns>加算後の日付</returns>
Public Function DateAdd(ByVal interval As String, ByVal number As Double, _
                      ByVal dateValue As Date) As Date
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "DateAdd"
    End If
    
    On Error GoTo ErrorHandler
    
    DateAdd = VBA.DateAdd(interval, number, dateValue)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateAdd"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "日付の加算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "DateAdd"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateAdd"
    End If
    DateAdd = dateValue
End Function

''' <summary>
''' 2つの日付の差分を計算します
''' </summary>
''' <param name="interval">期間の単位</param>
''' <param name="date1">日付1</param>
''' <param name="date2">日付2</param>
''' <returns>日付の差分</returns>
Public Function DateDiff(ByVal interval As String, ByVal date1 As Date, _
                       ByVal date2 As Date) As Long
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "DateDiff"
    End If
    
    On Error GoTo ErrorHandler
    
    DateDiff = VBA.DateDiff(interval, date1, date2)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateDiff"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "日付の差分計算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "DateDiff"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateDiff"
    End If
    DateDiff = 0
End Function

''' <summary>
''' 日付を指定された形式でフォーマットします
''' </summary>
''' <param name="dateValue">対象の日付</param>
''' <param name="format">フォーマット文字列（オプション）</param>
''' <returns>フォーマットされた日付文字列</returns>
Public Function FormatDate(ByVal dateValue As Date, _
                         Optional ByVal format As String = DEFAULT_DATE_FORMAT) As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "FormatDate"
    End If
    
    On Error GoTo ErrorHandler
    
    FormatDate = Format$(dateValue, format)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "FormatDate"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "日付のフォーマット中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "FormatDate"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "FormatDate"
    End If
    FormatDate = Format$(dateValue, DEFAULT_DATE_FORMAT)
End Function

''' <summary>
''' 現在の日時を取得します
''' </summary>
''' <returns>現在の日時</returns>
Public Function GetCurrentDateTime() As Date
    If Not isInitialized Then InitializeModule
    GetCurrentDateTime = Now
End Function

''' <summary>
''' 指定された日付が営業日かどうかを確認します
''' </summary>
''' <param name="dateValue">確認する日付</param>
''' <returns>営業日の場合True</returns>
Public Function IsBusinessDay(ByVal dateValue As Date) As Boolean
    If Not isInitialized Then InitializeModule
    
    ' 土曜日(7)または日曜日(1)の場合はFalse
    IsBusinessDay = Not (Weekday(dateValue, vbSunday) = 1 Or _
                        Weekday(dateValue, vbSunday) = 7)
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: templates/modError.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modError"

' ======================
' プライベート変数
' ======================
Private errorHandlers As Collection
Private isInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set errorHandlers = New Collection
    Set mLock = New clsLock
    RegisterDefaultHandlers
    
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set errorHandlers = Nothing
    Set mLock = Nothing
    isInitialized = False
End Sub

' ======================
' エラーハンドリング
' ======================
Public Sub HandleError(ByRef errInfo As ErrorInfo)
    If Not isInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' エラー情報の補完
    With errInfo
        If .OccurredAt = #12:00:00 AM# Then .OccurredAt = Now
        If .Category = 0 Then .Category = modErrorCodes.GetErrorCategory(.Code)
        If Len(.StackTrace) = 0 Then .StackTrace = modStackTrace.GetStackTrace()
    End With
    
    ' エラーハンドラの取得
    Dim handler As IErrorHandler
    Set handler = GetErrorHandler(errInfo.Code)
    
    mLock.ReleaseLock
    
    ' エラーハンドラによる処理
    Dim proceed As Boolean
    proceed = handler.HandleError(errInfo)
    
    ' エラー処理の結果に基づいて処理を継続するかどうかを判断
    If Not proceed Then
        Err.Raise errInfo.Code, errInfo.Source, errInfo.Description
    End If
    Exit Sub

ErrorHandler:
    If Not mLock Is Nothing Then mLock.ReleaseLock
    Err.Raise Err.Number, Err.Source, "HandleError中にエラーが発生しました: " & Err.Description
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub RegisterDefaultHandlers()
    ' データベース接続エラー用ハンドラ
    RegisterErrorHandler ErrDbConnectionFailed, New DatabaseConnectionErrorHandler
    
    ' ファイル不在エラー用ハンドラ
    RegisterErrorHandler ErrFileNotFound, New FileNotFoundErrorHandler
    
    ' 入力検証エラー用ハンドラ
    RegisterErrorHandler ErrInvalidInput, New InvalidInputErrorHandler
End Sub

Private Function GetErrorHandler(ByVal errorCode As ErrorCode) As IErrorHandler
    Dim handler As IErrorHandler
    
    On Error Resume Next
    Set handler = errorHandlers(CStr(errorCode))
    If Err.Number <> 0 Then
        ' 該当するハンドラが見つからない場合は、エラーカテゴリに基づいてデフォルトハンドラを返す
        Set handler = GetDefaultHandlerForCategory(modErrorCodes.GetErrorCategory(errorCode))
    End If
    On Error GoTo 0
    
    Set GetErrorHandler = handler
End Function

Private Function GetDefaultHandlerForCategory(ByVal category As ErrorCodeCategory) As IErrorHandler
    Select Case category
        Case ECDatabase
            Set GetDefaultHandlerForCategory = New DatabaseConnectionErrorHandler
        Case ECFileIO
            Set GetDefaultHandlerForCategory = New FileNotFoundErrorHandler
        Case Else
            Set GetDefaultHandlerForCategory = New InvalidInputErrorHandler
    End Select
End Function

' ======================
' パブリックメソッド
' ======================
Public Sub RegisterErrorHandler(ByVal errorCode As ErrorCode, ByVal handler As IErrorHandler)
    If Not isInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error Resume Next
    errorHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    
    errorHandlers.Add handler, CStr(errorCode)
    mLock.ReleaseLock
End Sub

Public Sub UnregisterErrorHandler(ByVal errorCode As ErrorCode)
    If Not isInitialized Then Exit Sub
    
    mLock.AcquireLock
    On Error Resume Next
    errorHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    mLock.ReleaseLock
End Sub

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    Private Function GetRegisteredHandlerCount() As Long
        mLock.AcquireLock
        GetRegisteredHandlerCount = errorHandlers.Count
        mLock.ReleaseLock
    End Function
    
    Private Sub ClearHandlers()
        mLock.AcquireLock
        Set errorHandlers = New Collection
        mLock.ReleaseLock
    End Sub
    
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: templates/modErrorCodes.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modErrorCodes"

' ======================
' エラーコード定義
' ======================
Public Enum ErrorCodeCategory
    ECGeneral = 1000    ' 一般エラー
    ECFileIO = 2000     ' ファイル操作エラー
    ECDatabase = 3000   ' データベースエラー
    ECNetwork = 4000    ' ネットワークエラー
    ECSystem = 5000     ' システムエラー
    ECSecurity = 6000   ' セキュリティエラー
End Enum

Public Enum ErrorCode
    ' 一般エラー (1000-1999)
    ErrUnexpected = vbObjectError + 1000             ' 予期せぬエラー
    ErrInvalidInput = vbObjectError + 1001           ' 無効な入力
    
    ' ファイル操作エラー (2000-2999)
    ErrFileNotFound = vbObjectError + 2000           ' ファイルが見つからない
    ErrFileInvalidFormat = vbObjectError + 2001      ' ファイル形式エラー
    ErrFileAccessDenied = vbObjectError + 2002       ' アクセス拒否
    
    ' データベースエラー (3000-3999)
    ErrDbConnectionFailed = vbObjectError + 3000     ' データベース接続エラー
    ErrDbQueryFailed = vbObjectError + 3001         ' データベースクエリエラー
    
    ' ネットワークエラー (4000-4999)
    ErrNetworkError = vbObjectError + 4000          ' ネットワークエラー
    ErrNetworkTimeout = vbObjectError + 4001        ' タイムアウト
    
    ' システムエラー (5000-5999)
    ErrSystemOutOfMemory = vbObjectError + 5000     ' メモリ不足
    ErrSystemResourceUnavailable = vbObjectError + 5001 ' リソース利用不可
    
    ' セキュリティエラー (6000-6999)
    ErrSecurityAccessDenied = vbObjectError + 6000  ' セキュリティアクセス拒否
    ErrSecurityInvalidCredentials = vbObjectError + 6001 ' 無効な認証情報
    
    ' 暗号化エラー (7000-7099)
    ErrCryptoProviderInitFailed = vbObjectError + 7000  ' 暗号化プロバイダーの初期化失敗
    ErrCryptoNotInitialized = vbObjectError + 7001      ' 暗号化プロバイダー未初期化
    ErrCryptoKeyNotSpecified = vbObjectError + 7002     ' 暗号化キー未指定
    ErrCryptoHashCreateFailed = vbObjectError + 7003    ' ハッシュオブジェクト作成失敗
    ErrCryptoHashDataFailed = vbObjectError + 7004      ' データハッシュ化失敗
    ErrCryptoKeyDerivationFailed = vbObjectError + 7005 ' キー生成失敗
    ErrCryptoEncryptionFailed = vbObjectError + 7006    ' 暗号化失敗
    ErrCryptoDecryptionFailed = vbObjectError + 7007    ' 復号化失敗
    ErrCryptoInvalidKeyLength = vbObjectError + 7008    ' 無効なキー長
    
    ' ロック関連エラー (7100-7199)
    ErrLockMutexCreateFailed = vbObjectError + 7100     ' Mutexの作成失敗
    ErrLockAcquireFailed = vbObjectError + 7101         ' ロックの取得失敗
    ErrLockReleaseFailed = vbObjectError + 7102         ' ロックの解放失敗
    
    ' スタックトレース関連エラー (7200-7299)
    ErrStackTracePushFailed = vbObjectError + 7200      ' スタックトレースへの追加失敗
    ErrStackTracePopFailed = vbObjectError + 7201       ' スタックトレースからの取得失敗
    ErrStackTraceGetFailed = vbObjectError + 7202       ' スタックトレース文字列の生成失敗
    
    ' イベントログ関連エラー (7300-7399)
    ErrEventLogCreateFailed = vbObjectError + 7300      ' イベントログオブジェクトの作成失敗
    ErrEventLogWriteFailed = vbObjectError + 7301       ' イベントログへの書き込み失敗
    ErrEventLogSourceInvalid = vbObjectError + 7302     ' イベントログソースが無効
End Enum

' ======================
' エラーカテゴリ取得
' ======================
Public Function GetErrorCategory(ByVal errCode As ErrorCode) As ErrorCodeCategory
    If errCode >= ECGeneral And errCode < ECFileIO Then
        GetErrorCategory = ECGeneral
    ElseIf errCode >= ECFileIO And errCode < ECDatabase Then
        GetErrorCategory = ECFileIO
    ElseIf errCode >= ECDatabase And errCode < ECNetwork Then
        GetErrorCategory = ECDatabase
    ElseIf errCode >= ECNetwork And errCode < ECSystem Then
        GetErrorCategory = ECNetwork
    ElseIf errCode >= ECSystem And errCode < ECSecurity Then
        GetErrorCategory = ECSystem
    ElseIf errCode >= ECSecurity Then
        GetErrorCategory = ECSecurity
    End If
End Function

================
File: templates/modFileIO.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modFileIO"

' ======================
' 定数定義
' ======================
Private Const MAX_BUFFER_SIZE As Long = 1024
Private Const DEFAULT_ENCODING As String = "UTF-8"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean
Private mFileSystemLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Private Sub InitializeIfNeeded()
    If Not isInitialized Then InitializeModule
End Sub

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    Set performanceMonitor = Nothing
    Set mFileSystemLock = Nothing
    isInitialized = False
End Sub

' FileSystemOperationsクラスのロックオブジェクトを設定
Public Sub SetFileSystemLock(ByVal lock As clsLock)
    Set mFileSystemLock = lock
End Sub

' ======================
' 公開メソッド
' ======================

''' <summary>
''' テキストファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>ファイルの内容、エラー時は空文字列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルの存在確認
''' - エンコーディングの検証
''' - ファイルロックの確認
''' - メモリ不足への対応
''' </remarks>
Public Function ReadTextFile(ByVal filePath As String, _
                           Optional ByVal encoding As String = DEFAULT_ENCODING) As String
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Read Text File"
    On Error GoTo ErrorHandler
    
    If Not FileExists(filePath) Then
        RaiseFileError modErrorCodes.ErrFileNotFound, "ファイルが見つかりません: " & filePath
    End If
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Input As #fileNum Encoding encoding
        ReadTextFile = Input$(LOF(fileNum), fileNum)
    Close #fileNum
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Read Text File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "ReadTextFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    ReadTextFile = ""  ' エラー時は空文字列を返す（IFileOperationsの規定に従う）
    Resume CleanUp
End Function

''' <summary>
''' テキストファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="content">書き込む内容</param>
''' <param name="append">追記モード（オプション）</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - 書き込み権限の確認
''' - ディスク容量の確認
''' - 既存ファイルのバックアップ
''' - 書き込み失敗時の復旧処理
''' </remarks>
Public Function WriteTextFile(ByVal filePath As String, _
                            ByVal content As String, _
                            Optional ByVal append As Boolean = False, _
                            Optional ByVal encoding As String = DEFAULT_ENCODING) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Write Text File"
    On Error GoTo ErrorHandler
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    If append Then
        Open filePath For Append As #fileNum Encoding encoding
    Else
        Open filePath For Output As #fileNum Encoding encoding
    End If
    
    Print #fileNum, content
    Close #fileNum
    
    WriteTextFile = True
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Write Text File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "WriteTextFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    WriteTextFile = False
    Resume CleanUp
End Function

''' <summary>
''' バイナリファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <returns>ファイルのバイトデータ、エラー時は空配列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルサイズの検証
''' - メモリ使用量の監視
''' - 破損ファイルの検出
''' - エラー発生時は空配列を返す
''' </remarks>
Public Function ReadBinaryFile(ByVal filePath As String) As Byte()
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Read Binary File"
    On Error GoTo ErrorHandler
    
    If Not FileExists(filePath) Then
        RaiseFileError modErrorCodes.ErrFileNotFound, "ファイルが見つかりません: " & filePath
    End If
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Binary Access Read As #fileNum
        Dim fileData() As Byte
        ReDim fileData(LOF(fileNum) - 1)
        Get #fileNum, , fileData
    Close #fileNum
    
    ReadBinaryFile = fileData
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Read Binary File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "ReadBinaryFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    ReadBinaryFile = Array()  ' エラー時は空配列を返す
    Resume CleanUp
End Function

''' <summary>
''' バイナリファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="data">書き込むバイトデータ</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - データの整合性チェック
''' - 部分書き込みの防止
''' - 書き込み失敗時のロールバック
''' - エラー発生時はFalseを返す
''' </remarks>
Public Function WriteBinaryFile(ByVal filePath As String, _
                              ByRef data() As Byte) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Write Binary File"
    On Error GoTo ErrorHandler
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Binary Access Write As #fileNum
        Put #fileNum, , data
    Close #fileNum
    
    WriteBinaryFile = True
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Write Binary File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "WriteBinaryFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    WriteBinaryFile = False
    Resume CleanUp
End Function

Public Function FileExists(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "FileExists"
    On Error GoTo ErrorHandler
    
    FileExists = (Dir(filePath) <> "")
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "FileExists"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "ファイルの存在確認中にエラーが発生しました: " & filePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "FileExists"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    FileExists = False
    Resume CleanUp
End Function
 
Public Function FolderExists(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "FolderExists"
    On Error GoTo ErrorHandler
    
    FolderExists = (Dir(folderPath, vbDirectory) <> "")
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "FolderExists"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの存在確認中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "FolderExists"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    FolderExists = False
    Resume CleanUp
End Function
 
Public Function CreateFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Create Folder"
    On Error GoTo ErrorHandler
    
    MkDir folderPath
    CreateFolder = True
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Create Folder"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの作成中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "CreateFolder"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    CreateFolder = False
    Resume CleanUp
End Function
 
Public Function DeleteFile(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Delete File"
    On Error GoTo ErrorHandler
    
    Kill filePath
    DeleteFile = True
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Delete File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "ファイルの削除中にエラーが発生しました: " & filePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "DeleteFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    DeleteFile = False
    Resume CleanUp
End Function
 
Public Function DeleteFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "Delete Folder"
    On Error GoTo ErrorHandler
    
    RmDir folderPath
    DeleteFolder = True
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "Delete Folder"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの削除中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "DeleteFolder"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    DeleteFolder = False
    Resume CleanUp
End Function

Public Function GetAbsolutePath(ByVal relativePath As String, _
                              Optional ByVal basePath As String) As String
    InitializeIfNeeded
    
    mFileSystemLock.AcquireLock
    performanceMonitor.StartMeasurement "GetAbsolutePath"
    On Error GoTo ErrorHandler
    
    If Len(basePath) = 0 Then basePath = CurDir
    GetAbsolutePath = CreateObject("Scripting.FileSystemObject").GetAbsolutePathName(basePath & "\" & relativePath)
    
CleanUp:
    mFileSystemLock.ReleaseLock
    performanceMonitor.EndMeasurement "GetAbsolutePath"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "絶対パスの取得中にエラーが発生しました: " & relativePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "GetAbsolutePath"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    GetAbsolutePath = ""
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Function GetFileErrorCode(ByVal errNumber As Long) As ErrorCode
    Select Case errNumber
        Case 53 ' File not found
            GetFileErrorCode = modErrorCodes.ErrFileNotFound
        Case 70 ' Permission denied
            GetFileErrorCode = modErrorCodes.ErrFileAccessDenied
        Case 75, 76 ' Path/File access error
            GetFileErrorCode = modErrorCodes.ErrFileAccessDenied
        Case Else
            GetFileErrorCode = modErrorCodes.ErrUnexpected
    End Select
End Function

Private Sub RaiseFileError(ByVal errorCode As ErrorCode, ByVal description As String)
    Err.Raise errorCode, MODULE_NAME, description
End Sub

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: templates/modMathUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modMathUtils"

' ======================
' 定数定義
' ======================
Private Const EPSILON As Double = 0.0000000001 ' 浮動小数点比較用の許容誤差

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 安全な除算を行います
''' </summary>
''' <param name="numerator">分子</param>
''' <param name="denominator">分母</param>
''' <param name="defaultValue">分母が0の場合の戻り値</param>
''' <returns>除算結果、またはデフォルト値</returns>
Public Function SafeDivide(ByVal numerator As Double, ByVal denominator As Double, _
                         Optional ByVal defaultValue As Variant = 0) As Variant
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "SafeDivide"
    End If
    
    On Error GoTo ErrorHandler
    
    If Abs(denominator) < EPSILON Then
        ' 分母が0の場合の警告を出力
        Dim errDetail As typErrorDetail
        With errDetail
            .ErrorCode = ERR_DIVISION_BY_ZERO
            .Description = "分母が0のため、デフォルト値" & CStr(defaultValue) & "を返します。(分子: " & CStr(numerator) & ")"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "SafeDivide"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
        
        SafeDivide = defaultValue
    Else
        SafeDivide = numerator / denominator
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SafeDivide"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "除算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "SafeDivide"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SafeDivide"
    End If
    SafeDivide = defaultValue
End Function

''' <summary>
''' 数値が指定された範囲内かどうかを確認します
''' </summary>
''' <param name="value">確認する値</param>
''' <param name="minValue">最小値</param>
''' <param name="maxValue">最大値</param>
''' <returns>範囲内の場合True</returns>
Public Function IsInRange(ByVal value As Double, ByVal minValue As Double, _
                        ByVal maxValue As Double) As Boolean
    If Not isInitialized Then InitializeModule
    
    IsInRange = (value >= minValue And value <= maxValue)
End Function

''' <summary>
''' 値を指定された範囲内に収めます
''' </summary>
''' <param name="value">対象の値</param>
''' <param name="minValue">最小値</param>
''' <param name="maxValue">最大値</param>
''' <returns>範囲内に収められた値</returns>
Public Function Clamp(ByVal value As Double, ByVal minValue As Double, _
                     ByVal maxValue As Double) As Double
    If Not isInitialized Then InitializeModule
    
    If value < minValue Then
        Clamp = minValue
    ElseIf value > maxValue Then
        Clamp = maxValue
    Else
        Clamp = value
    End If
End Function

''' <summary>
''' 指定された精度で四捨五入します
''' </summary>
''' <param name="value">対象の値</param>
''' <param name="decimals">小数点以下の桁数</param>
''' <returns>四捨五入された値</returns>
Public Function Round(ByVal value As Double, Optional ByVal decimals As Long = 0) As Double
    If Not isInitialized Then InitializeModule
    
    Dim factor As Double
    factor = 10 ^ decimals
    Round = Fix(value * factor + 0.5) / factor
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: templates/modStackTrace.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modStackTrace"

' ======================
' 定数定義
' ======================
Private Const MAX_STACK_TRACE_DEPTH As Long = 10 ' スタックトレースの最大深さ

' ======================
' プライベート変数
' ======================
Private stack As Collection
Private isInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set stack = New Collection
    Set mLock = New clsLock
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set stack = Nothing
    Set mLock = Nothing
    isInitialized = False
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub PushStackEntry(ByVal ModuleName As String, ByVal ProcedureName As String)
    If Not isInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    If stack.Count < MAX_STACK_TRACE_DEPTH Then
        stack.Add ModuleName & "." & ProcedureName
    End If
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTracePushFailed
        .Description = "スタックトレースへのエントリ追加に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "PushStackEntry"
        .StackTrace = "モジュール: " & ModuleName & ", プロシージャ: " & ProcedureName
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
End Sub

Public Function PopStackEntry() As String
    If Not isInitialized Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As String
    If stack.Count > 0 Then
        result = stack(stack.Count)
        stack.Remove stack.Count
        PopStackEntry = result
    End If
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTracePopFailed
        .Description = "スタックトレースからのエントリ取得に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "PopStackEntry"
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
End Function

Public Function GetStackTrace() As String
    If Not isInitialized Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim i As Long
    Dim trace As String
    
    For i = stack.Count To 1 Step -1
        trace = trace & "  " & stack(i) & vbCrLf
    Next i
    
    GetStackTrace = trace
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTraceGetFailed
        .Description = "スタックトレース文字列の生成に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "GetStackTrace"
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
    GetStackTrace = "スタックトレースの取得に失敗しました。"
End Function

Public Property Get StackDepth() As Long
    If Not isInitialized Then Exit Property
    mLock.AcquireLock
    StackDepth = stack.Count
    mLock.ReleaseLock
End Property

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' スタックの内容をクリア（テスト用）
    ''' </summary>
    Private Sub ClearStack()
        If Not isInitialized Then Exit Sub
        mLock.AcquireLock
        Set stack = New Collection
        mLock.ReleaseLock
    End Sub
    
    ''' <summary>
    ''' スタックの状態が有効かどうかを検証（テスト用）
    ''' </summary>
    ''' <returns>スタックの深さが最大値以下の場合True</returns>
    Private Function ValidateStackState() As Boolean
        If Not isInitialized Then Exit Function
        mLock.AcquireLock
        ValidateStackState = (stack.Count <= MAX_STACK_TRACE_DEPTH)
        mLock.ReleaseLock
    End Function
    
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: templates/modStringUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modStringUtils"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 文字列を左側からパディングします
''' </summary>
''' <param name="baseStr">対象の文字列</param>
''' <param name="totalWidth">目標の長さ</param>
''' <param name="padChar">パディング文字（オプション）</param>
''' <returns>パディングされた文字列</returns>
Public Function PadLeft(ByVal baseStr As String, ByVal totalWidth As Long, _
                      Optional ByVal padChar As String = " ") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "PadLeft"
    End If
    
    On Error GoTo ErrorHandler
    
    If Len(baseStr) >= totalWidth Then
        PadLeft = baseStr
    Else
        PadLeft = String(totalWidth - Len(baseStr), Left$(padChar, 1)) & baseStr
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadLeft"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "文字列のパディング中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "PadLeft"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadLeft"
    End If
    PadLeft = baseStr
End Function

''' <summary>
''' 文字列を右側からパディングします
''' </summary>
''' <param name="baseStr">対象の文字列</param>
''' <param name="totalWidth">目標の長さ</param>
''' <param name="padChar">パディング文字（オプション）</param>
''' <returns>パディングされた文字列</returns>
Public Function PadRight(ByVal baseStr As String, ByVal totalWidth As Long, _
                       Optional ByVal padChar As String = " ") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "PadRight"
    End If
    
    On Error GoTo ErrorHandler
    
    If Len(baseStr) >= totalWidth Then
        PadRight = baseStr
    Else
        PadRight = baseStr & String(totalWidth - Len(baseStr), Left$(padChar, 1))
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadRight"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "文字列のパディング中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "PadRight"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadRight"
    End If
    PadRight = baseStr
End Function

''' <summary>
''' 文字列の前後の空白を削除します
''' </summary>
''' <param name="str">対象の文字列</param>
''' <returns>トリムされた文字列</returns>
Public Function TrimString(ByVal str As String) As String
    If Not isInitialized Then InitializeModule
    
    TrimString = Trim$(str)
End Function

''' <summary>
''' 文字列を指定された区切り文字で分割します
''' </summary>
''' <param name="str">対象の文字列</param>
''' <param name="delimiter">区切り文字</param>
''' <returns>分割された文字列の配列</returns>
Public Function SplitString(ByVal str As String, ByVal delimiter As String) As Variant
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "SplitString"
    End If
    
    On Error GoTo ErrorHandler
    
    SplitString = Split(str, delimiter)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SplitString"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "文字列の分割中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "SplitString"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SplitString"
    End If
    SplitString = Array()
End Function

''' <summary>
''' 文字列配列を指定された区切り文字で結合します
''' </summary>
''' <param name="arr">文字列配列</param>
''' <param name="delimiter">区切り文字</param>
''' <returns>結合された文字列</returns>
Public Function JoinStrings(ByRef arr As Variant, Optional ByVal delimiter As String = "") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "JoinStrings"
    End If
    
    On Error GoTo ErrorHandler
    
    JoinStrings = Join(arr, delimiter)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "JoinStrings"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "文字列の結合中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "JoinStrings"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "JoinStrings"
    End If
    JoinStrings = ""
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: templates/modTestRunner.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modTestRunner"

' ======================
' テスト実行モジュール
' ======================
Public Sub RunAllTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.InitializeTestModule

    ' エラーハンドリング関連のテスト
    RunErrorHandlingTests
    
    ' ロギング関連のテスト
    RunLoggingTests
    
    ' ファイル操作関連のテスト
    RunFileOperationsTests
    
    ' バリデーション関連のテスト
    RunValidationTests
    
    ' ユーティリティ関連のテスト
    RunUtilityTests
    
    ' データベース関連のテスト
    RunDatabaseTests
    
    ' セキュリティ関連のテスト
    RunSecurityTests
    
    ' パフォーマンス関連のテスト
    RunPerformanceTests
    
    ' テストレポートの出力
    Debug.Print modTestUtility.GenerateTestReport
    modTestUtility.CleanupTestModule
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テスト実行中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "RunAllTests"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

' ======================
' エラーハンドリングテスト
' ======================
Private Sub RunErrorHandlingTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_ErrorHandlers", "エラーハンドラーのテスト"
    Test_ErrorHandlers
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "エラーハンドリングテストでエラー発生: " & Err.Description
End Sub

' ======================
' ロギングテスト
' ======================
Private Sub RunLoggingTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_Loggers", "ロガーのテスト"
    Test_Loggers
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "ロギングテストでエラー発生: " & Err.Description
End Sub

' ======================
' ファイル操作テスト
' ======================
Private Sub RunFileOperationsTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_FileOperations", "ファイル操作のテスト"
    Test_FileOperations
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "ファイル操作テストでエラー発生: " & Err.Description
End Sub

' ======================
' バリデーションテスト
' ======================
Private Sub RunValidationTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_Validators", "バリデーターのテスト"
    Test_Validators
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "バリデーションテストでエラー発生: " & Err.Description
End Sub

' ======================
' ユーティリティテスト
' ======================
Private Sub RunUtilityTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_MathUtils", "数学ユーティリティのテスト"
    Test_MathUtils
    modTestUtility.EndTest modTestUtility.ResultPass
    
    modTestUtility.StartTest "Test_StringUtils", "文字列ユーティリティのテスト"
    Test_StringUtils
    modTestUtility.EndTest modTestUtility.ResultPass
    
    modTestUtility.StartTest "Test_DateUtils", "日付ユーティリティのテスト"
    Test_DateUtils
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "ユーティリティテストでエラー発生: " & Err.Description
End Sub

' ======================
' データベーステスト
' ======================
Private Sub RunDatabaseTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_DatabaseUtils", "データベースユーティリティのテスト"
    Test_DatabaseUtils
    modTestUtility.EndTest modTestUtility.ResultPass
    
    modTestUtility.StartTest "Test_ConnectionPool", "接続プールのテスト"
    Test_ConnectionPool
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "データベーステストでエラー発生: " & Err.Description
End Sub

' ======================
' セキュリティテスト
' ======================
Private Sub RunSecurityTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_Crypto", "暗号化のテスト"
    Test_Crypto
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "セキュリティテストでエラー発生: " & Err.Description
End Sub

' ======================
' パフォーマンステスト
' ======================
Private Sub RunPerformanceTests()
    On Error GoTo ErrorHandler
    
    modTestUtility.StartTest "Test_PerformanceMonitor", "パフォーマンスモニターのテスト"
    Test_PerformanceMonitor
    modTestUtility.EndTest modTestUtility.ResultPass
    
    modTestUtility.StartTest "Test_Lock", "ロック機能のテスト"
    Test_Lock
    modTestUtility.EndTest modTestUtility.ResultPass
    
    modTestUtility.StartTest "Test_CallStack", "コールスタックのテスト"
    Test_CallStack
    modTestUtility.EndTest modTestUtility.ResultPass
    
    Exit Sub

ErrorHandler:
    modTestUtility.EndTest modTestUtility.ResultFail, "パフォーマンステストでエラー発生: " & Err.Description
End Sub

#If DEBUG Then
    ' ======================
    ' エラーハンドリングテストケース
    ' ======================
    Private Sub Test_ErrorHandlers()
        ' DatabaseConnectionErrorHandlerのテスト
        Dim dbErrorHandler As New DatabaseConnectionErrorHandler
        modTestUtility.AssertTrue TypeOf dbErrorHandler Is IErrorHandler, "DatabaseConnectionErrorHandlerがIErrorHandlerを実装していることを確認"
        
        ' FileNotFoundErrorHandlerのテスト
        Dim fileNotFoundHandler As New FileNotFoundErrorHandler
        modTestUtility.AssertTrue TypeOf fileNotFoundHandler Is IErrorHandler, "FileNotFoundErrorHandlerがIErrorHandlerを実装していることを確認"
        
        ' InvalidInputErrorHandlerのテスト
        Dim invalidInputHandler As New InvalidInputErrorHandler
        modTestUtility.AssertTrue TypeOf invalidInputHandler Is IErrorHandler, "InvalidInputErrorHandlerがIErrorHandlerを実装していることを確認"
        
        ' エラーコードの検証
        Dim errInfo As New ErrorInfo
        modTestUtility.AssertTrue dbErrorHandler.HandleError(errInfo) <> 0, "エラーハンドリングの結果確認"
    End Sub
    
    ' ======================
    ' ロギングテストケース
    ' ======================
    Private Sub Test_Loggers()
        ' FileLoggerのテスト
        Dim fileLogger As New FileLogger
        modTestUtility.AssertTrue TypeOf fileLogger Is ILogger, "FileLoggerがILoggerを実装していることを確認"
        
        ' MockLoggerのテスト
        Dim mockLogger As New MockLogger
        modTestUtility.AssertTrue TypeOf mockLogger Is ILogger, "MockLoggerがILoggerを実装していることを確認"
        
        ' clsLoggerのテスト
        Dim logger As New clsLogger
        modTestUtility.AssertTrue TypeOf logger Is ILogger, "clsLoggerがILoggerを実装していることを確認"
        
        ' DefaultLoggerSettingsのテスト
        Dim settings As New DefaultLoggerSettings
        modTestUtility.AssertTrue TypeOf settings Is ILoggerSettings, "DefaultLoggerSettingsがILoggerSettingsを実装していることを確認"
        
        ' ログ出力のテスト
        fileLogger.LogMessage "テストメッセージ", LogLevel.Info
        mockLogger.LogMessage "テストメッセージ", LogLevel.Info
        logger.LogMessage "テストメッセージ", LogLevel.Info
    End Sub
    
    ' ======================
    ' ファイル操作テストケース
    ' ======================
    Private Sub Test_FileOperations()
        ' FileSystemOperationsのテスト
        Dim fileOps As New FileSystemOperations
        modTestUtility.AssertTrue TypeOf fileOps Is IFileOperations, "FileSystemOperationsがIFileOperationsを実装していることを確認"
        
        ' modFileIOのテスト
        Dim testPath As String
        testPath = "test.txt"
        
        modFileIO.WriteTextFile testPath, "テストデータ"
        modTestUtility.AssertTrue modFileIO.FileExists(testPath), "ファイル作成の確認"
        
        Dim content As String
        content = modFileIO.ReadTextFile(testPath)
        modTestUtility.AssertEqual "テストデータ", content, "ファイル内容の確認"
        
        modFileIO.DeleteFile testPath
        modTestUtility.AssertFalse modFileIO.FileExists(testPath), "ファイル削除の確認"
    End Sub
    
    ' ======================
    ' バリデーションテストケース
    ' ======================
    Private Sub Test_Validators()
        ' StringValidatorのテスト
        Dim strValidator As New StringValidator
        modTestUtility.AssertTrue TypeOf strValidator Is IValidator, "StringValidatorがIValidatorを実装していることを確認"
        modTestUtility.AssertTrue strValidator.Validate("テスト"), "有効な文字列の検証"
        modTestUtility.AssertFalse strValidator.Validate(""), "空文字列の検証"
        
        ' DateValidatorのテスト
        Dim dateValidator As New DateValidator
        modTestUtility.AssertTrue TypeOf dateValidator Is IValidator, "DateValidatorがIValidatorを実装していることを確認"
        modTestUtility.AssertTrue dateValidator.Validate(Date), "有効な日付の検証"
        modTestUtility.AssertFalse dateValidator.Validate(Empty), "無効な日付の検証"
    End Sub
    
    ' ======================
    ' ユーティリティテストケース
    ' ======================
    Private Sub Test_MathUtils()
        modTestUtility.AssertEqual 10, modMathUtils.Add(7, 3), "加算のテスト"
        modTestUtility.AssertEqual 4, modMathUtils.Subtract(7, 3), "減算のテスト"
        modTestUtility.AssertEqual 21, modMathUtils.Multiply(7, 3), "乗算のテスト"
    End Sub
    
    Private Sub Test_StringUtils()
        modTestUtility.AssertEqual "HELLO", modStringUtils.ToUpper("hello"), "大文字変換のテスト"
        modTestUtility.AssertEqual "hello", modStringUtils.ToLower("HELLO"), "小文字変換のテスト"
        modTestUtility.AssertTrue modStringUtils.IsEmpty(""), "空文字チェックのテスト"
    End Sub
    
    Private Sub Test_DateUtils()
        Dim testDate As Date
        testDate = DateSerial(2025, 1, 1)
        
        modTestUtility.AssertEqual 2025, modDateUtils.GetYear(testDate), "年の取得テスト"
        modTestUtility.AssertEqual 1, modDateUtils.GetMonth(testDate), "月の取得テスト"
        modTestUtility.AssertEqual 1, modDateUtils.GetDay(testDate), "日の取得テスト"
    End Sub
    
    ' ======================
    ' データベーステストケース
    ' ======================
    Private Sub Test_DatabaseUtils()
        ' 接続文字列の生成テスト
        Dim connStr As String
        connStr = modDatabaseUtils.BuildConnectionString("Server", "Database", "User", "Pass")
        modTestUtility.AssertTrue Len(connStr) > 0, "接続文字列生成のテスト"
    End Sub
    
    Private Sub Test_ConnectionPool()
        Dim pool As New ConnectionPool
        
        ' プール設定のテスト
        pool.MaxPoolSize = 10
        modTestUtility.AssertEqual 10, pool.MaxPoolSize, "最大プールサイズの設定テスト"
        
        ' 接続管理のテスト
        modTestUtility.AssertEqual 0, pool.ActiveConnections, "初期接続数のテスト"
    End Sub
    
    ' ======================
    ' セキュリティテストケース
    ' ======================
    Private Sub Test_Crypto()
        Dim crypto As New clsCrypto
        
        ' プロバイダーの検証
        modTestUtility.AssertTrue crypto.ValidateProvider(), "ValidateProviderのテスト"
        
        ' 暗号化/復号化のテスト
        Const testString As String = "テスト文字列"
        Const testKey As String = "テストキー"
        
        Dim encrypted As String
        encrypted = crypto.EncryptString(testString, testKey)
        modTestUtility.AssertTrue Len(encrypted) > 0, "暗号化テスト"
        
        Dim decrypted As String
        decrypted = crypto.DecryptString(encrypted, testKey)
        modTestUtility.AssertEqual testString, decrypted, "復号化テスト"
    End Sub
    
    ' ======================
    ' パフォーマンステストケース
    ' ======================
    Private Sub Test_PerformanceMonitor()
        Dim monitor As New clsPerformanceMonitor
        
        monitor.StartMeasurement "TestOperation"
        ' 何らかの処理
        monitor.EndMeasurement "TestOperation"
        
        Dim result As String
        result = monitor.GetMeasurement("TestOperation")
        modTestUtility.AssertTrue Len(result) > 0, "パフォーマンス計測結果の確認"
    End Sub
    
    Private Sub Test_Lock()
        Dim lock As New clsLock
        
        modTestUtility.AssertTrue lock.TryAcquire(), "ロック取得のテスト"
        lock.Release
        modTestUtility.AssertTrue lock.TryAcquire(), "ロック解放後の再取得テスト"
    End Sub
    
    Private Sub Test_CallStack()
        Dim callStack As New clsCallStack
        
        ' Push/Popのテスト
        callStack.Push "Module1", "Proc1"
        callStack.Push "Module2", "Proc2"
        
        modTestUtility.AssertEqual "Module2.Proc2", callStack.Pop(), "Pop()のテスト1"
        modTestUtility.AssertEqual "Module1.Proc1", callStack.Pop(), "Pop()のテスト2"
        
        ' スタックの状態検証
        modTestUtility.AssertTrue callStack.ValidateStackState(), "ValidateStackStateのテスト"
    End Sub
#End If

================
File: templates/modTestUtility.bas
================
Option Explicit

' ======================
' テスト関連の定数
' ======================
Private Const MODULE_NAME As String = "modTestUtility"
Private Const TEST_RESULTS_FILE As String = "TestResults.log"

' テスト結果の状態
Public Enum TestResult
    ResultPass = 1
    ResultFail = 2
    ResultSkip = 3
    ResultError = 4
End Enum

' テストケース情報
Private Type TestCase
    Name As String
    Description As String
    Category As String
    Priority As Integer
    Result As TestResult
    ErrorMessage As String
    ExecutionTime As Double
End Type

' ======================
' プライベート変数
' ======================
Private testCases As Collection
Private performanceMonitor As clsPerformanceMonitor
Private currentTestCase As TestCase
Private isInitialized As Boolean

' ======================
' 初期化処理
' ======================
Public Sub InitializeTestModule()
    If isInitialized Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    Set testCases = New Collection
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テストモジュールの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeTestModule"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' 初期化失敗時は例外を再スロー
    Err.Raise errDetail.Code, errDetail.Source, errDetail.Description
End Sub

' ======================
' テスト実行関連
' ======================
Public Sub StartTest(ByVal testName As String, ByVal description As String, _
                    Optional ByVal category As String = "General", _
                    Optional ByVal priority As Integer = 1)
                    
    If Not isInitialized Then InitializeTestModule
    On Error GoTo ErrorHandler
    
    ' 新しいテストケースを初期化
    With currentTestCase
        .Name = testName
        .Description = description
        .Category = category
        .Priority = priority
        .Result = ResultSkip
        .ErrorMessage = ""
    End With
    
    ' パフォーマンス計測開始
    performanceMonitor.StartMeasurement testName
    
    ' ログにテスト開始を記録
    LogTestEvent "テスト開始: " & testName & " (" & description & ")"
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テスト開始処理中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "StartTest"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' エラー発生時は現在のテストのパフォーマンス計測を終了
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement testName
    End If
    ' エラー発生時はテストをエラー状態で終了
    EndTest ResultError, "テスト開始処理中にエラーが発生: " & Err.Description
End Sub

Public Sub EndTest(ByVal result As TestResult, Optional ByVal errorMessage As String = "")
    If Not isInitialized Then Exit Sub
    On Error GoTo ErrorHandler
    
    Dim originalResult As TestResult
    originalResult = result
    
    ' パフォーマンス計測終了
    performanceMonitor.EndMeasurement currentTestCase.Name
    
    ' テスト結果を設定
    With currentTestCase
        .Result = result
        .ErrorMessage = errorMessage
        .ExecutionTime = GetTestExecutionTime(.Name)
    End With
    
    ' テストケースをコレクションに追加
    testCases.Add currentTestCase, currentTestCase.Name
    
    ' ログにテスト終了を記録
    LogTestEvent "テスト終了: " & currentTestCase.Name & " - " & GetResultText(result)
    If errorMessage <> "" Then
        LogTestEvent "エラー詳細: " & errorMessage
    End If
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テスト終了処理中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "EndTest"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' エラー発生時は元のテスト結果を保持しつつ、エラーメッセージを追加
    With currentTestCase
        .Result = originalResult
        .ErrorMessage = .ErrorMessage & vbCrLf & "テスト終了処理中にエラーが発生: " & Err.Description
    End With
End Sub

' ======================
' アサーション関数
' ======================
Public Sub AssertEqual(ByVal expected As Variant, ByVal actual As Variant, _
                      Optional ByVal message As String = "")
    If Not isInitialized Then InitializeTestModule
    On Error GoTo ErrorHandler
    
    If expected <> actual Then
        Dim errorMsg As String
        errorMsg = "AssertEqual失敗: " & vbCrLf & _
                  "期待値: " & CStr(expected) & vbCrLf & _
                  "実際値: " & CStr(actual)
        If message <> "" Then
            errorMsg = errorMsg & vbCrLf & "メッセージ: " & message
        End If
        
        EndTest ResultFail, errorMsg
        Exit Sub
    End If
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "AssertEqual実行中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "AssertEqual"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' アサーション実行中のエラーはテストを失敗として扱う
    EndTest ResultFail, "アサーション実行中にエラーが発生: " & Err.Description
End Sub

Public Sub AssertTrue(ByVal condition As Boolean, Optional ByVal message As String = "")
    If Not isInitialized Then InitializeTestModule
    On Error GoTo ErrorHandler
    
    If Not condition Then
        Dim errorMsg As String
        errorMsg = "AssertTrue失敗"
        If message <> "" Then
            errorMsg = errorMsg & ": " & message
        End If
        
        EndTest ResultFail, errorMsg
        Exit Sub
    End If
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "AssertTrue実行中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "AssertTrue"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' アサーション実行中のエラーはテストを失敗として扱う
    EndTest ResultFail, "アサーション実行中にエラーが発生: " & Err.Description
End Sub

Public Sub AssertFalse(ByVal condition As Boolean, Optional ByVal message As String = "")
    If Not isInitialized Then InitializeTestModule
    On Error GoTo ErrorHandler
    
    If condition Then
        Dim errorMsg As String
        errorMsg = "AssertFalse失敗"
        If message <> "" Then
            errorMsg = errorMsg & ": " & message
        End If
        
        EndTest ResultFail, errorMsg
        Exit Sub
    End If
    Exit Sub

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "AssertFalse実行中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "AssertFalse"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' アサーション実行中のエラーはテストを失敗として扱う
    EndTest ResultFail, "アサーション実行中にエラーが発生: " & Err.Description
End Sub

' ======================
' テスト結果レポート
' ======================
Public Function GenerateTestReport() As String
    If Not isInitialized Then InitializeTestModule
    On Error GoTo ErrorHandler
    
    Dim report As String
    Dim testCase As TestCase
    Dim i As Long
    Dim totalTests As Long
    Dim passedTests As Long
    Dim failedTests As Long
    Dim skippedTests As Long
    Dim errorTests As Long
    
    report = "テスト実行レポート" & vbCrLf & _
            "=================" & vbCrLf & _
            "実行日時: " & Now & vbCrLf & vbCrLf
    
    ' カテゴリ別の結果集計
    Dim categories As Collection
    Set categories = New Collection
    
    For i = 1 To testCases.Count
        testCase = testCases(i)
        
        ' カテゴリの追加
        On Error Resume Next
        categories.Add testCase.Category, testCase.Category
        On Error GoTo ErrorHandler
        
        ' 全体の集計
        totalTests = totalTests + 1
        Select Case testCase.Result
            Case ResultPass: passedTests = passedTests + 1
            Case ResultFail: failedTests = failedTests + 1
            Case ResultSkip: skippedTests = skippedTests + 1
            Case ResultError: errorTests = errorTests + 1
        End Select
    Next i
    
    ' 概要の追加
    report = report & "概要:" & vbCrLf & _
            "- 総テスト数: " & totalTests & vbCrLf & _
            "- 成功: " & passedTests & vbCrLf & _
            "- 失敗: " & failedTests & vbCrLf & _
            "- スキップ: " & skippedTests & vbCrLf & _
            "- エラー: " & errorTests & vbCrLf & vbCrLf
    
    ' カテゴリ別の詳細
    report = report & "カテゴリ別詳細:" & vbCrLf & _
            "=================" & vbCrLf
    
    Dim category As Variant
    For Each category In categories
        report = report & vbCrLf & "カテゴリ: " & category & vbCrLf
        
        For i = 1 To testCases.Count
            testCase = testCases(i)
            If testCase.Category = category Then
                report = report & _
                        "  - " & testCase.Name & vbCrLf & _
                        "    結果: " & GetResultText(testCase.Result) & vbCrLf & _
                        "    実行時間: " & Format$(testCase.ExecutionTime, "0.000") & " ms" & vbCrLf
                If testCase.ErrorMessage <> "" Then
                    report = report & "    エラー: " & testCase.ErrorMessage & vbCrLf
                End If
            End If
        Next i
    Next category
    
    GenerateTestReport = report
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テストレポート生成中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GenerateTestReport"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' レポート生成エラー時は基本情報のみ返す
    GenerateTestReport = "テストレポート生成中にエラーが発生しました。" & vbCrLf & _
                        "エラー詳細: " & Err.Description & vbCrLf & _
                        "実行日時: " & Now
End Function

' ======================
' ユーティリティ関数
' ======================
Private Function GetResultText(ByVal result As TestResult) As String
    Select Case result
        Case ResultPass: GetResultText = "成功"
        Case ResultFail: GetResultText = "失敗"
        Case ResultSkip: GetResultText = "スキップ"
        Case ResultError: GetResultText = "エラー"
        Case Else: GetResultText = "不明"
    End Select
End Function

Private Function GetTestExecutionTime(ByVal testName As String) As Double
    On Error GoTo ErrorHandler
    
    Dim perfData As String
    perfData = performanceMonitor.GetMeasurement(testName)
    
    ' 実行時間を抽出（パフォーマンスモニターの出力形式に依存）
    Dim pos As Long
    pos = InStr(perfData, "Elapsed Time: ")
    If pos > 0 Then
        GetTestExecutionTime = Val(Mid$(perfData, pos + 14))
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "テスト実行時間の取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "GetTestExecutionTime"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    ' エラー時は0を返す
    GetTestExecutionTime = 0
End Function

Private Sub LogTestEvent(ByVal message As String)
    On Error Resume Next
    
    ' clsLoggerを使用してログを出力
    With New clsLogger
        Dim settings As New DefaultLoggerSettings
        settings.LogFilePath = TEST_RESULTS_FILE
        settings.LogDestination = LOG_DESTINATION_FILE
        .Configure settings
        .Log MODULE_NAME, message, 0
   eEnd With
    
    If Err.Number <> 0 Then
        Debug.Print "ログ出力エラー: " & Err.Description
        Err.Clear
    End If
End Sub

' ======================
' クリーンアップ
' ======================
Public Sub CleanupTestModule()
    If Not isInitialized Then Exit Sub
    
    On Error Resume Next
    Set testCases = Nothing
    Set performanceMonitor = Nothing
    isInitialized = False
    
    If Err.Number <> 0 Then
        Debug.Print "クリーンアップ中にエラーが発生: " & Err.Description
        Err.Clear
    End If
End Sub

================
File: templates/modWindowsAPI.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modWindowsAPI"

' ======================
' Windows API宣言
' ======================

' --- INIファイル操作 ---
Public Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" ( _
    ByVal lpApplicationName As String, ByVal lpKeyName As Any, _
    ByVal lpDefault As String, ByVal lpReturnedString As String, _
    ByVal nSize As Long, ByVal lpFileName As String) As Long

Public Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" ( _
    ByVal lpApplicationName As String, ByVal lpKeyName As Any, _
    ByVal lpString As Any, ByVal lpFileName As String) As Long

' --- ファイル操作 ---
Public Declare PtrSafe Function GetFileAttributes Lib "kernel32" Alias "GetFileAttributesA" ( _
    ByVal lpFileName As String) As Long

Public Declare PtrSafe Function SetFileAttributes Lib "kernel32" Alias "SetFileAttributesA" ( _
    ByVal lpFileName As String, ByVal dwFileAttributes As Long) As Long

' --- タイマー操作 ---
Public Declare PtrSafe Function SetTimer Lib "user32" ( _
    ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr, _
    ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr

Public Declare PtrSafe Function KillTimer Lib "user32" ( _
    ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr) As Long

' --- ミューテックス操作 ---
Public Declare PtrSafe Function CreateMutex Lib "kernel32" Alias "CreateMutexA" ( _
    ByVal lpMutexAttributes As LongPtr, ByVal bInitialOwner As Long, _
    ByVal lpName As String) As LongPtr

Public Declare PtrSafe Function ReleaseMutex Lib "kernel32" ( _
    ByVal hMutex As LongPtr) As Long

Public Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
    ByVal hObject As LongPtr) As Long

Public Declare PtrSafe Function WaitForSingleObject Lib "kernel32" ( _
    ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long

' --- 暗号化操作 ---
Public Declare PtrSafe Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" ( _
    ByRef phProv As LongPtr, ByVal pszContainer As String, _
    ByVal pszProvider As String, ByVal dwProvType As Long, _
    ByVal dwFlags As Long) As Long

Public Declare PtrSafe Function CryptCreateHash Lib "advapi32.dll" ( _
    ByVal hProv As LongPtr, ByVal Algid As Long, _
    ByVal hKey As LongPtr, ByVal dwFlags As Long, _
    ByRef phHash As LongPtr) As Long

Public Declare PtrSafe Function CryptHashData Lib "advapi32.dll" ( _
    ByVal hHash As LongPtr, ByRef pbData As Any, _
    ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long

Public Declare PtrSafe Function CryptGetHashParam Lib "advapi32.dll" ( _
    ByVal hHash As LongPtr, ByVal dwParam As Long, _
    ByRef pbData As Any, ByRef pdwDataLen As Long, _
    ByVal dwFlags As Long) As Long

Public Declare PtrSafe Function CryptDestroyHash Lib "advapi32.dll" ( _
    ByVal hHash As LongPtr) As Long

Public Declare PtrSafe Function CryptReleaseContext Lib "advapi32.dll" ( _
    ByVal hProv As LongPtr, ByVal dwFlags As Long) As Long

' --- AES暗号化関連 ---
Public Declare PtrSafe Function CryptGenKey Lib "advapi32.dll" ( _
    ByVal hProv As LongPtr, ByVal Algid As Long, _
    ByVal dwFlags As Long, ByRef phKey As LongPtr) As Long

Public Declare PtrSafe Function CryptImportKey Lib "advapi32.dll" ( _
    ByVal hProv As LongPtr, ByRef pbData As Any, _
    ByVal dwDataLen As Long, ByVal hPubKey As LongPtr, _
    ByVal dwFlags As Long, ByRef phKey As LongPtr) As Long

Public Declare PtrSafe Function CryptDestroyKey Lib "advapi32.dll" ( _
    ByVal hKey As LongPtr) As Long

Public Declare PtrSafe Function CryptEncrypt Lib "advapi32.dll" ( _
    ByVal hKey As LongPtr, ByVal hHash As LongPtr, _
    ByVal Final As Long, ByVal dwFlags As Long, _
    ByRef pbData As Any, ByRef pdwDataLen As Long, _
    ByVal dwBufLen As Long) As Long

Public Declare PtrSafe Function CryptDecrypt Lib "advapi32.dll" ( _
    ByVal hKey As LongPtr, ByVal hHash As LongPtr, _
    ByVal Final As Long, ByVal dwFlags As Long, _
    ByRef pbData As Any, ByRef pdwDataLen As Long) As Long

Public Declare PtrSafe Function CryptDeriveKey Lib "advapi32.dll" ( _
    ByVal hProv As LongPtr, ByVal Algid As Long, _
    ByVal hBaseData As LongPtr, ByVal dwFlags As Long, _
    ByRef phKey As LongPtr) As Long


Public Declare PtrSafe Function CryptSetKeyParam Lib "advapi32.dll" ( _
    ByVal hKey As LongPtr, ByVal dwParam As Long, _
    ByRef pbData As Any, ByVal dwFlags As Long) As Long

' --- メモリ操作 ---
Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
    ByRef Destination As Any, _
    ByRef Source As Any, _
    ByVal Length As LongPtr)

' --- パフォーマンスカウンター ---
Public Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" ( _
    lpPerformanceCount As Currency) As Long

Public Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" ( _
    lpFrequency As Currency) As Long

Public Declare PtrSafe Function GetProcessMemoryInfo Lib "psapi.dll" ( _
    ByVal Process As LongPtr, ByRef ppsmemCounters As PROCESS_MEMORY_COUNTERS, _
    ByVal cb As Long) As Long

Public Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As LongPtr

' ======================
' 定数定義
' ======================

' --- ファイル属性 ---
Public Const FILE_ATTRIBUTE_READONLY As Long = &H1
Public Const FILE_ATTRIBUTE_HIDDEN As Long = &H2
Public Const FILE_ATTRIBUTE_SYSTEM As Long = &H4
Public Const FILE_ATTRIBUTE_DIRECTORY As Long = &H10
Public Const FILE_ATTRIBUTE_ARCHIVE As Long = &H20
Public Const FILE_ATTRIBUTE_NORMAL As Long = &H80
Public Const INVALID_FILE_ATTRIBUTES As Long = -1

' --- タイマー関連 ---
Public Const INFINITE As Long = -1
Public Const WAIT_OBJECT_0 As Long = 0

' --- 暗号化関連 ---
Public Const MS_ENHANCED_PROV As String = "Microsoft Enhanced Cryptographic Provider v1.0"
Public Const PROV_RSA_FULL As Long = 1
Public Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Public Const CALG_SHA_256 As Long = &H800C
Public Const HP_HASHVAL As Long = 2
Public Const HP_HASHSIZE As Long = 4

' --- AES暗号化関連の定数 ---
Public Const CALG_AES_256 As Long = &H6610
Public Const CRYPT_EXPORTABLE As Long = &H1
Public Const KP_MODE As Long = 4
Public Const CRYPT_MODE_CBC As Long = 1
Public Const CRYPT_PADDING As Long = &H10

' ======================
' 型定義
' ======================
Public Type PROCESS_MEMORY_COUNTERS
    cb As Long
    PageFaultCount As Long
    PeakWorkingSetSize As Currency
    WorkingSetSize As Currency
    QuotaPeakPagedPoolUsage As Currency
    QuotaPagedPoolUsage As Currency
    QuotaPeakNonPagedPoolUsage As Currency
    QuotaNonPagedPoolUsage As Currency
    PagefileUsage As Currency
    PeakPagefileUsage As Currency
End Type

' ======================
' エラーコードマッピング
' ======================
Public Function MapWindowsErrorToAppError(ByVal windowsError As Long) As ErrorCode
    Select Case windowsError
        ' ファイル操作エラー
        Case 2, 3 ' ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND
            MapWindowsErrorToAppError = ErrFileNotFound
        Case 5 ' ERROR_ACCESS_DENIED
            MapWindowsErrorToAppError = ErrFileAccessDenied
        Case 32 ' ERROR_SHARING_VIOLATION
            MapWindowsErrorToAppError = ErrFileAccessDenied
            
        ' メモリ関連エラー
        Case 8, 14 ' ERROR_NOT_ENOUGH_MEMORY, ERROR_OUTOFMEMORY
            MapWindowsErrorToAppError = ErrSystemOutOfMemory
            
        ' その他のシステムエラー
        Case Else
            MapWindowsErrorToAppError = ErrUnexpected
    End Select
End Function

' ======================
' ユーティリティ関数
' ======================
Public Function GetLastWindowsError() As Long
    #If Win64 Then
        GetLastWindowsError = CreateObject("WScript.Shell").Environment("PROCESS")("ERROR_CODE")
    #Else
        GetLastWindowsError = Err.LastDllError
    #End If
End Function

Public Function IsValidHandle(ByVal handle As LongPtr) As Boolean
    IsValidHandle = (handle <> 0)
End Function

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function TestAPIAvailability() As Boolean
        Dim result As Boolean
        result = True
        
        ' 基本的なAPI機能のテスト
        Dim counter As Currency
        result = result And (QueryPerformanceCounter(counter) <> 0)
        
        ' ファイル操作APIのテスト
        Dim attr As Long
        attr = GetFileAttributes("C:\")
        result = result And (attr <> INVALID_FILE_ATTRIBUTES)
        
        TestAPIAvailability = result
    End Function
#End If

================
File: templates/MsgBoxNotifier.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "MsgBoxNotifier"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "MsgBoxNotifier"

' ======================
' インターフェース実装
' ======================
Implements IUserNotifier

' ======================
' プライベート変数
' ======================
Private mNotificationStyle As VbMsgBoxStyle
Private mDefaultTitle As String
Private mLock As clsLock

' ======================
' 初期化
' ======================
Private Sub Class_Initialize()
    mNotificationStyle = vbOKOnly Or vbInformation
    Set mLock = New clsLock
    mDefaultTitle = "エラー"
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
End Sub

' ======================
' IUserNotifier実装
' ======================
Private Function IUserNotifier_Notify(ByRef errorDetail As typErrorDetail, _
                                    Optional ByVal buttons As VbMsgBoxStyle = vbOKOnly, _
                                    Optional ByVal title As String = "エラー") As VbMsgBoxResult
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' エラーの重大度に応じてアイコンを設定
    Dim icon As VbMsgBoxStyle
    icon = GetIconForErrorCategory(errorDetail.Category)
    
    ' メッセージの組み立て
    Dim msg As String
    msg = BuildErrorMessage(errorDetail)
    
    ' メッセージボックスの表示（NotificationStyleを適用）
    IUserNotifier_Notify = MsgBox(msg, mNotificationStyle Or buttons Or icon, title)
    
Cleanup:
    mLock.ReleaseLock
    Exit Function

    
ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "エラー通知の表示中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IUserNotifier_Notify"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
        ' エラーの種類に応じて適切な戻り値を設定
        Select Case errDetail.Category
            Case ECSystem, ECSecurity
                ' システムエラーやセキュリティエラーの場合は中断を示すvbCancelを返す
                IUserNotifier_Notify = vbCancel
            Case ECDatabase, ECNetwork
                ' データベースやネットワークエラーの場合はリトライを促すvbRetryを返す
                IUserNotifier_Notify = vbRetry
            Case Else
                ' その他のエラーの場合は一般的なvbAbortを返す
                IUserNotifier_Notify = vbAbort
        End Select
        
    Resume Cleanup
End Function

Private Property Let IUserNotifier_NotificationStyle(ByVal style As VbMsgBoxStyle)
    mNotificationStyle = style
End Property

Private Property Get IUserNotifier_NotificationStyle() As VbMsgBoxStyle
    IUserNotifier_NotificationStyle = mNotificationStyle
End Property

Private Property Let IUserNotifier_DefaultTitle(ByVal title As String)
    mDefaultTitle = title
End Property

Private Property Get IUserNotifier_DefaultTitle() As String
    IUserNotifier_DefaultTitle = mDefaultTitle
End Property

' ======================
' プライベートメソッド
' ======================
Private Function GetIconForErrorCategory(ByVal category As ErrorCodeCategory) As VbMsgBoxStyle
    Select Case category
        Case ECSystem, ECSecurity
            GetIconForErrorCategory = vbCritical
        Case ECDatabase, ECNetwork
            GetIconForErrorCategory = vbExclamation
        Case Else
            GetIconForErrorCategory = vbInformation
    End Select
End Function

Private Function BuildErrorMessage(ByRef errorDetail As typErrorDetail) As String
    Dim msg As String
    
    msg = "エラーが発生しました。" & vbCrLf & vbCrLf & _
          "説明: " & errorDetail.Description & vbCrLf & _
          "発生場所: " & errorDetail.Source & "." & errorDetail.ProcedureName
    
    ' スタックトレースが存在する場合は追加
    If Len(errorDetail.StackTrace) > 0 Then
        msg = msg & vbCrLf & vbCrLf & _
              "スタックトレース:" & vbCrLf & _
              errorDetail.StackTrace
    End If
    
    BuildErrorMessage = msg
End Function

================
File: templates/StringValidator.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "StringValidator"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "StringValidator"

' ======================
' インターフェース実装
' ======================
Implements IValidator

' ======================
' プライベート変数
' ======================
Private mErrorMessage As String
Private mMinLength As Long
Private mMaxLength As Long
Private mPattern As String

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mMinLength = 0
    mMaxLength = 2147483647 ' Long型の最大値
    mPattern = ""
    mErrorMessage = ""
End Sub

' ======================
' プロパティ
' ======================
Public Property Let MinLength(ByVal value As Long)
    mMinLength = value
End Property

Public Property Get MinLength() As Long
    MinLength = mMinLength
End Property

Public Property Let MaxLength(ByVal value As Long)
    mMaxLength = value
End Property

Public Property Get MaxLength() As Long
    MaxLength = mMaxLength
End Property

Public Property Let Pattern(ByVal value As String)
    mPattern = value
End Property

Public Property Get Pattern() As String
    Pattern = mPattern
End Property

Private Property Get IValidator_ErrorMessage() As String
    IValidator_ErrorMessage = mErrorMessage
End Property

' ======================
' メソッド
' ======================
Private Function IValidator_Validate(ByVal value As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    ' 文字列型チェック
    If VarType(value) <> vbString Then
        mErrorMessage = "値は文字列である必要があります。"
        IValidator_Validate = False
        Exit Function
    End If
    
    Dim strValue As String
    strValue = CStr(value)
    
    ' 長さチェック
    If Len(strValue) < mMinLength Then
        mErrorMessage = "文字列の長さが短すぎます。最小" & mMinLength & "文字必要です。"
        IValidator_Validate = False
        Exit Function
    End If
    
    If Len(strValue) > mMaxLength Then
        mErrorMessage = "文字列の長さが長すぎます。最大" & mMaxLength & "文字までです。"
        IValidator_Validate = False
        Exit Function
    End If
    
    ' パターンチェック
    If mPattern <> "" Then
        Dim regex As Object
        Set regex = CreateObject("VBScript.RegExp")
        With regex
            .Pattern = mPattern
            .Global = True
            .IgnoreCase = True
            
            If Not .Test(strValue) Then
                mErrorMessage = "文字列が指定されたパターンと一致しません。"
                IValidator_Validate = False
                Exit Function
            End If
        End With
    End If
    
    mErrorMessage = ""
    IValidator_Validate = True
    Exit Function

ErrorHandler:
    Dim errDetail As typErrorDetail
    With errDetail
        .ErrorCode = ERR_UNEXPECTED
        .Description = "文字列の検証中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IValidator_Validate"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    mErrorMessage = "検証中に予期せぬエラーが発生しました。"
    IValidator_Validate = False
End Function

' ======================
' ファクトリメソッド
' ======================
Public Function CreateEmailValidator() As StringValidator
    Set CreateEmailValidator = New StringValidator
    With CreateEmailValidator
        .Pattern = "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
    End With
End Function

Public Function CreatePhoneValidator() As StringValidator
    Set CreatePhoneValidator = New StringValidator
    With CreatePhoneValidator
        .Pattern = "^[0-9\-\(\)]+$"
        .MinLength = 10
        .MaxLength = 15
    End With
End Function
