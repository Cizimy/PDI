This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-27T00:45:23.072Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
ConnectionPool.cls
DatabaseConnectionErrorHandler.cls
FileIOImpl.cls
FileNotFoundErrorHandler.cls
FileSystemOperations.cls
IniFileImpl.cls
modDatabaseUtils.bas
modFileIO.bas
ODBCConnectionStringBuilder.cls
OLEDBConnectionStringBuilder.cls

================================================================
Files
================================================================

================
File: ConnectionPool.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ConnectionPool"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IConnectionPool

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "ConnectionPool"

' ======================
' 定数定義
' ======================
Private Const CONNECTION_TIMEOUT As Long = 30 ' 秒

' ======================
' メンバ変数
' ======================
Private Type ConnectionInfo
    Connection As Object
    InUse As Boolean
    LastUsed As Date
End Type

Private mConnections() As ConnectionInfo
Private mConnectionString As String
Private mPoolSize As Long
Private mLock As clsLock
Private mPerformanceMonitor As clsPerformanceMonitor
Private mLogger As ILogger
Private mConfig As IDatabaseConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Dim MAX_POOL_SIZE As Long
    ReDim mConnections(1 To MAX_POOL_SIZE)
    mPoolSize = 0
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
End Sub

Private Sub Class_Terminate()
    Dim i As Long
    Dim MAX_POOL_SIZE As Long
    For i = 1 To MAX_POOL_SIZE
        If Not mConnections(i).Connection Is Nothing Then
            If mConnections(i).Connection.State = 1 Then ' adStateOpen
                mConnections(i).Connection.Close
            End If
            Set mConnections(i).Connection = Nothing
        End If
    Next i
    Set mLock = Nothing
    Set mConfig = Nothing
    Set mLogger = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' パブリックメソッド
' ======================

''' <summary>
''' コネクションプールを初期化します
''' </summary>
''' <param name="config">データベース設定を提供するインターフェース</param>
''' <param name="performanceMonitor">パフォーマンスモニター</param>
''' <param name="lock">ロックオブジェクト</param>
''' <param name="logger">ロガー</param>
Public Sub Initialize(ByVal config As IDatabaseConfig, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal lock As ILock, _
                     ByVal logger As ILogger)
    Set mConfig = config
    Set mPerformanceMonitor = performanceMonitor
    Set mLock = lock
    Set mLogger = logger
    mConnectionString = mConfig.GetConnectionString
End Sub

''' <summary>
''' データベース接続を取得します（IConnectionPool実装）
''' </summary>
Private Function IConnectionPool_AcquireConnection() As Object
    On Error GoTo ErrorHandler
    mPerformanceMonitor.StartMeasurement "Get Database Connection"
    
    mLock.AcquireLock
    
    ' 未使用のコネクションを探す
    Dim i As Long
    For i = 1 To mPoolSize
        If Not mConnections(i).InUse Then
            ' コネクションの状態をチェック
            If ValidateConnection(mConnections(i).Connection) Then
                mConnections(i).InUse = True
                mConnections(i).LastUsed = Now
                Set IConnectionPool_AcquireConnection = mConnections(i).Connection
                GoTo Cleanup
            Else
                ' 無効なコネクションを破棄して再作成
                Set mConnections(i).Connection = CreateNewConnection()
                If Not mConnections(i).Connection Is Nothing Then
                    mConnections(i).InUse = True
                    mConnections(i).LastUsed = Now
                    Set IConnectionPool_AcquireConnection = mConnections(i).Connection
                    GoTo Cleanup
                End If
            End If
        End If
    Next i
    
    ' 新しいコネクションを作成（プールサイズが上限に達していない場合）
    Dim MAX_POOL_SIZE As Long
    MAX_POOL_SIZE = mConfig.GetMaxPoolSize
    If mPoolSize < MAX_POOL_SIZE Then
        mPoolSize = mPoolSize + 1
        Set mConnections(mPoolSize).Connection = CreateNewConnection()
        If Not mConnections(mPoolSize).Connection Is Nothing Then
            mConnections(mPoolSize).InUse = True
            mConnections(mPoolSize).LastUsed = Now
            GoTo Cleanup
        End If
    End If
    
    ' 利用可能なコネクションがない場合はエラー
    Err.Raise vbObjectError + 1, MODULE_NAME, "利用可能なコネクションがありません。"
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Get Database Connection"
    Exit Function
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDatabaseConnectionFailed
        .Description = "コネクション取得中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnection"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    If Not mLock Is Nothing Then mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Get Database Connection"
    Set IConnectionPool_AcquireConnection = Nothing
End Function

''' <summary>
''' データベース接続を解放します（IConnectionPool実装）
''' </summary>
''' <param name="connection">解放するコネクション</param>
Private Sub IConnectionPool_ReleaseConnection(ByVal connection As Object)
    If connection Is Nothing Then Exit Sub
    
    mLock.AcquireLock
    
    Dim i As Long
    For i = 1 To mPoolSize
        If mConnections(i).Connection Is connection Then
            mConnections(i).InUse = False
            mConnections(i).LastUsed = Now
            Exit For
        End If
    Next i
    
    mLock.ReleaseLock
End Sub

''' <summary>
''' 現在のアクティブな接続数を取得します（IConnectionPool実装）
''' </summary>
Private Property Get IConnectionPool_ActiveConnections() As Long
    Dim count As Long
    Dim i As Long
    For i = 1 To mPoolSize
        If mConnections(i).InUse Then count = count + 1
    Next i
    IConnectionPool_ActiveConnections = count
End Property

''' <summary>
''' プールの最大接続数を取得または設定します（IConnectionPool実装）
''' </summary>
Private Property Get IConnectionPool_MaxConnections() As Long
    IConnectionPool_MaxConnections = mConfig.GetMaxPoolSize
End Property

Private Property Let IConnectionPool_MaxConnections(ByVal value As Long)
    ' 設定は無視 - 設定はIDatabaseConfigで管理
End Property

''' <summary>
''' 接続タイムアウト時間を取得または設定します（IConnectionPool実装）
''' </summary>
Private Property Get IConnectionPool_ConnectionTimeout() As Long
    IConnectionPool_ConnectionTimeout = mConfig.GetConnectionTimeout
End Property

Private Property Let IConnectionPool_ConnectionTimeout(ByVal value As Long)
    ' 設定は無視 - 設定はIDatabaseConfigで管理
End Property

' ======================
' プライベートメソッド
' ======================

''' <summary>
''' 新しいデータベース接続を作成します
''' </summary>
Private Function CreateNewConnection() As Object
    On Error GoTo ErrorHandler
    mPerformanceMonitor.StartMeasurement "Create Database Connection"
    
    ' 接続文字列の検証
    If Not ValidateConnectionString(mConnectionString) Then
        mLogger.LogError MODULE_NAME, "CreateNewConnection", "不正な接続文字列です: " & mConnectionString
        Exit Function
    End If
    mLock.AcquireLock
    
    Dim conn As Object
    Set conn = CreateObject("ADODB.Connection")
    conn.ConnectionString = mConnectionString
    conn.ConnectionTimeout = CONNECTION_TIMEOUT
    
    ' リトライ処理を実装
    Dim retryCount As Long
    Dim retryInterval As Long
    retryCount = mConfig.GetRetryCount
    retryInterval = mConfig.GetRetryInterval
    
    Do While retryCount >= 0
        On Error Resume Next
        conn.Open
        If Err.Number = 0 Then Exit Do
        retryCount = retryCount - 1
        If retryCount >= 0 Then Sleep retryInterval
    Loop
    
    Set CreateNewConnection = conn
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "Create Database Connection"
    Exit Function
    
ErrorHandler:
    mLogger.LogError MODULE_NAME, "CreateNewConnection", "接続の作成に失敗しました: " & Err.Description
    Set CreateNewConnection = Nothing
    Resume Cleanup
End Function

''' <summary>
''' コネクションが有効かどうかを確認します
''' </summary>
Private Function ValidateConnection(ByVal connection As Object) As Boolean
    If connection Is Nothing Then
        ValidateConnection = False
        Exit Function
    End If
    
    On Error Resume Next
    ValidateConnection = (connection.State = 1) ' adStateOpen
    If Err.Number <> 0 Then
        ValidateConnection = False
    End If
    On Error GoTo 0
End Function

''' <summary>
''' 接続文字列を検証します
''' </summary>
Private Function ValidateConnectionString(ByVal connectionString As String) As Boolean
    If Len(Trim(connectionString)) = 0 Then
        ValidateConnectionString = False
        Exit Function
    End If
    
    ' 基本的な接続文字列の形式チェック
    If InStr(1, connectionString, "Provider=", vbTextCompare) = 0 And _
       InStr(1, connectionString, "Driver=", vbTextCompare) = 0 Then
        ValidateConnectionString = False
        Exit Function
    End If
    
    ValidateConnectionString = True
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' コネクションプールの現在のサイズを取得（テスト用）
    ''' </summary>
    Private Property Get PoolSize() As Long
        PoolSize = mPoolSize
    End Property
    
    ''' <summary>
    ''' アクティブなコネクション数を取得（テスト用）
    ''' </summary>
    Private Property Get ActiveConnections() As Long
        Dim count As Long
        Dim i As Long
        For i = 1 To mPoolSize
            If mConnections(i).InUse Then count = count + 1
        Next i
        ActiveConnections = count
    End Property
    
    ''' <summary>
    ''' コネクションプールをクリア（テスト用）
    ''' </summary>
    Private Sub ClearPool()
        Class_Terminate
        Class_Initialize
    End Sub
#End If

================
File: DatabaseConnectionErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DatabaseConnectionErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DatabaseConnectionErrorHandler"

' ======================
' 定数定義
' ======================
Private Const DEFAULT_RETRY_INTERVAL As Long = 1000 ' ミリ秒
Private Const MAX_RETRY_COUNT As Long = 3

' ======================
' プライベート変数
' ======================
Private mConnectionString As String
Private mLock As ILock
Private mLogger As ILogger
Private mEmergencyLogger As IEmergencyLogger
Private mConfig As IDatabaseConfig
Private mUserNotifier As IUserNotifier

Implements IErrorHandler

' =====================
' コンストラクタ
' =====================
Public Function Create( _
    ByVal lock As ILock, _
    ByVal logger As ILogger, _
    ByVal emergencyLogger As IEmergencyLogger, _
    ByVal config As IDatabaseConfig, _
    ByVal userNotifier As IUserNotifier _
) As DatabaseConnectionErrorHandler
    
    Dim instance As New DatabaseConnectionErrorHandler
    
    ' 依存性の注入
    With instance
        If lock Is Nothing Then
            Err.Raise 5, "DatabaseConnectionErrorHandler.Create", "ILock is required"
        End If
        Set .Lock = lock
        
        If logger Is Nothing Then
            Err.Raise 5, "DatabaseConnectionErrorHandler.Create", "ILogger is required"
        End If
        Set .Logger = logger
        
        If emergencyLogger Is Nothing Then
            Err.Raise 5, "DatabaseConnectionErrorHandler.Create", "IEmergencyLogger is required"
        End If
        Set .EmergencyLogger = emergencyLogger
        
        If config Is Nothing Then
            Err.Raise 5, "DatabaseConnectionErrorHandler.Create", "IDatabaseConfig is required"
        End If
        Set .Config = config
        
        If userNotifier Is Nothing Then
            Err.Raise 5, "DatabaseConnectionErrorHandler.Create", "IUserNotifier is required"
        End If
        Set .UserNotifier = userNotifier
    End With
    
    Set Create = instance
End Function

' プロパティ
Public Property Set Lock(ByVal value As ILock)
    Set mLock = value
End Property

Public Property Set Logger(ByVal value As ILogger)
    Set mLogger = value
End Property

Public Property Set EmergencyLogger(ByVal value As IEmergencyLogger)
    Set mEmergencyLogger = value
End Property

Public Property Set Config(ByVal value As IDatabaseConfig)
    Set mConfig = value
    mConnectionString = mConfig.GetConnectionString
End Property

Public Property Set UserNotifier(ByVal value As IUserNotifier)
    Set mUserNotifier = value
End Property

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As ErrorInfo) As Boolean
    Dim proceed As Boolean
    proceed = False  ' デフォルトでは処理を中断
    
    ' エラー情報をログに記録
    LogError errorDetail
    
    ' エラー情報の補完
    errorDetail.AddAdditionalInfo "ConnectionString", mConnectionString
    errorDetail.AddAdditionalInfo "MaxRetries", CStr(MAX_RETRY_COUNT)
    errorDetail.RecoveryAttempted = True
    
    ' リトライ処理の実行
    If AttemptRetry(errorDetail) Then
        proceed = True  ' リトライ成功
        errorDetail.RecoverySuccessful = True
    Else
        ' リトライ失敗時はユーザーに通知
        errorDetail.RecoverySuccessful = False
        NotifyUser errorDetail, vbCritical
    End If
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Function AttemptRetry(ByRef errorDetail As ErrorInfo) As Boolean
    On Error GoTo ErrorHandler
    
    Dim retryCount As Long
    Dim success As Boolean
    
    For retryCount = 1 To MAX_RETRY_COUNT
        ' リトライ間隔を設ける
        Wait DEFAULT_RETRY_INTERVAL
        
        errorDetail.AddAdditionalInfo "CurrentRetry", CStr(retryCount)
        
        If TryDatabaseConnection Then
            success = True
            Exit For
        End If
        
        ' リトライ試行をログに記録
        With mLogger
            .Log MODULE_NAME, "データベース接続リトライ " & retryCount & "/" & MAX_RETRY_COUNT, errorDetail.Code
        End With
    Next retryCount
    
    AttemptRetry = success
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベース接続のリトライ中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "AttemptRetry"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
    AttemptRetry = False
    Exit Function
End Function

Private Function TryDatabaseConnection() As Boolean
    On Error GoTo ErrorHandler
    
    Dim conn As Object
    Set conn = CreateObject("ADODB.Connection")
    conn.Open mConnectionString
    
    ' 接続テストのためのシンプルなクエリを実行
    conn.Execute "SELECT 1"
    
    conn.Close
    Set conn = Nothing
    TryDatabaseConnection = True
    Exit Function
    
ErrorHandler:
    Dim errNum As Long
    errNum = Err.Number
    
    ' エラー種別に応じた処理
    Select Case errNum
        Case -2147467259  ' ネットワークエラー
            LogSpecificError "ネットワーク接続エラー: サーバーに接続できません。", ECNetwork
        Case -2147217843  ' タイムアウト
            LogSpecificError "データベース接続がタイムアウトしました。", ECNetwork
        Case -2147217865  ' 認証エラー
            LogSpecificError "データベース認証エラー: ユーザー名またはパスワードが無効です。", ECSecurity
        Case Else
            LogSpecificError "データベース接続エラー: " & Err.Description, ECDatabase
    End Select
    
    If Not conn Is Nothing Then
        If conn.State = 1 Then  ' adStateOpen
            conn.Close
        End If
        Set conn = Nothing
    End If
    
    TryDatabaseConnection = False
    Exit Function
End Function

Private Sub LogSpecificError(ByVal message As String, ByVal category As ErrorCodeCategory)
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrDbConnectionFailed
        .Description = message
        .Category = category
        .Source = MODULE_NAME
        .ProcedureName = "TryDatabaseConnection"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
    End With
    modError.HandleError errDetail
End Sub

Private Sub LogError(ByRef errorDetail As ErrorInfo)
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' 通常のログ出力
    mLogger.Log MODULE_NAME, "データベース接続エラー: " & errorDetail.Description, errorDetail.Code
    ' 重要なエラーは緊急ログにも記録
    mEmergencyLogger.LogEmergency MODULE_NAME, errorDetail.ToString
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースエラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As ErrorInfo, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    mUserNotifier.Notify errorDetail, style, "データベースエラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースエラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

Private Sub Wait(ByVal milliseconds As Long)
    ' Sleep APIを使用して待機
    modWindowsAPI.Sleep milliseconds
End Sub

================
File: FileIOImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileIOImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileIOImpl"

' ======================
' インターフェース実装
' ======================
Implements IFileIO

' ======================
' プライベート変数
' ======================
Private mFSO As Object ' Scripting.FileSystemObject
Private mIsInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mFSO = CreateObject("Scripting.FileSystemObject")
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mFSO = Nothing
    mIsInitialized = False
End Sub

Private Sub InitializeIfNeeded()
    If Not mIsInitialized Then
        Class_Initialize
    End If
End Sub

' ======================
' IFileIO実装
' ======================
Private Function IFileIO_FileExists(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    On Error Resume Next
    IFileIO_FileExists = mFSO.FileExists(filePath)
    On Error GoTo 0
End Function

Private Function IFileIO_FolderExists(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    On Error Resume Next
    IFileIO_FolderExists = mFSO.FolderExists(folderPath)
    On Error GoTo 0
End Function

Private Function IFileIO_CreateFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    On Error GoTo ErrorHandler
    
    If IFileIO_FolderExists(folderPath) Then
        IFileIO_CreateFolder = True
        Exit Function
    End If
    
    mFSO.CreateFolder folderPath
    IFileIO_CreateFolder = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "フォルダの作成に失敗しました: " & folderPath
        .Source = MODULE_NAME & ".IFileIO_CreateFolder"
    End With
    Call modError.HandleError(errInfo)
    IFileIO_CreateFolder = False
End Function

Private Function IFileIO_DeleteFile(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    On Error GoTo ErrorHandler
    
    If Not IFileIO_FileExists(filePath) Then
        IFileIO_DeleteFile = True
        Exit Function
    End If
    
    mFSO.DeleteFile filePath, True ' Force = True
    IFileIO_DeleteFile = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "ファイルの削除に失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileIO_DeleteFile"
    End With
    Call modError.HandleError(errInfo)
    IFileIO_DeleteFile = False
End Function

Private Function IFileIO_CopyFile(ByVal sourceFilePath As String, ByVal destinationFilePath As String) As Boolean
    InitializeIfNeeded
    On Error GoTo ErrorHandler
    
    If Not IFileIO_FileExists(sourceFilePath) Then
        Err.Raise ErrFileNotFound, MODULE_NAME & ".IFileIO_CopyFile", "コピー元ファイルが存在しません: " & sourceFilePath
    End If
    
    mFSO.CopyFile sourceFilePath, destinationFilePath, True ' OverWrite = True
    IFileIO_CopyFile = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = Err.Number
        .Description = "ファイルのコピーに失敗しました: " & Err.Description
        .Source = MODULE_NAME & ".IFileIO_CopyFile"
    End With
    Call modError.HandleError(errInfo)
    IFileIO_CopyFile = False
End Function

Private Function IFileIO_MoveFile(ByVal sourceFilePath As String, ByVal destinationFilePath As String) As Boolean
    InitializeIfNeeded
    On Error GoTo ErrorHandler
    
    If Not IFileIO_FileExists(sourceFilePath) Then
        Err.Raise ErrFileNotFound, MODULE_NAME & ".IFileIO_MoveFile", "移動元ファイルが存在しません: " & sourceFilePath
    End If
    
    mFSO.MoveFile sourceFilePath, destinationFilePath
    IFileIO_MoveFile = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = Err.Number
        .Description = "ファイルの移動に失敗しました: " & Err.Description
        .Source = MODULE_NAME & ".IFileIO_MoveFile"
    End With
    Call modError.HandleError(errInfo)
    IFileIO_MoveFile = False
End Function

Private Function IFileIO_OpenFile(ByVal filePath As String, ByVal mode As String) As Object
    InitializeIfNeeded
    On Error GoTo ErrorHandler
    
    Dim fileMode As Integer
    Select Case UCase$(mode)
        Case "READ"
            fileMode = 1 ' ForReading
        Case "WRITE"
            fileMode = 2 ' ForWriting
        Case "APPEND"
            fileMode = 8 ' ForAppending
        Case Else
            Err.Raise vbObjectError + 1001, MODULE_NAME & ".IFileIO_OpenFile", "無効なファイルモード: " & mode
    End Select
    
    Set IFileIO_OpenFile = mFSO.OpenTextFile(filePath, fileMode, True) ' Create = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = Err.Number
        .Description = "ファイルを開けませんでした: " & Err.Description
        .Source = MODULE_NAME & ".IFileIO_OpenFile"
    End With
    Call modError.HandleError(errInfo)
    Set IFileIO_OpenFile = Nothing
End Function

Private Function IFileIO_CloseFile(ByVal file As Object) As Boolean
    On Error GoTo ErrorHandler
    
    If file Is Nothing Then
        IFileIO_CloseFile = True
        Exit Function
    End If
    
    file.Close
    IFileIO_CloseFile = True
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = Err.Number
        .Description = "ファイルを閉じる際にエラーが発生しました: " & Err.Description
        .Source = MODULE_NAME & ".IFileIO_CloseFile"
    End With
    Call modError.HandleError(errInfo)
    IFileIO_CloseFile = False
End Function

' ======================
' パブリックメソッド
' ======================
Public Function CreateInstance() As IFileIO
    Set CreateInstance = New FileIOImpl
End Function

' ======================
' テストサポート機能（開発環境専用）
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        Class_Terminate
        Class_Initialize
    End Sub
    
    ''' <summary>
    ''' 初期化状態を取得（テスト用）
    ''' </summary>
    Private Property Get IsInitialized() As Boolean
        IsInitialized = mIsInitialized
    End Property
#End If

================
File: FileNotFoundErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileNotFoundErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileNotFoundErrorHandler"

' ======================
' プライベート変数
' ======================
Private mLock As ILock
Private mLogger As ILogger
Private mEmergencyLogger As IEmergencyLogger
Private mUserNotifier As IUserNotifier
Private mFileOperations As IFileOperations

Implements IErrorHandler

' =====================
' コンストラクタ
' =====================
Public Function Create( _
    ByVal lock As ILock, _
    ByVal logger As ILogger, _
    ByVal emergencyLogger As IEmergencyLogger, _
    ByVal userNotifier As IUserNotifier, _
    ByVal fileOperations As IFileOperations _
) As FileNotFoundErrorHandler
    
    Dim instance As New FileNotFoundErrorHandler
    
    ' 依存性の注入
    With instance
        If lock Is Nothing Then
            Err.Raise 5, "FileNotFoundErrorHandler.Create", "ILock is required"
        End If
        Set .Lock = lock
        
        If logger Is Nothing Then
            Err.Raise 5, "FileNotFoundErrorHandler.Create", "ILogger is required"
        End If
        Set .Logger = logger
        
        If emergencyLogger Is Nothing Then
            Err.Raise 5, "FileNotFoundErrorHandler.Create", "IEmergencyLogger is required"
        End If
        Set .EmergencyLogger = emergencyLogger
        
        If userNotifier Is Nothing Then
            Err.Raise 5, "FileNotFoundErrorHandler.Create", "IUserNotifier is required"
        End If
        Set .UserNotifier = userNotifier
        
        If fileOperations Is Nothing Then
            Err.Raise 5, "FileNotFoundErrorHandler.Create", "IFileOperations is required"
        End If
        Set .FileOperations = fileOperations
    End With
    
    Set Create = instance
End Function

' プロパティ
Public Property Set Lock(ByVal value As ILock)
    Set mLock = value
End Property

Public Property Set Logger(ByVal value As ILogger)
    Set mLogger = value
End Property

Public Property Set EmergencyLogger(ByVal value As IEmergencyLogger)
    Set mEmergencyLogger = value
End Property

Public Property Set UserNotifier(ByVal value As IUserNotifier)
    Set mUserNotifier = value
End Property

Public Property Set FileOperations(ByVal value As IFileOperations)
    Set mFileOperations = value
End Property

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As ErrorInfo) As Boolean
    Dim proceed As Boolean
    proceed = False  ' デフォルトでは処理を中断
    
    mLock.AcquireLock
    
    ' エラー情報をログに記録
    LogError errorDetail
    
    ' エラー情報の補完
    If errorDetail.HasAdditionalInfo("FilePath") Then
        Dim filePath As String
        filePath = errorDetail.GetAdditionalInfo("FilePath")
        
        ' 代替ファイルパスの確認
        Dim alternativePath As String
        alternativePath = FindAlternativeFile(filePath)
        
        If alternativePath <> "" Then
            errorDetail.AddAdditionalInfo "AlternativeFilePath", alternativePath
            errorDetail.RecoveryAttempted = True
            errorDetail.RecoverySuccessful = True
            proceed = True
        Else
            ' バックアップファイルの確認
            Dim backupPath As String
            backupPath = CheckBackupFile(filePath)
            
            If backupPath <> "" Then
                errorDetail.AddAdditionalInfo "BackupFilePath", backupPath
                errorDetail.RecoveryAttempted = True
                errorDetail.RecoverySuccessful = True
                proceed = True
            End If
        End If
    End If
    
    mLock.ReleaseLock
    
    ' ユーザーに通知
    NotifyUser errorDetail, IIf(proceed, vbInformation, vbExclamation)
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Function FindAlternativeFile(ByVal originalPath As String) As String
    On Error GoTo ErrorHandler
    
    ' 1. 異なる拡張子のファイルを確認
    Dim extensions() As String
    extensions = Array(".bak", ".tmp", ".old")
    
    Dim basePath As String
    basePath = Left(originalPath, InStrRev(originalPath, ".") - 1)
    
    Dim i As Long
    For i = LBound(extensions) To UBound(extensions)
        Dim altPath As String
        altPath = basePath & extensions(i)
        
        If mFileOperations.FileExists(altPath) Then
            FindAlternativeFile = altPath
            Exit Function
        End If
    Next i
    
    ' 2. 同じ名前の異なるディレクトリを確認
    Dim parentPath As String
    parentPath = Left(originalPath, InStrRev(originalPath, "\") - 1)
    
    Dim fileName As String
    fileName = Mid(originalPath, InStrRev(originalPath, "\") + 1)
    
    Dim altDirs() As String
    altDirs = Array("\backup", "\archive", "\old")
    
    For i = LBound(altDirs) To UBound(altDirs)
        altPath = parentPath & altDirs(i) & "\" & fileName
        
        If mFileOperations.FileExists(altPath) Then
            FindAlternativeFile = altPath
            Exit Function
        End If
    Next i
    
    FindAlternativeFile = ""
    Exit Function

ErrorHandler:
    FindAlternativeFile = ""
End Function

Private Function CheckBackupFile(ByVal originalPath As String) As String
    On Error GoTo ErrorHandler
    
    Dim backupPath As String
    backupPath = originalPath & ".bak"
    
    If mFileOperations.FileExists(backupPath) Then
        CheckBackupFile = backupPath
    Else
        CheckBackupFile = ""
    End If
    Exit Function

ErrorHandler:
    CheckBackupFile = ""
End Function

Private Sub LogError(ByRef errorDetail As ErrorInfo)
    On Error GoTo ErrorHandler
    
    ' 通常のログ出力
    mLogger.Log MODULE_NAME, "ファイルが見つかりません: " & errorDetail.Description, errorDetail.Code
    
    ' 重要なエラーは緊急ログにも記録
    If errorDetail.Severity >= ESError Then
        mEmergencyLogger.LogEmergency MODULE_NAME, errorDetail.ToString
    End If
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ファイルエラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As ErrorInfo, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    Dim message As String
    message = "ファイルが見つかりません: " & errorDetail.Description
    
    If errorDetail.HasAdditionalInfo("AlternativeFilePath") Then
        message = message & vbCrLf & vbCrLf & _
                 "代替ファイルが見つかりました: " & _
                 errorDetail.GetAdditionalInfo("AlternativeFilePath")
    ElseIf errorDetail.HasAdditionalInfo("BackupFilePath") Then
        message = message & vbCrLf & vbCrLf & _
                 "バックアップファイルが見つかりました: " & _
                 errorDetail.GetAdditionalInfo("BackupFilePath")
    End If
    
    mUserNotifier.Notify errorDetail, style, "ファイルエラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ファイルエラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

================
File: FileSystemOperations.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileSystemOperations"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileSystemOperations"

' ======================
' インターフェース実装
' ======================
Implements IFileOperations

' ======================
' プライベート変数
' ======================
Private mLock As ILock
Private mPerformanceMonitor As IPerformanceMonitor
Private mFileIO As IFileIO
Private mIsInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 依存性は外部から注入されるため、ここでは初期化しない
    mIsInitialized = False
End Sub

''' <summary>
''' 依存性を注入して初期化します
''' </summary>
''' <param name="lock">ロック機構</param>
''' <param name="performanceMonitor">パフォーマンスモニター</param>
''' <param name="fileIO">ファイルI/O操作</param>
''' <remarks>
''' このメソッドは必ずインスタンス作成後に呼び出す必要があります
''' </remarks>
Public Sub Initialize(ByVal lock As ILock, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal fileIO As IFileIO)
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    Set mFileIO = fileIO
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    Set mFileIO = Nothing
    mIsInitialized = False
End Sub

Private Sub InitializeIfNeeded()
    If Not mIsInitialized Then
        Err.Raise vbObjectError + 1000, MODULE_NAME, "オブジェクトが初期化されていません。Initialize メソッドを呼び出してください。"
    End If
End Sub

' ======================
' IFileOperations実装
' ======================
Private Function IFileOperations_ReadTextFile(ByVal filePath As String, _
                                           Optional ByVal encoding As String) As String
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Read Text File"
    Dim content As String
    On Error GoTo ErrorHandler
    content = ReadTextFileUsingFileIO(filePath, encoding)
    IFileOperations_ReadTextFile = content
    mPerformanceMonitor.EndMeasurement "Read Text File"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileNotFound
        .Description = "ファイルの読み込みに失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileOperations_ReadTextFile"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Read Text File"
    IFileOperations_ReadTextFile = vbNullString
End Function

Private Function IFileOperations_WriteTextFile(ByVal filePath As String, _
                                            ByVal content As String, _
                                            Optional ByVal append As Boolean = False, _
                                            Optional ByVal encoding As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Write Text File"
    Dim result As Boolean
    On Error GoTo ErrorHandler
    result = WriteTextFileUsingFileIO(filePath, content, append, encoding)
    IFileOperations_WriteTextFile = result
    mPerformanceMonitor.EndMeasurement "Write Text File"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "ファイルの書き込みに失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileOperations_WriteTextFile"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Write Text File"
    IFileOperations_WriteTextFile = False
End Function

Private Function IFileOperations_ReadBinaryFile(ByVal filePath As String) As Byte()
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Read Binary File"
    On Error GoTo ErrorHandler
    IFileOperations_ReadBinaryFile = ReadBinaryFileUsingFileIO(filePath)
    mPerformanceMonitor.EndMeasurement "Read Binary File"
    Exit Function
ErrorHandler:
    mPerformanceMonitor.EndMeasurement "Read Binary File"
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileNotFound
        .Description = "バイナリファイルの読み込みに失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileOperations_ReadBinaryFile"
    End With
    Call modError.HandleError(errInfo)
    IFileOperations_ReadBinaryFile = Array()
End Function

Private Function IFileOperations_WriteBinaryFile(ByVal filePath As String, _
                                              ByRef data() As Byte) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Write Binary File"
    On Error GoTo ErrorHandler
    IFileOperations_WriteBinaryFile = WriteBinaryFileUsingFileIO(filePath, data)
    mPerformanceMonitor.EndMeasurement "Write Binary File"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "バイナリファイルの書き込みに失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileOperations_WriteBinaryFile"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Write Binary File"
    IFileOperations_WriteBinaryFile = False
End Function

Private Function IFileOperations_FileExists(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    IFileOperations_FileExists = mFileIO.FileExists(filePath)
End Function

Private Function IFileOperations_FolderExists(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    IFileOperations_FolderExists = mFileIO.FolderExists(folderPath)
End Function

Private Function IFileOperations_CreateFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Create Folder"
    On Error GoTo ErrorHandler
    IFileOperations_CreateFolder = mFileIO.CreateFolder(folderPath)
    mPerformanceMonitor.EndMeasurement "Create Folder"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "フォルダの作成に失敗しました: " & folderPath
        .Source = MODULE_NAME & ".IFileOperations_CreateFolder"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Create Folder"
    IFileOperations_CreateFolder = False
End Function

Private Function IFileOperations_DeleteFile(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Delete File"
    On Error GoTo ErrorHandler
    IFileOperations_DeleteFile = mFileIO.DeleteFile(filePath)
    mPerformanceMonitor.EndMeasurement "Delete File"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "ファイルの削除に失敗しました: " & filePath
        .Source = MODULE_NAME & ".IFileOperations_DeleteFile"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Delete File"
    IFileOperations_DeleteFile = False
End Function

Private Function IFileOperations_DeleteFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    mPerformanceMonitor.StartMeasurement "Delete Folder"
    On Error GoTo ErrorHandler
    IFileOperations_DeleteFolder = mFileIO.DeleteFolder(folderPath)
    mPerformanceMonitor.EndMeasurement "Delete Folder"
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrFileAccessDenied
        .Description = "フォルダの削除に失敗しました: " & folderPath
        .Source = MODULE_NAME & ".IFileOperations_DeleteFolder"
    End With
    Call modError.HandleError(errInfo)
    mPerformanceMonitor.EndMeasurement "Delete Folder"
    IFileOperations_DeleteFolder = False
End Function

Private Function IFileOperations_GetAbsolutePath(ByVal relativePath As String, _
                                              Optional ByVal basePath As String) As String
    InitializeIfNeeded
    ' FileIOImplでは絶対パスの解決は実装していないため、
    ' FSO（FileSystemObject）の機能を直接使用
    On Error Resume Next
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If basePath = "" Then basePath = CurDir()
    IFileOperations_GetAbsolutePath = fso.GetAbsolutePathName(fso.BuildPath(basePath, relativePath))
    Set fso = Nothing
    On Error GoTo 0
End Function

' ======================
' パブリックメソッド
' ======================
Public Function CreateInstance(ByVal lock As ILock, _
                             ByVal performanceMonitor As IPerformanceMonitor, _
                             ByVal fileIO As IFileIO) As IFileOperations
    Dim instance As New FileSystemOperations
    instance.Initialize lock, performanceMonitor, fileIO
    Set CreateInstance = instance
End Function

' ======================
' プライベートヘルパーメソッド
' ======================
Private Function ReadTextFileUsingFileIO(ByVal filePath As String, _
                                       Optional ByVal encoding As String) As String
    Dim file As Object
    Set file = mFileIO.OpenFile(filePath, "READ")
    
    If file Is Nothing Then Exit Function
    
    On Error GoTo ErrorHandler
    ReadTextFileUsingFileIO = file.ReadAll
    mFileIO.CloseFile file
    Exit Function
    
ErrorHandler:
    If Not file Is Nothing Then mFileIO.CloseFile file
    ReadTextFileUsingFileIO = vbNullString
End Function

Private Function WriteTextFileUsingFileIO(ByVal filePath As String, _
                                        ByVal content As String, _
                                        ByVal append As Boolean, _
                                        Optional ByVal encoding As String) As Boolean
    Dim file As Object
    Set file = mFileIO.OpenFile(filePath, IIf(append, "APPEND", "WRITE"))
    
    If file Is Nothing Then Exit Function
    
    On Error GoTo ErrorHandler
    file.Write content
    mFileIO.CloseFile file
    WriteTextFileUsingFileIO = True
    Exit Function
    
ErrorHandler:
    If Not file Is Nothing Then mFileIO.CloseFile file
    WriteTextFileUsingFileIO = False
End Function

Private Function ReadBinaryFileUsingFileIO(ByVal filePath As String) As Byte()
    Dim file As Object
    Set file = mFileIO.OpenFile(filePath, "READ")
    
    If file Is Nothing Then
        ReadBinaryFileUsingFileIO = Array()
        Exit Function
    End If
    
    On Error GoTo ErrorHandler
    Dim fileContent As String
    fileContent = file.ReadAll
    mFileIO.CloseFile file
    
    ' 文字列をバイト配列に変換
    Dim bytes() As Byte
    bytes = StrConv(fileContent, vbFromUnicode)
    ReadBinaryFileUsingFileIO = bytes
    Exit Function
    
ErrorHandler:
    If Not file Is Nothing Then mFileIO.CloseFile file
    ReadBinaryFileUsingFileIO = Array()
End Function

Private Function WriteBinaryFileUsingFileIO(ByVal filePath As String, _
                                          ByRef data() As Byte) As Boolean
    Dim file As Object
    Set file = mFileIO.OpenFile(filePath, "WRITE")
    
    If file Is Nothing Then Exit Function
    
    On Error GoTo ErrorHandler
    ' バイト配列を文字列に変換
    Dim content As String
    content = StrConv(data, vbUnicode)
    file.Write content
    mFileIO.CloseFile file
    WriteBinaryFileUsingFileIO = True
    Exit Function
    
ErrorHandler:
    If Not file Is Nothing Then mFileIO.CloseFile file
    WriteBinaryFileUsingFileIO = False
End Function

' ======================
' テストサポート機能（開発環境専用）
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        Class_Terminate
        Class_Initialize
    End Sub
    
    ''' <summary>
    ''' 初期化状態を取得（テスト用）
    ''' </summary>
    Private Property Get IsInitialized() As Boolean
        IsInitialized = mIsInitialized
    End Property
#End If

================
File: IniFileImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "IniFileImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IIniFile

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "IniFileImpl"

' ======================
' 定数定義
' ======================
Private Const MAX_BUFFER_SIZE As Long = 32767 ' Win32 APIの制限
Private Const DEFAULT_BUFFER_SIZE As Long = 1024

' ======================
' メンバ変数
' ======================
Private mIsInitialized As Boolean
Private mPerformanceMonitor As clsPerformanceMonitor
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mPerformanceMonitor = New clsPerformanceMonitor
    Set mLock = New clsLock
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
    mIsInitialized = False
End Sub

' ======================
' IIniFile実装
' ======================
Private Function IIniFile_GetPrivateProfileString(ByVal section As String, _
                                                ByVal key As String, _
                                                ByVal defaultValue As String, _
                                                ByVal filePath As String) As String
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "GetPrivateProfileString"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim buffer As String
    Dim result As Long
    Dim retryCount As Long
    Const MAX_RETRIES As Long = 3
    
    ' 徐々にバッファサイズを大きくしながら値の取得を試みる
    Dim bufferSize As Long
    bufferSize = DEFAULT_BUFFER_SIZE
    
    Do
        buffer = String$(bufferSize, 0)
        result = modWindowsAPI.GetPrivateProfileString(section, key, defaultValue, _
                                                     buffer, bufferSize, filePath)
        
        ' バッファが不足している場合は拡張して再試行
        If result = bufferSize - 1 Then
            bufferSize = bufferSize * 2
            If bufferSize > MAX_BUFFER_SIZE Then
                LogError "バッファサイズが最大値を超えました。"
                IIniFile_GetPrivateProfileString = defaultValue
                GoTo CleanUp
            End If
        Else
            Exit Do
        End If
        
        retryCount = retryCount + 1
    Loop While retryCount < MAX_RETRIES
    
    If result > 0 Then
        IIniFile_GetPrivateProfileString = Left$(buffer, result)
    Else
        IIniFile_GetPrivateProfileString = defaultValue
    End If
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "GetPrivateProfileString"
    Exit Function

ErrorHandler:
    LogError "INIファイルからの読み取り中にエラーが発生しました: " & Err.Description
    IIniFile_GetPrivateProfileString = defaultValue
    Resume CleanUp
End Function

Private Function IIniFile_WritePrivateProfileString(ByVal section As String, _
                                                  ByVal key As String, _
                                                  ByVal value As String, _
                                                  ByVal filePath As String) As Boolean
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "WritePrivateProfileString"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Long
    result = modWindowsAPI.WritePrivateProfileString(section, key, value, filePath)
    
    IIniFile_WritePrivateProfileString = (result <> 0)
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "WritePrivateProfileString"
    Exit Function

ErrorHandler:
    LogError "INIファイルへの書き込み中にエラーが発生しました: " & Err.Description
    IIniFile_WritePrivateProfileString = False
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = mIsInitialized And _
                       Not (mPerformanceMonitor Is Nothing) And _
                       Not (mLock Is Nothing)
    End Function
    
    Public Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
    
    Public Function TestBufferHandling(ByVal testValue As String) As String
        ' 大きな値の読み書きをテスト
        Const TEST_SECTION As String = "TestSection"
        Const TEST_KEY As String = "TestKey"
        Const TEST_FILE As String = "test.ini"
        
        ' 書き込み
        IIniFile_WritePrivateProfileString TEST_SECTION, TEST_KEY, testValue, TEST_FILE
        
        ' 読み込み
        TestBufferHandling = IIniFile_GetPrivateProfileString(TEST_SECTION, TEST_KEY, "", TEST_FILE)
    End Function
#End If

================
File: modDatabaseUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modDatabaseUtils"

' ======================
' 定数定義
' ======================
Private Const ERR_MODULE_NOT_INITIALIZED As String = "モジュールが初期化されていません。"
Private Const DEFAULT_CONNECTION_STRING As String = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=default.accdb;"

' ======================
' プライベート変数
' ======================
Private mPerformanceMonitor As clsPerformanceMonitor
Private mIsInitialized As Boolean
Private mLock As clsLock
Private mDefaultConnection As Object ' ADODB.Connection
Private mConfig As IDatabaseConfig ' データベース設定
Private mConnectionPool As ConnectionPool ' コネクションプール

' ======================
' 初期化・終了処理
' ======================
''' <summary>モジュールを初期化します</summary>
''' <param name="config">データベース設定を提供するインターフェース（必須）</param>
Public Sub InitializeModule(ByVal config As IDatabaseConfig)
    If mIsInitialized Then Exit Sub
    
    Set mPerformanceMonitor = New clsPerformanceMonitor
    If config Is Nothing Then
        Err.Raise vbObjectError + 1001, MODULE_NAME, _
            "データベース設定が指定されていません。"
    End If
    Set mConfig = config
    Set mLock = New clsLock
    Set mConnectionPool = New ConnectionPool
    
    ' コネクションプールの初期化
    With mConnectionPool
        .MinPoolSize = CLng(mConfig.GetDatabaseSetting("MinPoolSize"))
        .MaxPoolSize = CLng(mConfig.GetDatabaseSetting("MaxPoolSize"))
        .ConnectionTimeout = mConfig.ConnectionTimeout
    End With
    
    mIsInitialized = True
End Sub

Public Sub TerminateModule()
    If Not mIsInitialized Then Exit Sub
    
    CloseConnection
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
    Set mConfig = Nothing
    Set mConnectionPool = Nothing
    mIsInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' データベース接続文字列を取得します
''' </summary>
''' <returns>接続文字列</returns>
Public Function GetConnectionString() As String
    If Not mIsInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    On Error GoTo ErrorHandler

    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "GetConnectionString"
    End If
    
    mLock.AcquireLock
    
    ' IDatabaseConfigから接続文字列を取得
    GetConnectionString = mConfig.GetConnectionString
    
    mLock.ReleaseLock
    
    ' 接続文字列が空の場合、デフォルト値を使用
    If GetConnectionString = "" Then
        ' デフォルト接続文字列を使用する前に警告をログ
        LogWarning "接続文字列が設定されていません。デフォルト値を使用します。", _
                  "GetConnectionString"
        
        GetConnectionString = DEFAULT_CONNECTION_STRING
    End If
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "GetConnectionString"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDatabaseConnectionFailed
        .Description = "接続文字列の取得中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnectionString"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "GetConnectionString"
    End If
    GetConnectionString = DEFAULT_CONNECTION_STRING
End Function

''' <summary>
''' データベース接続を取得します
''' </summary>
''' <returns>データベース接続オブジェクト</returns>
Public Function GetConnection() As Object ' ADODB.Connection
    If Not mIsInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "GetConnection"
    End If
    
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' コネクションプールから接続を取得
    Set GetConnection = mConnectionPool.GetConnection(GetConnectionString())
    
    GoTo CleanupAndExit

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDatabaseConnectionFailed
        .Description = "データベース接続の取得中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "GetConnection"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Set GetConnection = Nothing

CleanupAndExit:
    mLock.ReleaseLock
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "GetConnection"
    End If
End Function

''' <summary>
''' データベース接続を閉じます
''' </summary>
Public Sub CloseConnection()
    If Not mConnectionPool Is Nothing Then
        mLock.AcquireLock
        
        On Error Resume Next
        mConnectionPool.ReleaseAllConnections
        
        mLock.ReleaseLock
        On Error GoTo 0
    End If
End Sub

''' <summary>
''' データベース接続をテストします
''' </summary>
''' <returns>接続成功の場合True</returns>
Public Function TestConnection() As Boolean
    If Not mIsInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    Dim conn As Object
    Set conn = GetConnection()
    
    TestConnection = Not (conn Is Nothing)
    
    If Not conn Is Nothing Then
        If conn.State = 1 Then ' adStateOpen
            TestConnection = True
            mConnectionPool.ReleaseConnection conn
        End If
    End If
End Function

''' <summary>
''' SQLクエリを実行し、結果を取得します
''' </summary>
''' <param name="sql">SQLクエリ</param>
''' <param name="params">パラメータ配列（オプション）</param>
''' <returns>レコードセット</returns>
Public Function ExecuteQuery(ByVal sql As String, _
                           Optional ByRef params As Variant) As Object ' ADODB.Recordset
    If Not mIsInitialized Then Err.Raise vbObjectError + 1002, MODULE_NAME, ERR_MODULE_NOT_INITIALIZED
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "ExecuteQuery"
    End If
    
    On Error GoTo ErrorHandler
    
    Dim conn As Object
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Function
    
    Dim cmd As Object
    Set cmd = CreateObject("ADODB.Command")
    With cmd
        Set .ActiveConnection = conn
        .CommandText = sql
        .CommandType = 1 ' adCmdText
        .CommandTimeout = mConfig.CommandTimeout
        
        ' パラメータの設定
        If Not IsMissing(params) Then
            ' 単一値のパラメータを配列に変換
            Dim paramArray As Variant
            If IsArray(params) Then
                paramArray = params
            Else
                ReDim paramArray(0)
                paramArray(0) = params
            End If
            
            ' パラメータのバリデーション
            ValidateParameters paramArray
            
            ' パラメータの追加
            Dim i As Long
            For i = LBound(paramArray) To UBound(paramArray)
                Dim paramValue As Variant
                paramValue = paramArray(i)
                If Not IsNull(paramValue) Then
                    .Parameters.Append .CreateParameter("p" & i, GetParameterType(paramValue), 1, , paramValue)
                End If
            Next i
        End If
        
        Set ExecuteQuery = .Execute
    End With
    
    ' 接続をプールに返却
    mConnectionPool.ReleaseConnection conn
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ExecuteQuery"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDatabaseQueryFailed
        .Description = "クエリの実行中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "ExecuteQuery"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ExecuteQuery"
    End If
    Set ExecuteQuery = Nothing
End Function

' ======================
' プライベート関数
' ======================
Private Function GetParameterType(ByVal Value As Variant) As Integer
    Select Case VarType(Value)
        Case vbInteger, vbLong
            GetParameterType = 3 ' adInteger
        Case vbSingle, vbDouble
            GetParameterType = 5 ' adDouble
        Case vbString
            GetParameterType = 200 ' adVarChar
        Case vbDate
            GetParameterType = 7 ' adDate
        Case vbBoolean
            GetParameterType = 11 ' adBoolean
        Case Else
            GetParameterType = 12 ' adVariant
    End Select
End Function

Private Sub ValidateParameters(ByRef params As Variant)
    If Not IsArray(params) Then Exit Sub
    
    Dim i As Long
    For i = LBound(params) To UBound(params)
        If Not IsNull(params(i)) Then
            Select Case VarType(params(i))
                Case vbInteger, vbLong, vbSingle, vbDouble, vbString, vbDate, vbBoolean
                    ' サポートされている型
                Case Else
                    Err.Raise vbObjectError + 1003, MODULE_NAME, _
                        "サポートされていないパラメータ型です: " & TypeName(params(i))
            End Select
        End If
    Next i
End Sub

Private Sub LogWarning(ByVal message As String, ByVal procedureName As String)
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrDatabaseWarning
        .Description = message
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = procedureName
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule mConfig
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
    
    ''' <summary>
    ''' コネクションプールの参照を取得（テスト用）
    ''' </summary>
    Private Function GetConnectionPool() As ConnectionPool
        Set GetConnectionPool = mConnectionPool
    End Function
#End If

================
File: modFileIO.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modFileIO"

' ======================
' 定数定義
' ======================
Private Const MAX_BUFFER_SIZE As Long = 1024
Private Const DEFAULT_ENCODING As String = "UTF-8"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Private Sub InitializeIfNeeded()
    If Not isInitialized Then InitializeModule
End Sub

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開メソッド
' ======================

''' <summary>
''' テキストファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>ファイルの内容、エラー時は空文字列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルの存在確認
''' - エンコーディングの検証
''' - ファイルロックの確認
''' - メモリ不足への対応
''' </remarks>
Public Function ReadTextFile(ByVal filePath As String, _
                           Optional ByVal encoding As String = DEFAULT_ENCODING) As String
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Read Text File"
    On Error GoTo ErrorHandler
    
    If Not FileExists(filePath) Then
        RaiseFileError modErrorCodes.ErrFileNotFound, "ファイルが見つかりません: " & filePath
    End If
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Input As #fileNum Encoding encoding
        ReadTextFile = Input$(LOF(fileNum), fileNum)
    Close #fileNum
    
CleanUp:
    performanceMonitor.EndMeasurement "Read Text File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "ReadTextFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    ReadTextFile = ""  ' エラー時は空文字列を返す（IFileOperationsの規定に従う）
    Resume CleanUp
End Function

''' <summary>
''' テキストファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="content">書き込む内容</param>
''' <param name="append">追記モード（オプション）</param>
''' <param name="encoding">文字エンコーディング（オプション）</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - 書き込み権限の確認
''' - ディスク容量の確認
''' - 既存ファイルのバックアップ
''' - 書き込み失敗時の復旧処理
''' </remarks>
Public Function WriteTextFile(ByVal filePath As String, _
                            ByVal content As String, _
                            Optional ByVal append As Boolean = False, _
                            Optional ByVal encoding As String = DEFAULT_ENCODING) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Write Text File"
    On Error GoTo ErrorHandler
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    If append Then
        Open filePath For Append As #fileNum Encoding encoding
    Else
        Open filePath For Output As #fileNum Encoding encoding
    End If
    
    Print #fileNum, content
    Close #fileNum
    
    WriteTextFile = True
    
CleanUp:
    performanceMonitor.EndMeasurement "Write Text File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "WriteTextFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    WriteTextFile = False
    Resume CleanUp
End Function

''' <summary>
''' バイナリファイルを読み込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <returns>ファイルのバイトデータ、エラー時は空配列</returns>
''' <remarks>
''' エラー処理要件：
''' - ファイルサイズの検証
''' - メモリ使用量の監視
''' - 破損ファイルの検出
''' - エラー発生時は空配列を返す
''' </remarks>
Public Function ReadBinaryFile(ByVal filePath As String) As Byte()
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Read Binary File"
    On Error GoTo ErrorHandler
    
    If Not FileExists(filePath) Then
        RaiseFileError modErrorCodes.ErrFileNotFound, "ファイルが見つかりません: " & filePath
    End If
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Binary Access Read As #fileNum
        Dim fileData() As Byte
        ReDim fileData(LOF(fileNum) - 1)
        Get #fileNum, , fileData
    Close #fileNum
    
    ReadBinaryFile = fileData
    
CleanUp:
    performanceMonitor.EndMeasurement "Read Binary File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "ReadBinaryFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    ReadBinaryFile = Array()  ' エラー時は空配列を返す
    Resume CleanUp
End Function

''' <summary>
''' バイナリファイルに書き込みます
''' </summary>
''' <param name="filePath">ファイルパス</param>
''' <param name="data">書き込むバイトデータ</param>
''' <returns>成功時True、失敗時False</returns>
''' <remarks>
''' エラー処理要件：
''' - データの整合性チェック
''' - 部分書き込みの防止
''' - 書き込み失敗時のロールバック
''' - エラー発生時はFalseを返す
''' </remarks>
Public Function WriteBinaryFile(ByVal filePath As String, _
                              ByRef data() As Byte) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Write Binary File"
    On Error GoTo ErrorHandler
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Binary Access Write As #fileNum
        Put #fileNum, , data
    Close #fileNum
    
    WriteBinaryFile = True
    
CleanUp:
    performanceMonitor.EndMeasurement "Write Binary File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "WriteBinaryFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    WriteBinaryFile = False
    Resume CleanUp
End Function

Public Function FileExists(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "FileExists"
    On Error GoTo ErrorHandler
    
    FileExists = (Dir(filePath) <> "")
    
CleanUp:
    performanceMonitor.EndMeasurement "FileExists"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "ファイルの存在確認中にエラーが発生しました: " & filePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "FileExists"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    FileExists = False
    Resume CleanUp
End Function
 
Public Function FolderExists(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "FolderExists"
    On Error GoTo ErrorHandler
    
    FolderExists = (Dir(folderPath, vbDirectory) <> "")
    
CleanUp:
    performanceMonitor.EndMeasurement "FolderExists"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの存在確認中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "FolderExists"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    FolderExists = False
    Resume CleanUp
End Function
 
Public Function CreateFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Create Folder"
    On Error GoTo ErrorHandler
    
    MkDir folderPath
    CreateFolder = True
    
CleanUp:
    performanceMonitor.EndMeasurement "Create Folder"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの作成中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "CreateFolder"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    CreateFolder = False
    Resume CleanUp
End Function
 
Public Function DeleteFile(ByVal filePath As String) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Delete File"
    On Error GoTo ErrorHandler
    
    Kill filePath
    DeleteFile = True
    
CleanUp:
    performanceMonitor.EndMeasurement "Delete File"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "ファイルの削除中にエラーが発生しました: " & filePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "DeleteFile"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    DeleteFile = False
    Resume CleanUp
End Function
 
Public Function DeleteFolder(ByVal folderPath As String) As Boolean
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "Delete Folder"
    On Error GoTo ErrorHandler
    
    RmDir folderPath
    DeleteFolder = True
    
CleanUp:
    performanceMonitor.EndMeasurement "Delete Folder"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "フォルダの削除中にエラーが発生しました: " & folderPath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "DeleteFolder"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    DeleteFolder = False
    Resume CleanUp
End Function

Public Function GetAbsolutePath(ByVal relativePath As String, _
                              Optional ByVal basePath As String) As String
    InitializeIfNeeded
    
    performanceMonitor.StartMeasurement "GetAbsolutePath"
    On Error GoTo ErrorHandler
    
    If Len(basePath) = 0 Then basePath = CurDir
    GetAbsolutePath = CreateObject("Scripting.FileSystemObject").GetAbsolutePathName(basePath & "\" & relativePath)
    
CleanUp:
    performanceMonitor.EndMeasurement "GetAbsolutePath"
    Exit Function
    
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = GetFileErrorCode(Err.Number)
        .Category = modErrorCodes.ECFileIO
        .Description = "絶対パスの取得中にエラーが発生しました: " & relativePath & vbCrLf & Err.Description
        .Source = MODULE_NAME
        .ProcedureName = "GetAbsolutePath"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    modError.HandleError errInfo
    GetAbsolutePath = ""
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Function GetFileErrorCode(ByVal errNumber As Long) As ErrorCode
    Select Case errNumber
        Case 53 ' File not found
            GetFileErrorCode = modErrorCodes.ErrFileNotFound
        Case 70 ' Permission denied
            GetFileErrorCode = modErrorCodes.ErrFileAccessDenied
        Case 75, 76 ' Path/File access error
            GetFileErrorCode = modErrorCodes.ErrFileAccessDenied
        Case Else
            GetFileErrorCode = modErrorCodes.ErrUnexpected
    End Select
End Function

Private Sub RaiseFileError(ByVal errorCode As ErrorCode, ByVal description As String)
    Err.Raise errorCode, MODULE_NAME, description
End Sub

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: ODBCConnectionStringBuilder.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ODBCConnectionStringBuilder"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IConnectionStringBuilder

' ======================
' メンバ変数
' ======================
Private mServer As String
Private mDatabase As String
Private mUserName As String
Private mPassword As String
Private mAdditionalParameters As String

' ======================
' IConnectionStringBuilder実装
' ======================
Private Function IConnectionStringBuilder_BuildConnectionString() As String
    Dim connectionString As String
    
    connectionString = "Driver={SQL Server};"
    
    ' サーバー名
    If Len(mServer) > 0 Then
        connectionString = connectionString & "Server=" & mServer & ";"
    End If
    
    ' データベース名
    If Len(mDatabase) > 0 Then
        connectionString = connectionString & "Database=" & mDatabase & ";"
    End If
    
    ' ユーザー名
    If Len(mUserName) > 0 Then
        connectionString = connectionString & "Uid=" & mUserName & ";"
    End If
    
    ' パスワード
    If Len(mPassword) > 0 Then
        connectionString = connectionString & "Pwd=" & mPassword & ";"
    End If
    
    ' 追加のパラメータ
    If Len(mAdditionalParameters) > 0 Then
        connectionString = connectionString & mAdditionalParameters
    End If
    
    IConnectionStringBuilder_BuildConnectionString = connectionString
End Function

Private Property Get IConnectionStringBuilder_Server() As String
    IConnectionStringBuilder_Server = mServer
End Property

Private Property Let IConnectionStringBuilder_Server(ByVal value As String)
    mServer = value
End Property

Private Property Get IConnectionStringBuilder_Database() As String
    IConnectionStringBuilder_Database = mDatabase
End Property

Private Property Let IConnectionStringBuilder_Database(ByVal value As String)
    mDatabase = value
End Property

Private Property Get IConnectionStringBuilder_UserName() As String
    IConnectionStringBuilder_UserName = mUserName
End Property

Private Property Let IConnectionStringBuilder_UserName(ByVal value As String)
    mUserName = value
End Property

Private Property Get IConnectionStringBuilder_Password() As String
    IConnectionStringBuilder_Password = mPassword
End Property

Private Property Let IConnectionStringBuilder_Password(ByVal value As String)
    mPassword = value
End Property

Private Property Get IConnectionStringBuilder_AdditionalParameters() As String
    IConnectionStringBuilder_AdditionalParameters = mAdditionalParameters
End Property

Private Property Let IConnectionStringBuilder_AdditionalParameters(ByVal value As String)
    mAdditionalParameters = value
End Property

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mServer = ""
    mDatabase = ""
    mUserName = ""
    mPassword = ""
    mAdditionalParameters = ""
End Sub

================
File: OLEDBConnectionStringBuilder.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "OLEDBConnectionStringBuilder"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IConnectionStringBuilder

' ======================
' メンバ変数
' ======================
Private mServer As String
Private mDatabase As String
Private mUserName As String
Private mPassword As String
Private mAdditionalParameters As String

' ======================
' IConnectionStringBuilder実装
' ======================
Private Function IConnectionStringBuilder_BuildConnectionString() As String
    Dim connectionString As String
    
    connectionString = "Provider=SQLOLEDB;"
    
    ' サーバー名
    If Len(mServer) > 0 Then
        connectionString = connectionString & "Data Source=" & mServer & ";"
    End If
    
    ' データベース名
    If Len(mDatabase) > 0 Then
        connectionString = connectionString & "Initial Catalog=" & mDatabase & ";"
    End If
    
    ' ユーザー名とパスワード
    If Len(mUserName) > 0 Then
        connectionString = connectionString & "User ID=" & mUserName & ";"
        If Len(mPassword) > 0 Then
            connectionString = connectionString & "Password=" & mPassword & ";"
        End If
    Else
        ' 統合認証を使用
        connectionString = connectionString & "Integrated Security=SSPI;"
    End If
    
    ' 追加のパラメータ
    If Len(mAdditionalParameters) > 0 Then
        connectionString = connectionString & mAdditionalParameters
    End If
    
    IConnectionStringBuilder_BuildConnectionString = connectionString
End Function

Private Property Get IConnectionStringBuilder_Server() As String
    IConnectionStringBuilder_Server = mServer
End Property

Private Property Let IConnectionStringBuilder_Server(ByVal value As String)
    mServer = value
End Property

Private Property Get IConnectionStringBuilder_Database() As String
    IConnectionStringBuilder_Database = mDatabase
End Property

Private Property Let IConnectionStringBuilder_Database(ByVal value As String)
    mDatabase = value
End Property

Private Property Get IConnectionStringBuilder_UserName() As String
    IConnectionStringBuilder_UserName = mUserName
End Property

Private Property Let IConnectionStringBuilder_UserName(ByVal value As String)
    mUserName = value
End Property

Private Property Get IConnectionStringBuilder_Password() As String
    IConnectionStringBuilder_Password = mPassword
End Property

Private Property Let IConnectionStringBuilder_Password(ByVal value As String)
    mPassword = value
End Property

Private Property Get IConnectionStringBuilder_AdditionalParameters() As String
    IConnectionStringBuilder_AdditionalParameters = mAdditionalParameters
End Property

Private Property Let IConnectionStringBuilder_AdditionalParameters(ByVal value As String)
    mAdditionalParameters = value
End Property

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mServer = ""
    mDatabase = ""
    mUserName = ""
    mPassword = ""
    mAdditionalParameters = ""
End Sub
