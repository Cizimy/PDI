This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-27T00:45:08.829Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
clsLogger.cls
clsPerformanceMonitor.cls
ConfigImpl.cls
ConsoleLogger.cls
DatabaseLogger.cls
DefaultLoggerSettings.cls
DefaultMessageFormatter.cls
EmergencyLogger.cls
ErrorHandlerManager.cls
ErrorImpl.cls
ErrorInfo.cls
EventLogImpl.cls
EventLogLogger.cls
FileLogger.cls
InvalidInputErrorHandler.cls
modAppInitializer.bas
modConfig.bas
modError.bas
modErrorCodes.bas
PerformanceCounterImpl.cls
PerformanceMonitorImpl.cls

================================================================
Files
================================================================

================
File: clsLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsLogger"

' ======================
' メンバ変数
' ======================
Private mSettings As ILoggerSettings
Private mLogQueue As IQueue
Private mLock As ILock
Private mTimerID As LongPtr
Private mLoggers As Object ' Dictionary of ILogger instances
Private mIsProcessing As Boolean
Private mWorkerThread As Object
Private mPerformanceMonitor As clsPerformanceMonitor
Private mIsInitialized As Boolean
Private Const MAX_RETRY_COUNT As Long = 3
Private Const RETRY_DELAY_MS As Long = 1000
Private Const EMERGENCY_LOG_PATH As String = "\PDI_emergency.log"

' ======================
' イベント
' ======================
Public Event Logged(ByVal logMessage As String, ByVal logLevel As LogLevel)

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLoggers = CreateObject("Scripting.Dictionary")
    Set mLogQueue = New QueueImpl ' QueueImplはIQueueを実装
    Set mPerformanceMonitor = New clsPerformanceMonitor
End Sub

Private Sub Class_Terminate()
    If mTimerID <> 0 Then
        KillTimer 0, mTimerID
        mTimerID = 0
    End If
    
    If Not mWorkerThread Is Nothing Then
        ' ワーカースレッドの終了を待機
        mIsProcessing = False
        While mWorkerThread.Status = 1 ' 実行中
            Sleep 100
        Wend
    End If
    
    Set mLogQueue = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    Set mLoggers = Nothing
    Set mSettings = Nothing
    
    mIsInitialized = False
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Configure(ByVal settings As ILoggerSettings, _
                    ByVal queue As IQueue, _
                    ByVal lock As ILock, _
                    ByVal performanceMonitor As IPerformanceMonitor)
    Set mSettings = settings
    Set mLogQueue = queue
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    
    ' ログ出力先の設定
    InitializeLoggers
    
    ' ワーカースレッドの開始
    StartWorkerThread
    
    mIsInitialized = True
End Sub

Public Sub SetLogger(ByVal destination As String, ByVal logger As ILogger)
    If mLoggers.Exists(destination) Then
        mLoggers.Remove destination
    End If
    mLoggers.Add destination, logger
End Sub

Private Sub InitializeLoggers()
    ' 既存のロガーをクリア
    mLoggers.RemoveAll
    
    ' 設定に基づいてロガーを初期化
    Dim destinations As Variant
    destinations = mSettings.GetLogDestinations()
    
    Dim i As Long
    For i = LBound(destinations) To UBound(destinations)
        SetLogger destinations(i), CreateLogger(destinations(i))
    Next i
    
    ' タイマーの設定
    If mTimerID <> 0 Then
        KillTimer 0, mTimerID
    End If
    mTimerID = SetTimer(0, 0, mSettings.TimerInterval, AddressOf TimerProc)
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal moduleName As String, ByVal message As String, Optional ByVal errorCode As ErrorCode)
    If Not mIsInitialized Then Exit Sub
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "Logger_Log"
    End If
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' ログレベルチェック
    If errorCode >= mSettings.LogLevel Then
        ' ログメッセージをキューに追加
        Dim logEntry As Variant
        logEntry = Array(moduleName, message, errorCode, Now)
        mLogQueue.Enqueue logEntry
    End If
    
Cleanup:
    mLock.ReleaseLock
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "Logger_Log"
    End If
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

Private Property Let ILogger_LogLevel(ByVal level As LogLevel)
    If Not mSettings Is Nothing Then
        mSettings.LogLevel = level
    End If
End Property

Private Property Get ILogger_LogLevel() As LogLevel
    If Not mSettings Is Nothing Then
        ILogger_LogLevel = mSettings.LogLevel
    End If
End Property

Private Property Let ILogger_LogDestination(ByVal destination As LogDestination)
    If Not mSettings Is Nothing Then
        mSettings.LogDestination = destination
    End If
End Property

Private Property Get ILogger_LogDestination() As LogDestination
    If Not mSettings Is Nothing Then
        ILogger_LogDestination = mSettings.LogDestination
    End If
End Property

' ======================
' プライベートメソッド
' ======================
Private Sub ProcessLogQueue()
    If Not mIsInitialized Then Exit Sub
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    While mLogQueue.Count > 0
        Dim logEntry As Variant
        logEntry = mLogQueue.Dequeue
        
        ' 各ロガーでログを処理
        Dim destination As Variant
        For Each destination In mLoggers.Keys
            If mSettings.ShouldLog(destination, logEntry(2)) Then
                Dim logger As ILogger
                Set logger = mLoggers(destination)
                logger.Log CStr(logEntry(2)), CStr(logEntry(1)), CStr(logEntry(3)), CLng(logEntry(0))
            End If
        Next destination
        
        ' イベント発行
        RaiseEvent Logged(logEntry(1), logEntry(2))
    Wend
    
Cleanup:
    mLock.ReleaseLock
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ログキュー処理中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ProcessLogQueue"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

Private Function CreateLogger(ByVal destination As String) As ILogger
    Select Case destination
        Case "File"
            Dim fileLogger As New FileLogger
            fileLogger.Initialize mSettings.GetFileOperations(), _
                                mLock, _
                                mPerformanceMonitor, _
                                mSettings.LogFilePath
            Set CreateLogger = fileLogger
            
        Case "Database"
            Dim dbLogger As New DatabaseLogger
            dbLogger.Initialize mSettings.GetConnectionPool(), _
                              mLock, _
                              mPerformanceMonitor, _
                              mSettings.GetDatabaseConfig(), _
                              mSettings.LogTableName
            Set CreateLogger = dbLogger
            
        Case "EventLog"
            Dim eventLogger As New EventLogLogger
            eventLogger.Initialize mSettings.GetEventLog(), _
                                 mLock, _
                                 mPerformanceMonitor, _
                                 mSettings.LogEventSource
            Set CreateLogger = eventLogger
            
        Case "Console"
            Dim consoleLogger As New ConsoleLogger
            consoleLogger.Initialize mPerformanceMonitor, True
            Set CreateLogger = consoleLogger
            
        Case Else
            Err.Raise vbObjectError + 1, "CreateLogger", "不明なログ出力先: " & destination
    End Select
End Function

' ワーカースレッドの作成と開始
Private Sub StartWorkerThread()
    Set mWorkerThread = CreateObject("WScript.Shell").Exec( _
        "cmd /c powershell -Command {" & _
        "    while ($true) {" & _
        "        if (-not $global:isProcessing) { break }" & _
        "        Start-Sleep -Milliseconds " & mSettings.TimerInterval & _
        "    }" & _
        "}")
    mIsProcessing = True
End Sub

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' ログキューのエントリ数を取得（テスト用）
    ''' </summary>
    Private Function GetQueueCount() As Long
        GetQueueCount = mLogQueue.Count
    End Function
    
    ''' <summary>
    ''' ログキューをクリア（テスト用）
    ''' </summary>
    Private Sub ClearQueue()
        Set mLogQueue = New Queue
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
    
    ''' <summary>
    ''' タイマー処理をシミュレート（テスト用）
    ''' </summary>
    Private Sub SimulateTimer()
        ProcessLogQueue
    End Sub
#End If

================
File: clsPerformanceMonitor.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsPerformanceMonitor"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

'@Description("パフォーマンス監視機能を提供するレガシークラス（新規実装はIPerformanceMonitorを使用してください）")

' ======================
' メンバ変数
' ======================
Private mImpl As IPerformanceMonitor

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mImpl = New PerformanceMonitorImpl
End Sub

Private Sub Class_Terminate()
    Set mImpl = Nothing
End Sub

' ======================
' パブリックメソッド
' （レガシーサポート）
' ======================
Public Sub StartMeasurement(ByVal description As String)
    mImpl.Start description
End Sub

Public Sub EndMeasurement(ByVal description As String)
    mImpl.Stop description
End Sub

Public Function GetMeasurement(ByVal description As String) As String
    GetMeasurement = PerformanceMonitorImpl(mImpl).GetDetailedMeasurement(description)
End Function

Public Function GetAllMeasurements() As String
    Dim measurements As Variant
    measurements = mImpl.GetAllMeasurements()
    
    Dim result As String
    result = "Performance Monitoring Report" & vbCrLf & _
            "=========================" & vbCrLf
    
    Dim i As Long
    For i = LBound(measurements) To UBound(measurements)
        result = result & vbCrLf & "Measurement " & (i + 1) & ": " & measurements(i) & " ms"
    Next i
    
    GetAllMeasurements = result
End Function

Public Sub ClearMeasurements()
    mImpl.Clear
End Sub

' ======================
' プロパティ
' ======================
Public Property Get IsEnabled() As Boolean
    IsEnabled = mImpl.IsEnabled
End Property

Public Property Let IsEnabled(ByVal Value As Boolean)
    If Value Then
        mImpl.Enable
    Else
        mImpl.Disable
    End If
End Property

Public Property Get CurrentOperation() As String
    CurrentOperation = PerformanceMonitorImpl(mImpl).CurrentOperation
End Property

================
File: ConfigImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ConfigImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IAppConfig
Implements IDatabaseConfig

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "ConfigImpl"

' ======================
' メンバ変数
' ======================
Private mIniFile As IIniFile
Private mSettings As Collection
Private mLock As clsLock
Private mConnectionStringBuilder As IConnectionStringBuilder

' データベース設定
Private mConnectionString As String
Private mConnectionTimeout As Long
Private mCommandTimeout As Long
Private mDatabaseType As String
Private mLogTableName As String

' アプリケーション設定
Private mLogFilePath As String
Private mLogLevel As String
Private mMaxRetryCount As Long
Private mMaxStackDepth As Long
Private mTimerInterval As Long
Private mLogEventSource As String
Private mPerformanceMonitoringEnabled As Boolean
Private mDiagnosticsEnabled As Boolean
Private mAutoSave As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mSettings = New Collection
    Set mLock = New clsLock
    Set mIniFile = New IniFileImpl
    
    ' デフォルト値の設定
    mConnectionTimeout = 30
    mCommandTimeout = 30
    mDatabaseType = "ODBC"
    mLogTableName = "AppLog"
    mMaxRetryCount = 3
    mMaxStackDepth = 10
    mTimerInterval = 1000
    mPerformanceMonitoringEnabled = True
    mDiagnosticsEnabled = True
    mAutoSave = True
    
    ' データベースタイプに応じたConnectionStringBuilderの設定
    UpdateConnectionStringBuilder
End Sub

Private Sub Class_Terminate()
    Set mSettings = Nothing
    Set mLock = Nothing
    Set mIniFile = Nothing
    Set mConnectionStringBuilder = Nothing
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub UpdateConnectionStringBuilder()
    Select Case UCase$(mDatabaseType)
        Case "ODBC"
            Set mConnectionStringBuilder = New ODBCConnectionStringBuilder
        Case "OLEDB"
            Set mConnectionStringBuilder = New OLEDBConnectionStringBuilder
        Case Else
            ' デフォルトはODBCを使用
            Set mConnectionStringBuilder = New ODBCConnectionStringBuilder
    End Select
End Sub

' ======================
' IAppConfig実装
' ======================
Private Function IAppConfig_GetSetting(ByVal settingName As String) As Variant
    mLock.AcquireLock
    On Error Resume Next
    
    IAppConfig_GetSetting = mSettings(settingName)
    
    If Err.Number <> 0 Then
        ' 設定が見つからない場合はNullを返す
        IAppConfig_GetSetting = Null
    End If
    
    mLock.ReleaseLock
End Function

Private Sub IAppConfig_SetSetting(ByVal settingName As String, ByVal settingValue As Variant)
    mLock.AcquireLock
    On Error Resume Next
    
    mSettings.Remove settingName
    mSettings.Add settingValue, settingName
    
    If mAutoSave Then
        IAppConfig_SaveSettings App.Path & "\config.ini"
    End If
    
    mLock.ReleaseLock
End Sub

Private Sub IAppConfig_LoadSettings(ByVal filePath As String)
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' INIファイルから設定を読み込む
    mLogFilePath = mIniFile.GetPrivateProfileString("Logging", "LogFilePath", App.Path & "\app.log", filePath)
    mLogLevel = mIniFile.GetPrivateProfileString("Logging", "LogLevel", "INFO", filePath)
    mMaxRetryCount = CLng(mIniFile.GetPrivateProfileString("System", "MaxRetryCount", "3", filePath))
    mMaxStackDepth = CLng(mIniFile.GetPrivateProfileString("System", "MaxStackDepth", "10", filePath))
    mTimerInterval = CLng(mIniFile.GetPrivateProfileString("System", "TimerInterval", "1000", filePath))
    mLogEventSource = mIniFile.GetPrivateProfileString("Logging", "EventSource", "MyApp", filePath)
    mPerformanceMonitoringEnabled = CBool(mIniFile.GetPrivateProfileString("System", "PerformanceMonitoring", "True", filePath))
    mDiagnosticsEnabled = CBool(mIniFile.GetPrivateProfileString("System", "Diagnostics", "True", filePath))
    mAutoSave = CBool(mIniFile.GetPrivateProfileString("System", "AutoSave", "True", filePath))
    
    ' データベース設定の読み込み
    mDatabaseType = mIniFile.GetPrivateProfileString("Database", "Type", "ODBC", filePath)
    mConnectionTimeout = CLng(mIniFile.GetPrivateProfileString("Database", "ConnectionTimeout", "30", filePath))
    mCommandTimeout = CLng(mIniFile.GetPrivateProfileString("Database", "CommandTimeout", "30", filePath))
    mLogTableName = mIniFile.GetPrivateProfileString("Database", "LogTable", "AppLog", filePath)
    
    ' ConnectionStringBuilderの更新
    UpdateConnectionStringBuilder
    
    ' ConnectionStringBuilderのプロパティを設定
    With mConnectionStringBuilder
        .Server = mIniFile.GetPrivateProfileString("Database", "Server", "", filePath)
        .Database = mIniFile.GetPrivateProfileString("Database", "Database", "", filePath)
        .UserName = mIniFile.GetPrivateProfileString("Database", "UserName", "", filePath)
        .Password = mIniFile.GetPrivateProfileString("Database", "Password", "", filePath)
        .AdditionalParameters = mIniFile.GetPrivateProfileString("Database", "AdditionalParameters", "", filePath)
    End With
    
    ' 接続文字列の生成
    mConnectionString = mConnectionStringBuilder.BuildConnectionString()
    
    mLock.ReleaseLock
    Exit Sub
    
ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "設定の読み込み中にエラーが発生しました: " & Err.Description
End Sub

Private Sub IAppConfig_SaveSettings(ByVal filePath As String)
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' INIファイルに設定を保存
    mIniFile.WritePrivateProfileString "Logging", "LogFilePath", mLogFilePath, filePath
    mIniFile.WritePrivateProfileString "Logging", "LogLevel", mLogLevel, filePath
    mIniFile.WritePrivateProfileString "System", "MaxRetryCount", CStr(mMaxRetryCount), filePath
    mIniFile.WritePrivateProfileString "System", "MaxStackDepth", CStr(mMaxStackDepth), filePath
    mIniFile.WritePrivateProfileString "System", "TimerInterval", CStr(mTimerInterval), filePath
    mIniFile.WritePrivateProfileString "Logging", "EventSource", mLogEventSource, filePath
    mIniFile.WritePrivateProfileString "System", "PerformanceMonitoring", CStr(mPerformanceMonitoringEnabled), filePath
    mIniFile.WritePrivateProfileString "System", "Diagnostics", CStr(mDiagnosticsEnabled), filePath
    mIniFile.WritePrivateProfileString "System", "AutoSave", CStr(mAutoSave), filePath
    
    ' データベース設定の保存
    mIniFile.WritePrivateProfileString "Database", "Type", mDatabaseType, filePath
    mIniFile.WritePrivateProfileString "Database", "ConnectionTimeout", CStr(mConnectionTimeout), filePath
    mIniFile.WritePrivateProfileString "Database", "CommandTimeout", CStr(mCommandTimeout), filePath
    mIniFile.WritePrivateProfileString "Database", "LogTable", mLogTableName, filePath
    
    ' ConnectionStringBuilder設定の保存
    With mConnectionStringBuilder
        mIniFile.WritePrivateProfileString "Database", "Server", .Server, filePath
        mIniFile.WritePrivateProfileString "Database", "Database", .Database, filePath
        mIniFile.WritePrivateProfileString "Database", "UserName", .UserName, filePath
        mIniFile.WritePrivateProfileString "Database", "Password", .Password, filePath
        mIniFile.WritePrivateProfileString "Database", "AdditionalParameters", .AdditionalParameters, filePath
    End With
    
    mLock.ReleaseLock
    Exit Sub
    
ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "設定の保存中にエラーが発生しました: " & Err.Description
End Sub

' ======================
' IDatabaseConfig実装
' ======================
Private Function IDatabaseConfig_GetConnectionString() As String
    IDatabaseConfig_GetConnectionString = mConnectionString
End Function

Private Function IDatabaseConfig_GetDatabaseSetting(ByVal settingName As String) As Variant
    mLock.AcquireLock
    On Error Resume Next
    
    Select Case UCase$(settingName)
        Case "CONNECTIONTIMEOUT"
            IDatabaseConfig_GetDatabaseSetting = mConnectionTimeout
        Case "COMMANDTIMEOUT"
            IDatabaseConfig_GetDatabaseSetting = mCommandTimeout
        Case "DATABASETYPE"
            IDatabaseConfig_GetDatabaseSetting = mDatabaseType
        Case "LOGTABLENAME"
            IDatabaseConfig_GetDatabaseSetting = mLogTableName
        Case Else
            ' 設定が見つからない場合はNullを返す
            IDatabaseConfig_GetDatabaseSetting = Null
    End Select
    
    mLock.ReleaseLock
End Function

' ======================
' IAppConfigプロパティ実装
' ======================
Private Property Get IAppConfig_LogFilePath() As String
    IAppConfig_LogFilePath = mLogFilePath
End Property

Private Property Let IAppConfig_LogFilePath(ByVal value As String)
    mLogFilePath = value
End Property

Private Property Get IAppConfig_LogLevel() As String
    IAppConfig_LogLevel = mLogLevel
End Property

Private Property Let IAppConfig_LogLevel(ByVal value As String)
    mLogLevel = value
End Property

Private Property Get IAppConfig_MaxRetryCount() As Long
    IAppConfig_MaxRetryCount = mMaxRetryCount
End Property

Private Property Let IAppConfig_MaxRetryCount(ByVal value As Long)
    mMaxRetryCount = value
End Property

Private Property Get IAppConfig_MaxStackDepth() As Long
    IAppConfig_MaxStackDepth = mMaxStackDepth
End Property

Private Property Let IAppConfig_MaxStackDepth(ByVal value As Long)
    mMaxStackDepth = value
End Property

Private Property Get IAppConfig_TimerInterval() As Long
    IAppConfig_TimerInterval = mTimerInterval
End Property

Private Property Let IAppConfig_TimerInterval(ByVal value As Long)
    mTimerInterval = value
End Property

Private Property Get IAppConfig_LogEventSource() As String
    IAppConfig_LogEventSource = mLogEventSource
End Property

Private Property Let IAppConfig_LogEventSource(ByVal value As String)
    mLogEventSource = value
End Property

Private Property Get IAppConfig_PerformanceMonitoringEnabled() As Boolean
    IAppConfig_PerformanceMonitoringEnabled = mPerformanceMonitoringEnabled
End Property

Private Property Let IAppConfig_PerformanceMonitoringEnabled(ByVal value As Boolean)
    mPerformanceMonitoringEnabled = value
End Property

Private Property Get IAppConfig_DiagnosticsEnabled() As Boolean
    IAppConfig_DiagnosticsEnabled = mDiagnosticsEnabled
End Property

Private Property Let IAppConfig_DiagnosticsEnabled(ByVal value As Boolean)
    mDiagnosticsEnabled = value
End Property

Private Property Get IAppConfig_AutoSave() As Boolean
    IAppConfig_AutoSave = mAutoSave
End Property

Private Property Let IAppConfig_AutoSave(ByVal value As Boolean)
    mAutoSave = value
End Property

' ======================
' IDatabaseConfigプロパティ実装
' ======================
Private Property Get IDatabaseConfig_ConnectionString() As String
    IDatabaseConfig_ConnectionString = mConnectionString
End Property

Private Property Let IDatabaseConfig_ConnectionString(ByVal value As String)
    mConnectionString = value
End Property

Private Property Get IDatabaseConfig_ConnectionTimeout() As Long
    IDatabaseConfig_ConnectionTimeout = mConnectionTimeout
End Property

Private Property Let IDatabaseConfig_ConnectionTimeout(ByVal value As Long)
    mConnectionTimeout = value
End Property

Private Property Get IDatabaseConfig_CommandTimeout() As Long
    IDatabaseConfig_CommandTimeout = mCommandTimeout
End Property

Private Property Let IDatabaseConfig_CommandTimeout(ByVal value As Long)
    mCommandTimeout = value
End Property

Private Property Get IDatabaseConfig_DatabaseType() As String
    IDatabaseConfig_DatabaseType = mDatabaseType
End Property

Private Property Let IDatabaseConfig_DatabaseType(ByVal value As String)
    mDatabaseType = value
    UpdateConnectionStringBuilder
End Property

Private Property Get IDatabaseConfig_LogTableName() As String
    IDatabaseConfig_LogTableName = mLogTableName
End Property

Private Property Let IDatabaseConfig_LogTableName(ByVal value As String)
    mLogTableName = value
End Property

================
File: ConsoleLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ConsoleLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "ConsoleLogger"

' ======================
' メンバ変数
' ======================
Private mPerformanceMonitor As IPerformanceMonitor
Private mUseColors As Boolean

' ANSIエスケープシーケンス用の色コード
Private Const ANSI_RESET As String = vbNullString
Private Const ANSI_RED As String = vbNullString
Private Const ANSI_YELLOW As String = vbNullString
Private Const ANSI_GREEN As String = vbNullString
Private Const ANSI_BLUE As String = vbNullString

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 何もしない（依存性は外部から注入）
End Sub

Private Sub Class_Terminate()
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Initialize(ByVal performanceMonitor As IPerformanceMonitor, _
                     Optional ByVal useColors As Boolean = False)
    Set mPerformanceMonitor = performanceMonitor
    mUseColors = useColors
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal logLevel As String, _
                       ByVal message As String, _
                       Optional ByVal stackTrace As String, _
                       Optional ByVal errorCode As Long)
    If mPerformanceMonitor Is Nothing Then Exit Sub
    
    mPerformanceMonitor.StartMeasurement "ConsoleLogger_Log"
    
    On Error GoTo ErrorHandler
    
    ' ログメッセージの組み立てと出力
    Dim logMessage As String
    logMessage = BuildLogMessage(logLevel, message, stackTrace, errorCode)
    WriteToConsole logMessage, logLevel
    
Cleanup:
    mPerformanceMonitor.EndMeasurement "ConsoleLogger_Log"
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "コンソールログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = stackTrace
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

' ======================
' プライベートメソッド
' ======================
Private Function BuildLogMessage(ByVal logLevel As String, _
                               ByVal message As String, _
                               ByVal stackTrace As String, _
                               ByVal errorCode As Long) As String
    BuildLogMessage = Format$(Now, "yyyy/mm/dd hh:nn:ss") & " " & _
                     "[" & logLevel & "] " & _
                     IIf(errorCode <> 0, "(Code: " & errorCode & ") ", "") & _
                     message & _
                     IIf(Len(stackTrace) > 0, vbCrLf & "Stack Trace: " & stackTrace, "")
End Function

Private Sub WriteToConsole(ByVal logMessage As String, ByVal logLevel As String)
    If Not mUseColors Then
        Debug.Print logMessage
        Exit Sub
    End If
    
    ' ログレベルに応じた色付け
    Dim colorCode As String
    Select Case UCase$(logLevel)
        Case "ERROR", "FATAL"
            colorCode = ANSI_RED
        Case "WARNING"
            colorCode = ANSI_YELLOW
        Case "SUCCESS"
            colorCode = ANSI_GREEN
        Case "INFO"
            colorCode = ANSI_BLUE
        Case Else
            colorCode = ANSI_RESET
    End Select
    
    Debug.Print colorCode & logMessage & ANSI_RESET
End Sub

================
File: DatabaseLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DatabaseLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DatabaseLogger"

' ======================
' メンバ変数
' ======================
Private mConnectionPool As IConnectionPool
Private mLock As ILock
Private mPerformanceMonitor As IPerformanceMonitor
Private mDatabaseConfig As IDatabaseConfig
Private mTableName As String
Private Const MAX_RETRY_COUNT As Long = 3
Private Const RETRY_DELAY_MS As Long = 1000

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 何もしない（依存性は外部から注入）
End Sub

Private Sub Class_Terminate()
    Set mConnectionPool = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    Set mDatabaseConfig = Nothing
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Initialize(ByVal connectionPool As IConnectionPool, _
                     ByVal lock As ILock, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal databaseConfig As IDatabaseConfig, _
                     ByVal tableName As String)
    Set mConnectionPool = connectionPool
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    Set mDatabaseConfig = databaseConfig
    mTableName = tableName
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal logLevel As String, _
                       ByVal message As String, _
                       Optional ByVal stackTrace As String, _
                       Optional ByVal errorCode As Long)
    If mConnectionPool Is Nothing Then Exit Sub
    
    mPerformanceMonitor.StartMeasurement "DatabaseLogger_Log"
    mLock.AcquireLock
    
    Dim conn As Object
    Set conn = Nothing
    
    On Error GoTo ErrorHandler
    
    Dim retryCount As Long
    Do While retryCount < MAX_RETRY_COUNT
        If WriteLogToDatabase(logLevel, message, stackTrace, errorCode) Then Exit Do
        retryCount = retryCount + 1
        If retryCount < MAX_RETRY_COUNT Then Sleep RETRY_DELAY_MS
    Loop
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "DatabaseLogger_Log"
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = stackTrace
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

' ======================
' プライベートメソッド
' ======================
Private Function WriteLogToDatabase(ByVal logLevel As String, _
                                  ByVal message As String, _
                                  ByVal stackTrace As String, _
                                  ByVal errorCode As Long) As Boolean
    On Error Resume Next
    
    Dim conn As Object
    Set conn = mConnectionPool.AcquireConnection()
    
    If conn Is Nothing Then
        WriteLogToDatabase = False
        Exit Function
    End If
    
    ' コマンドオブジェクトの作成
    Dim cmd As Object
    Set cmd = CreateObject("ADODB.Command")
    With cmd
        Set .ActiveConnection = conn
        .CommandText = "INSERT INTO " & mTableName & " " & _
                      "(LogTime, LogLevel, Message, StackTrace, ErrorCode) " & _
                      "VALUES (?, ?, ?, ?, ?)"
        .Parameters.Append .CreateParameter("LogTime", adDate, adParamInput, , Now)
        .Parameters.Append .CreateParameter("LogLevel", adVarChar, adParamInput, 50, logLevel)
        .Parameters.Append .CreateParameter("Message", adVarChar, adParamInput, 4000, message)
        .Parameters.Append .CreateParameter("StackTrace", adVarChar, adParamInput, 4000, stackTrace)
        .Parameters.Append .CreateParameter("ErrorCode", adInteger, adParamInput, , errorCode)
        .Execute
    End With
    
    WriteLogToDatabase = (Err.Number = 0)
    
    ' 接続の解放
    If Not conn Is Nothing Then
        mConnectionPool.ReleaseConnection conn
        Set conn = Nothing
    End If
    
    On Error GoTo 0
End Function

================
File: DefaultLoggerSettings.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DefaultLoggerSettings"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILoggerSettings

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DefaultLoggerSettings"

' ======================
' メンバ変数
' ======================
Private mAppConfig As IAppConfig
Private mLogLevel As LogLevel
Private mLogDestinations As Collection
Private mLogFilePath As String
Private mLogTableName As String
Private mLogEventSource As String
Private mTimerInterval As Long
Private mFileOperations As IFileOperations
Private mConnectionPool As IConnectionPool
Private mEventLog As IEventLog
Private mDatabaseConfig As IDatabaseConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLogDestinations = New Collection
    mTimerInterval = 1000 ' デフォルト値: 1秒
End Sub

Private Sub Class_Terminate()
    Set mAppConfig = Nothing
    Set mLogDestinations = Nothing
    Set mFileOperations = Nothing
    Set mConnectionPool = Nothing
    Set mEventLog = Nothing
    Set mDatabaseConfig = Nothing
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Initialize(ByVal appConfig As IAppConfig, _
                     ByVal fileOperations As IFileOperations, _
                     ByVal connectionPool As IConnectionPool, _
                     ByVal eventLog As IEventLog, _
                     ByVal databaseConfig As IDatabaseConfig)
    Set mAppConfig = appConfig
    Set mFileOperations = fileOperations
    Set mConnectionPool = connectionPool
    Set mEventLog = eventLog
    Set mDatabaseConfig = databaseConfig
    
    ' 設定の読み込み
    LoadSettings
End Sub

' ======================
' ILoggerSettings実装
' ======================
Private Property Get ILoggerSettings_LogLevel() As LogLevel
    ILoggerSettings_LogLevel = mLogLevel
End Property

Private Property Let ILoggerSettings_LogLevel(ByVal value As LogLevel)
    mLogLevel = value
End Property

Private Function ILoggerSettings_GetLogDestinations() As Variant
    Dim result() As String
    ReDim result(1 To mLogDestinations.Count)
    
    Dim i As Long
    For i = 1 To mLogDestinations.Count
        result(i) = mLogDestinations(i)
    Next i
    
    ILoggerSettings_GetLogDestinations = result
End Function

Private Property Get ILoggerSettings_LogFilePath() As String
    ILoggerSettings_LogFilePath = mLogFilePath
End Property

Private Property Get ILoggerSettings_LogTableName() As String
    ILoggerSettings_LogTableName = mLogTableName
End Property

Private Property Get ILoggerSettings_LogEventSource() As String
    ILoggerSettings_LogEventSource = mLogEventSource
End Property

Private Property Get ILoggerSettings_TimerInterval() As Long
    ILoggerSettings_TimerInterval = mTimerInterval
End Property

Private Function ILoggerSettings_GetFileOperations() As IFileOperations
    Set ILoggerSettings_GetFileOperations = mFileOperations
End Function

Private Function ILoggerSettings_GetConnectionPool() As IConnectionPool
    Set ILoggerSettings_GetConnectionPool = mConnectionPool
End Function

Private Function ILoggerSettings_GetEventLog() As IEventLog
    Set ILoggerSettings_GetEventLog = mEventLog
End Function

Private Function ILoggerSettings_GetDatabaseConfig() As IDatabaseConfig
    Set ILoggerSettings_GetDatabaseConfig = mDatabaseConfig
End Function

Private Function ILoggerSettings_ShouldLog(ByVal destination As String, ByVal level As LogLevel) As Boolean
    ' 指定された出力先が有効で、ログレベルが現在の設定以上の場合にログを出力
    Dim i As Long
    For i = 1 To mLogDestinations.Count
        If mLogDestinations(i) = destination Then
            ILoggerSettings_ShouldLog = (level >= mLogLevel)
            Exit Function
        End If
    Next i
    
    ILoggerSettings_ShouldLog = False
End Function

Private Function ILoggerSettings_FormatLogMessage(ByVal logLevel As String, _
                                                ByVal message As String, _
                                                ByVal stackTrace As String, _
                                                ByVal errorCode As Long) As String
    Dim result As String
    result = Format$(Now, "yyyy/mm/dd hh:nn:ss") & " " & _
             "[" & logLevel & "] " & _
             IIf(errorCode <> 0, "(Code: " & errorCode & ") ", "") & _
             message
             
    If Len(stackTrace) > 0 Then
        result = result & vbCrLf & "Stack Trace: " & stackTrace
    End If
    
    ILoggerSettings_FormatLogMessage = result
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LoadSettings()
    If mAppConfig Is Nothing Then Exit Sub
    
    ' ログレベルの読み込み
    mLogLevel = mAppConfig.GetValue("Logging", "Level", LOG_LEVEL_INFO)
    
    ' 出力先の読み込み
    Dim destinations As String
    destinations = mAppConfig.GetValue("Logging", "Destinations", "File")
    ParseDestinations destinations
    
    ' ファイル出力設定
    mLogFilePath = mAppConfig.GetValue("Logging", "FilePath", "log\application.log")
    
    ' データベース出力設定
    mLogTableName = mAppConfig.GetValue("Logging", "TableName", "ApplicationLog")
    
    ' イベントログ出力設定
    mLogEventSource = mAppConfig.GetValue("Logging", "EventSource", "PDI Logger")
    
    ' タイマー間隔設定
    mTimerInterval = CLng(mAppConfig.GetValue("Logging", "TimerInterval", "1000"))
End Sub

Private Sub ParseDestinations(ByVal destinations As String)
    Set mLogDestinations = New Collection
    
    Dim parts() As String
    parts = Split(destinations, ",")
    
    Dim i As Long
    For i = LBound(parts) To UBound(parts)
        mLogDestinations.Add Trim$(parts(i))
    Next i
End Sub

================
File: DefaultMessageFormatter.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "DefaultMessageFormatter"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "DefaultMessageFormatter"

' ======================
' インターフェース実装
' ======================
Implements IMessageFormatter

' ======================
' IMessageFormatter実装
' ======================
Private Function IMessageFormatter_FormatMessage(ByVal message As String, ByRef errorInfo As ErrorInfo) As String
    On Error GoTo ErrorHandler
    
    Dim formattedMessage As String
    
    ' 基本メッセージの設定
    formattedMessage = IIf(Len(message) > 0, message & vbCrLf & vbCrLf, "エラーが発生しました。" & vbCrLf & vbCrLf)
    
    ' エラー詳細情報の追加
    formattedMessage = formattedMessage & _
                      "説明: " & errorInfo.Description & vbCrLf & _
                      "発生場所: " & errorInfo.Source & "." & errorInfo.ProcedureName
    
    ' スタックトレースが存在する場合は追加
    If Len(errorInfo.StackTrace) > 0 Then
        formattedMessage = formattedMessage & vbCrLf & vbCrLf & _
                          "スタックトレース:" & vbCrLf & _
                          errorInfo.StackTrace
    End If
    
    IMessageFormatter_FormatMessage = formattedMessage
    Exit Function
    
ErrorHandler:
    ' エラー情報の作成
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "メッセージのフォーマット中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IMessageFormatter_FormatMessage"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    
    ' エラーハンドラに委譲
    modError.HandleError errDetail
    
    ' デフォルトメッセージを返す
    IMessageFormatter_FormatMessage = "エラーメッセージのフォーマットに失敗しました。"
End Function

#If DEBUG Then
    ' ======================
    ' テストサポート機能
    ' ======================
    Public Function TestFormatMessage(ByVal testMessage As String, ByRef testError As ErrorInfo) As String
        TestFormatMessage = IMessageFormatter_FormatMessage(testMessage, testError)
    End Function
#End If

================
File: EmergencyLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "EmergencyLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

Implements IEmergencyLogger

'==========================
' 定数
'==========================
Private Const MODULE_NAME As String = "EmergencyLogger"
Private Const EMERGENCY_LOG_FILE As String = "\PDI_emergency.log"
Private Const EVENT_SOURCE As String = "PDI Error"

'==========================
' メンバ変数
'==========================
Private mLock As clsLock

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    Set mLock = New clsLock
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
End Sub

'==========================
' IEmergencyLogger 実装
'==========================
Private Sub IEmergencyLogger_LogEmergencyError(ByVal message As String, Optional ByRef errorInfo As ErrorInfo)
    mLock.AcquireLock
    On Error Resume Next
    
    ' エラー情報をフォーマット
    Dim formattedMessage As String
    formattedMessage = FormatErrorMessage(message, errorInfo)
    
    ' イベントログへの出力を試みる
    WriteToEventLog formattedMessage
    
    ' ファイルへの出力を試みる
    WriteToEmergencyFile formattedMessage
    
    mLock.ReleaseLock
End Sub

'==========================
' プライベートメソッド
'==========================

''' <summary>
''' エラーメッセージをフォーマットします
''' </summary>
Private Function FormatErrorMessage(ByVal message As String, ByRef errorInfo As ErrorInfo) As String
    Dim builder As String
    builder = Now & " - " & message
    
    If Not IsMissing(errorInfo) Then
        With errorInfo
            builder = builder & vbCrLf & _
                     "コード: " & .Code & vbCrLf & _
                     "説明: " & .Description & vbCrLf & _
                     "ソース: " & .Source & vbCrLf & _
                     "プロシージャ: " & .ProcedureName & vbCrLf & _
                     "発生時刻: " & .OccurredAt & vbCrLf & _
                     "スタックトレース: " & vbCrLf & .StackTrace
        End With
    End If
    
    FormatErrorMessage = builder
End Function

''' <summary>
''' イベントログにエラーを記録します
''' </summary>
Private Sub WriteToEventLog(ByVal message As String)
    On Error Resume Next
    modWindowsAPI.WriteToEventLog EVENT_SOURCE, message, EVENTLOG_ERROR_TYPE
End Sub

''' <summary>
''' 緊急用ファイルにエラーを記録します
''' </summary>
Private Sub WriteToEmergencyFile(ByVal message As String)
    On Error Resume Next
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    Dim logPath As String
    logPath = Environ$("TEMP") & EMERGENCY_LOG_FILE
    
    Dim logFile As Object
    Set logFile = fso.OpenTextFile(logPath, 8, True) ' 8: ForAppending, Create if doesn't exist
    logFile.WriteLine message
    logFile.Close
    
    Set logFile = Nothing
    Set fso = Nothing
End Sub

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Function GetEmergencyLogPath() As String
        GetEmergencyLogPath = Environ$("TEMP") & EMERGENCY_LOG_FILE
    End Function
    
    Public Sub ClearEmergencyLog()
        On Error Resume Next
        Kill GetEmergencyLogPath()
    End Sub
#End If

================
File: ErrorHandlerManager.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ErrorHandlerManager"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

'@Description("エラーハンドラーの管理を行うクラス")

'==========================
' 定数
'==========================
Private Const MODULE_NAME As String = "ErrorHandlerManager"

'==========================
' メンバ変数
'==========================
Private mHandlers As Collection
Private mLock As clsLock
Private mIsInitialized As Boolean

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    Set mHandlers = New Collection
    Set mLock = New clsLock
    InitializeManager
End Sub

Private Sub Class_Terminate()
    Set mHandlers = Nothing
    Set mLock = Nothing
    mIsInitialized = False
End Sub

'==========================
' パブリックメソッド
'==========================

''' <summary>
''' エラーハンドラーマネージャーを初期化します
''' </summary>
Public Sub InitializeManager()
    If mIsInitialized Then Exit Sub
    
    RegisterDefaultHandlers
    mIsInitialized = True
End Sub

''' <summary>
''' エラーコードに対応するエラーハンドラーを登録します
''' </summary>
''' <param name="errorCode">エラーコード</param>
''' <param name="handler">エラーハンドラー</param>
Public Sub RegisterHandler(ByVal errorCode As ErrorCode, ByVal handler As IErrorHandler)
    mLock.AcquireLock
    
    On Error Resume Next
    mHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    
    mHandlers.Add handler, CStr(errorCode)
    
    mLock.ReleaseLock
End Sub

''' <summary>
''' エラーコードに対応するエラーハンドラーの登録を解除します
''' </summary>
''' <param name="errorCode">エラーコード</param>
Public Sub UnregisterHandler(ByVal errorCode As ErrorCode)
    mLock.AcquireLock
    
    On Error Resume Next
    mHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    
    mLock.ReleaseLock
End Sub

''' <summary>
''' エラーコードに対応するエラーハンドラーを取得します
''' </summary>
''' <param name="errorCode">エラーコード</param>
''' <returns>エラーハンドラー。未登録の場合はデフォルトハンドラー</returns>
Public Function GetErrorHandler(ByVal errorCode As ErrorCode) As IErrorHandler
    Dim handler As IErrorHandler
    
    mLock.AcquireLock
    
    On Error Resume Next
    Set handler = mHandlers(CStr(errorCode))
    If Err.Number <> 0 Then
        ' 該当するハンドラが見つからない場合は、エラーカテゴリに基づいてデフォルトハンドラを返す
        Set handler = GetDefaultHandlerForCategory(modErrorCodes.GetErrorCategory(errorCode))
    End If
    On Error GoTo 0
    
    mLock.ReleaseLock
    
    Set GetErrorHandler = handler
End Function

'==========================
' プライベートメソッド
'==========================

''' <summary>
''' デフォルトのエラーハンドラーを登録します
''' </summary>
Private Sub RegisterDefaultHandlers()
    ' データベース接続エラー用ハンドラ
    RegisterHandler ErrDbConnectionFailed, New DatabaseConnectionErrorHandler
    
    ' ファイル不在エラー用ハンドラ
    RegisterHandler ErrFileNotFound, New FileNotFoundErrorHandler
    
    ' 入力検証エラー用ハンドラ
    RegisterHandler ErrInvalidInput, New InvalidInputErrorHandler
End Sub

''' <summary>
''' エラーカテゴリに対応するデフォルトのエラーハンドラーを取得します
''' </summary>
''' <param name="category">エラーカテゴリ</param>
''' <returns>デフォルトのエラーハンドラー</returns>
Private Function GetDefaultHandlerForCategory(ByVal category As ErrorCodeCategory) As IErrorHandler
    Select Case category
        Case ECDatabase
            Set GetDefaultHandlerForCategory = New DatabaseConnectionErrorHandler
        Case ECFileIO
            Set GetDefaultHandlerForCategory = New FileNotFoundErrorHandler
        Case Else
            Set GetDefaultHandlerForCategory = New InvalidInputErrorHandler
    End Select
End Function

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Function GetHandlerCount() As Long
        mLock.AcquireLock
        GetHandlerCount = mHandlers.Count
        mLock.ReleaseLock
    End Function
    
    Public Sub ClearHandlers()
        mLock.AcquireLock
        Set mHandlers = New Collection
        mLock.ReleaseLock
    End Sub
#End If

================
File: ErrorImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ErrorImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

Implements IError

'==========================
' 定数
'==========================
Private Const MODULE_NAME As String = "ErrorImpl"
Private Const MAX_ERROR_RECURSION As Long = 3
Private Const ERROR_COUNT_DICT_SIZE As Long = 100

'==========================
' メンバ変数
'==========================
Private mHandlerManager As ErrorHandlerManager
Private mEmergencyLogger As IEmergencyLogger
Private mErrorCounts As Object ' Scripting.Dictionary
Private mLock As clsLock
Private mIsInitialized As Boolean
Private mErrorRecursionCount As Long
Private mPerformanceMonitor As clsPerformanceMonitor

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    Set mHandlerManager = New ErrorHandlerManager
    Set mEmergencyLogger = New EmergencyLogger
    Set mErrorCounts = CreateObject("Scripting.Dictionary")
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
    mErrorRecursionCount = 0
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mHandlerManager = Nothing
    Set mEmergencyLogger = Nothing
    Set mErrorCounts = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    mIsInitialized = False
End Sub

'==========================
' IError 実装
'==========================
Private Function IError_HandleError(ByRef errorInfo As ErrorInfo) As Boolean
    If Not mIsInitialized Then Exit Function
    
    ' パフォーマンス計測開始
    mPerformanceMonitor.StartMeasurement "HandleError"
    
    ' エラーの再帰制御
    mErrorRecursionCount = mErrorRecursionCount + 1
    If mErrorRecursionCount > MAX_ERROR_RECURSION Then
        mEmergencyLogger.LogEmergencyError "エラー処理の再帰回数が上限を超えました。処理を中断します。", errorInfo
        IError_HandleError = False
        GoTo Cleanup
    End If
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' エラー情報の補完
    CompleteErrorInfo errorInfo
    
    ' エラー発生回数をカウント
    IError_IncrementErrorCount errorInfo.Code
    
    ' エラーハンドラーの取得と実行
    Dim handler As IErrorHandler
    Set handler = mHandlerManager.GetErrorHandler(errorInfo.Code)
    
    If Not handler Is Nothing Then
        IError_HandleError = handler.HandleError(errorInfo)
    End If
    
    mLock.ReleaseLock
    GoTo Cleanup
    
ErrorHandler:
    mLock.ReleaseLock
    mEmergencyLogger.LogEmergencyError "HandleError中にエラーが発生しました: " & Err.Description, errorInfo
    IError_HandleError = False
    
Cleanup:
    mErrorRecursionCount = mErrorRecursionCount - 1
    mPerformanceMonitor.EndMeasurement "HandleError"
End Function

Private Sub IError_RegisterHandler(ByVal errorCode As ErrorCode, ByVal handler As IErrorHandler)
    If Not mIsInitialized Then Exit Sub
    mHandlerManager.RegisterHandler errorCode, handler
End Sub

Private Sub IError_UnregisterHandler(ByVal errorCode As ErrorCode)
    If Not mIsInitialized Then Exit Sub
    mHandlerManager.UnregisterHandler errorCode
End Sub

Private Sub IError_IncrementErrorCount(ByVal errorCode As ErrorCode)
    mLock.AcquireLock
    
    Dim key As String
    key = CStr(errorCode)
    
    If Not mErrorCounts.Exists(key) Then
        mErrorCounts.Add key, 1
    Else
        mErrorCounts(key) = mErrorCounts(key) + 1
    End If
    
    ' エラーカウントの上限を超えた場合、古いエントリを削除
    If mErrorCounts.Count > ERROR_COUNT_DICT_SIZE Then
        RemoveOldestErrorCount
    End If
    
    mLock.ReleaseLock
End Sub

Private Function IError_CheckErrorThreshold(ByVal errorCode As ErrorCode, ByVal threshold As Long) As Boolean
    mLock.AcquireLock
    
    Dim key As String
    key = CStr(errorCode)
    
    IError_CheckErrorThreshold = False
    If mErrorCounts.Exists(key) Then
        IError_CheckErrorThreshold = (mErrorCounts(key) >= threshold)
    End If
    
    mLock.ReleaseLock
End Function

'==========================
' プライベートメソッド
'==========================

''' <summary>
''' エラー情報を補完します
''' </summary>
Private Sub CompleteErrorInfo(ByRef errorInfo As ErrorInfo)
    With errorInfo
        If .OccurredAt = #12:00:00 AM# Then .OccurredAt = Now
        If .Category = 0 Then .Category = modErrorCodes.GetErrorCategory(.Code)
        If Len(.StackTrace) = 0 Then .StackTrace = modStackTrace.GetStackTrace()
    End With
End Sub

''' <summary>
''' 最も古いエラーカウントを削除します
''' </summary>
Private Sub RemoveOldestErrorCount()
    If mErrorCounts.Count = 0 Then Exit Sub
    
    Dim oldestKey As String
    oldestKey = mErrorCounts.Keys()(0)
    mErrorCounts.Remove oldestKey
End Sub

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Function GetErrorCount(ByVal errorCode As ErrorCode) As Long
        mLock.AcquireLock
        
        Dim key As String
        key = CStr(errorCode)
        
        GetErrorCount = 0
        If mErrorCounts.Exists(key) Then
            GetErrorCount = mErrorCounts(key)
        End If
        
        mLock.ReleaseLock
    End Function
    
    Public Sub ClearErrorCounts()
        mLock.AcquireLock
        mErrorCounts.RemoveAll
        mLock.ReleaseLock
    End Sub
    
    Public Function GetPerformanceReport() As String
        GetPerformanceReport = mPerformanceMonitor.GetAllMeasurements()
    End Function
#End If

================
File: ErrorInfo.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ErrorInfo"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' プロパティ
' ======================
Private mCode As Long
Private mDescription As String
Private mCategory As ErrorCodeCategory
Private mSource As String
Private mProcedureName As String
Private mStackTrace As String
Private mOccurredAt As Date
Private mSeverity As ErrorSeverity
Private mAdditionalInfo As Collection
Private mInnerError As ErrorInfo
Private mRecoveryAttempted As Boolean
Private mRecoverySuccessful As Boolean

' ======================
' 列挙型
' ======================
Public Enum ErrorSeverity
    ESInfo = 1
    ESWarning = 2
    ESError = 3
    ESCritical = 4
End Enum

' ======================
' プロパティ
' ======================
Public Property Get Code() As Long
    Code = mCode
End Property
Public Property Let Code(ByVal value As Long)
    mCode = value
End Property

Public Property Get Description() As String
    Description = mDescription
End Property
Public Property Let Description(ByVal value As String)
    mDescription = value
End Property

Public Property Get Category() As ErrorCodeCategory
    Category = mCategory
End Property
Public Property Let Category(ByVal value As ErrorCodeCategory)
    mCategory = value
End Property

Public Property Get Source() As String
    Source = mSource
End Property
Public Property Let Source(ByVal value As String)
    mSource = value
End Property

Public Property Get ProcedureName() As String
    ProcedureName = mProcedureName
End Property
Public Property Let ProcedureName(ByVal value As String)
    mProcedureName = value
End Property

Public Property Get StackTrace() As String
    StackTrace = mStackTrace
End Property
Public Property Let StackTrace(ByVal value As String)
    mStackTrace = value
End Property

Public Property Get OccurredAt() As Date
    OccurredAt = mOccurredAt
End Property
Public Property Let OccurredAt(ByVal value As Date)
    mOccurredAt = value
End Property

Public Property Get Severity() As ErrorSeverity
    Severity = mSeverity
End Property
Public Property Let Severity(ByVal value As ErrorSeverity)
    mSeverity = value
End Property

Public Property Get InnerError() As ErrorInfo
    Set InnerError = mInnerError
End Property
Public Property Set InnerError(ByVal value As ErrorInfo)
    Set mInnerError = value
End Property

Public Property Get RecoveryAttempted() As Boolean
    RecoveryAttempted = mRecoveryAttempted
End Property
Public Property Let RecoveryAttempted(ByVal value As Boolean)
    mRecoveryAttempted = value
End Property

Public Property Get RecoverySuccessful() As Boolean
    RecoverySuccessful = mRecoverySuccessful
End Property
Public Property Let RecoverySuccessful(ByVal value As Boolean)
    mRecoverySuccessful = value
End Property

' ======================
' 初期化
' ======================
Private Sub Class_Initialize()
    Set mAdditionalInfo = New Collection
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub AddAdditionalInfo(ByVal key As String, ByVal value As Variant)
    On Error Resume Next
    mAdditionalInfo.Remove key
    On Error GoTo 0
    mAdditionalInfo.Add value, key
End Sub

Public Function GetAdditionalInfo(ByVal key As String) As Variant
    On Error Resume Next
    GetAdditionalInfo = mAdditionalInfo(key)
    On Error GoTo 0
End Function

Public Function HasAdditionalInfo(ByVal key As String) As Boolean
    On Error Resume Next
    Dim temp As Variant
    temp = mAdditionalInfo(key)
    HasAdditionalInfo = (Err.Number = 0)
    On Error GoTo 0
End Function

Public Function Clone() As ErrorInfo
    Dim result As New ErrorInfo
    With result
        .Code = mCode
        .Description = mDescription
        .Category = mCategory
        .Source = mSource
        .ProcedureName = mProcedureName
        .StackTrace = mStackTrace
        .OccurredAt = mOccurredAt
        .Severity = mSeverity
        .RecoveryAttempted = mRecoveryAttempted
        .RecoverySuccessful = mRecoverySuccessful
        If Not mInnerError Is Nothing Then
            Set .InnerError = mInnerError.Clone
        End If
        
        ' 追加情報のコピー
        Dim key As Variant
        For Each key In mAdditionalInfo
            .AddAdditionalInfo CStr(key), mAdditionalInfo(key)
        Next key
    End With
    Set Clone = result
End Function

Public Function ToString() As String
    Dim result As String
    result = "Error Details:" & vbCrLf & _
            "Code: " & mCode & vbCrLf & _
            "Description: " & mDescription & vbCrLf & _
            "Category: " & mCategory & vbCrLf & _
            "Source: " & mSource & vbCrLf & _
            "Procedure: " & mProcedureName & vbCrLf & _
            "Occurred At: " & Format(mOccurredAt, "yyyy/mm/dd hh:nn:ss") & vbCrLf & _
            "Severity: " & mSeverity & vbCrLf & _
            "Recovery Attempted: " & mRecoveryAttempted & vbCrLf & _
            "Recovery Successful: " & mRecoverySuccessful & vbCrLf & _
            "Stack Trace: " & vbCrLf & mStackTrace
    
    If Not mInnerError Is Nothing Then
        result = result & vbCrLf & vbCrLf & "Inner Error:" & vbCrLf & _
                mInnerError.ToString
    End If
    
    ToString = result
End Function

================
File: EventLogImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "EventLogImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IEventLog

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "EventLogImpl"

' ======================
' メンバ変数
' ======================
Private mIsInitialized As Boolean
Private mLock As clsLock
Private mPerformanceMonitor As clsPerformanceMonitor
Private mLastError As String

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    mIsInitialized = False
End Sub

' ======================
' IEventLog実装
' ======================
Private Function IEventLog_WriteToEventLog(ByVal source As String, _
                                         ByVal message As String, _
                                         ByVal eventType As EventLogType) As Boolean
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "WriteToEventLog"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' ソースの存在確認
    If Not IEventLog_EventSourceExists(source) Then
        LogError "イベントソースが存在しません: " & source
        GoTo CleanUp
    End If
    
    ' メッセージの長さチェック
    If Len(message) > 32766 Then
        LogError "メッセージが長すぎます。32,766文字以内にしてください。"
        GoTo CleanUp
    End If
    
    ' Shell経由でイベントログに書き込み
    Dim shell As Object
    Set shell = CreateObject("WScript.Shell")
    
    ' イベントログ書き込み
    shell.LogEvent CInt(eventType), message, source
    
    Set shell = Nothing
    IEventLog_WriteToEventLog = True
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "WriteToEventLog"
    Exit Function

ErrorHandler:
    mLastError = "イベントログへの書き込み中にエラーが発生しました: " & Err.Description
    LogError mLastError
    IEventLog_WriteToEventLog = False
    Resume CleanUp
End Function

Private Function IEventLog_EventSourceExists(ByVal source As String) As Boolean
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "EventSourceExists"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' レジストリキーの存在確認
    Dim shell As Object
    Set shell = CreateObject("WScript.Shell")
    
    Const HKLM As String = "HKLM\SYSTEM\CurrentControlSet\Services\Eventlog\Application\"
    
    ' レジストリキーの存在確認を試行
    Dim regValue
    regValue = shell.RegRead(HKLM & source & "\EventMessageFile")
    
    Set shell = Nothing
    IEventLog_EventSourceExists = True
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "EventSourceExists"
    Exit Function

ErrorHandler:
    ' レジストリキーが存在しない場合も含む
    mLastError = "イベントソースの確認中にエラーが発生しました: " & Err.Description
    IEventLog_EventSourceExists = False
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' パブリックプロパティ
' ======================
Public Property Get LastError() As String
    LastError = mLastError
End Property

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = mIsInitialized And _
                       Not (mLock Is Nothing) And _
                       Not (mPerformanceMonitor Is Nothing)
    End Function
    
    Public Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
    
    Public Function TestEventLogAccess(ByVal testSource As String) As Boolean
        ' イベントログへのアクセス権限をテスト
        Dim testMessage As String
        testMessage = "EventLogImpl Test Message @ " & Now
        
        TestEventLogAccess = IEventLog_WriteToEventLog(testSource, _
                                                      testMessage, _
                                                      EVENTLOG_INFORMATION_TYPE)
    End Function
#End If

================
File: EventLogLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "EventLogLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "EventLogLogger"

' ======================
' メンバ変数
' ======================
Private mEventLog As IEventLog
Private mLock As ILock
Private mPerformanceMonitor As IPerformanceMonitor
Private mEventSource As String
Private Const MAX_RETRY_COUNT As Long = 3
Private Const RETRY_DELAY_MS As Long = 1000

' イベントログの種類定数
Private Const EVENTLOG_SUCCESS As Long = 0
Private Const EVENTLOG_ERROR As Long = 1
Private Const EVENTLOG_WARNING As Long = 2
Private Const EVENTLOG_INFORMATION As Long = 4

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 何もしない（依存性は外部から注入）
End Sub

Private Sub Class_Terminate()
    Set mEventLog = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Initialize(ByVal eventLog As IEventLog, _
                     ByVal lock As ILock, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal eventSource As String)
    Set mEventLog = eventLog
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    mEventSource = eventSource
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal logLevel As String, _
                       ByVal message As String, _
                       Optional ByVal stackTrace As String, _
                       Optional ByVal errorCode As Long)
    If mEventLog Is Nothing Then Exit Sub
    
    mPerformanceMonitor.StartMeasurement "EventLogLogger_Log"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim retryCount As Long
    Do While retryCount < MAX_RETRY_COUNT
        If WriteLogToEventLog(logLevel, message, stackTrace, errorCode) Then Exit Do
        retryCount = retryCount + 1
        If retryCount < MAX_RETRY_COUNT Then Sleep RETRY_DELAY_MS
    Loop
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "EventLogLogger_Log"
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "イベントログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = stackTrace
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

' ======================
' プライベートメソッド
' ======================
Private Function WriteLogToEventLog(ByVal logLevel As String, _
                                  ByVal message As String, _
                                  ByVal stackTrace As String, _
                                  ByVal errorCode As Long) As Boolean
    On Error Resume Next
    
    ' イベントの種類を決定
    Dim eventType As Long
    Select Case UCase$(logLevel)
        Case "ERROR", "FATAL"
            eventType = EVENTLOG_ERROR
        Case "WARNING"
            eventType = EVENTLOG_WARNING
        Case "SUCCESS"
            eventType = EVENTLOG_SUCCESS
        Case Else
            eventType = EVENTLOG_INFORMATION
    End Select
    
    ' メッセージの組み立て
    Dim logMessage As String
    logMessage = Format$(Now, "yyyy/mm/dd hh:nn:ss") & vbCrLf & _
                 "Level: " & logLevel & vbCrLf & _
                 "Message: " & message
    
    If errorCode <> 0 Then
        logMessage = logMessage & vbCrLf & "Error Code: " & errorCode
    End If
    
    If Len(stackTrace) > 0 Then
        logMessage = logMessage & vbCrLf & "Stack Trace: " & stackTrace
    End If
    
    ' イベントログへの書き込み
    mEventLog.WriteEntry mEventSource, logMessage, eventType
    
    WriteLogToEventLog = (Err.Number = 0)
    On Error GoTo 0
End Function

================
File: FileLogger.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FileLogger"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILogger

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "FileLogger"

' ======================
' メンバ変数
' ======================
Private mFileOperations As IFileOperations
Private mLock As ILock
Private mPerformanceMonitor As IPerformanceMonitor
Private mLogFilePath As String
Private Const MAX_RETRY_COUNT As Long = 3
Private Const RETRY_DELAY_MS As Long = 1000

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 何もしない（依存性は外部から注入）
End Sub

Private Sub Class_Terminate()
    Set mFileOperations = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' 公開メソッド
' ======================
Public Sub Initialize(ByVal fileOperations As IFileOperations, _
                     ByVal lock As ILock, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal logFilePath As String)
    Set mFileOperations = fileOperations
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    mLogFilePath = logFilePath
End Sub

' ======================
' ILogger実装
' ======================
Private Sub ILogger_Log(ByVal logLevel As String, _
                       ByVal message As String, _
                       Optional ByVal stackTrace As String, _
                       Optional ByVal errorCode As Long)
    If mFileOperations Is Nothing Then Exit Sub
    
    mPerformanceMonitor.StartMeasurement "FileLogger_Log"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim logMessage As String
    logMessage = BuildLogMessage(logLevel, message, stackTrace, errorCode)
    
    Dim retryCount As Long
    Do While retryCount < MAX_RETRY_COUNT
        If WriteLogToFile(logMessage) Then Exit Do
        retryCount = retryCount + 1
        If retryCount < MAX_RETRY_COUNT Then Sleep RETRY_DELAY_MS
    Loop
    
Cleanup:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "FileLogger_Log"
    Exit Sub
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ファイルログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ILogger_Log"
        .StackTrace = stackTrace
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Cleanup
End Sub

' ======================
' プライベートメソッド
' ======================
Private Function BuildLogMessage(ByVal logLevel As String, _
                               ByVal message As String, _
                               ByVal stackTrace As String, _
                               ByVal errorCode As Long) As String
    BuildLogMessage = Format$(Now, "yyyy/mm/dd hh:nn:ss") & " " & _
                     "[" & logLevel & "] " & _
                     IIf(errorCode <> 0, "(Code: " & errorCode & ") ", "") & _
                     message & _
                     IIf(Len(stackTrace) > 0, vbCrLf & "Stack Trace: " & stackTrace, "")
End Function

Private Function WriteLogToFile(ByVal logMessage As String) As Boolean
    On Error Resume Next
    
    ' ファイルの存在確認と作成
    If Not mFileOperations.FileExists(mLogFilePath) Then
        mFileOperations.CreateFile mLogFilePath
    End If
    
    ' ログメッセージの書き込み
    mFileOperations.AppendText mLogFilePath, logMessage & vbCrLf
    
    WriteLogToFile = (Err.Number = 0)
    On Error GoTo 0
End Function

================
File: InvalidInputErrorHandler.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "InvalidInputErrorHandler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "InvalidInputErrorHandler"

' ======================
' プライベート変数
' ======================
Private mLock As ILock
Private mLogger As ILogger
Private mEmergencyLogger As IEmergencyLogger
Private mUserNotifier As IUserNotifier
Private mValidator As IValidator

Implements IErrorHandler

' =====================
' コンストラクタ
' =====================
Public Function Create( _
    ByVal lock As ILock, _
    ByVal logger As ILogger, _
    ByVal emergencyLogger As IEmergencyLogger, _
    ByVal userNotifier As IUserNotifier, _
    ByVal validator As IValidator _
) As InvalidInputErrorHandler
    
    Dim instance As New InvalidInputErrorHandler
    
    ' 依存性の注入
    With instance
        If lock Is Nothing Then
            Err.Raise 5, "InvalidInputErrorHandler.Create", "ILock is required"
        End If
        Set .Lock = lock
        
        If logger Is Nothing Then
            Err.Raise 5, "InvalidInputErrorHandler.Create", "ILogger is required"
        End If
        Set .Logger = logger
        
        If emergencyLogger Is Nothing Then
            Err.Raise 5, "InvalidInputErrorHandler.Create", "IEmergencyLogger is required"
        End If
        Set .EmergencyLogger = emergencyLogger
        
        If userNotifier Is Nothing Then
            Err.Raise 5, "InvalidInputErrorHandler.Create", "IUserNotifier is required"
        End If
        Set .UserNotifier = userNotifier
        
        If validator Is Nothing Then
            Err.Raise 5, "InvalidInputErrorHandler.Create", "IValidator is required"
        End If
        Set .Validator = validator
    End With
    
    Set Create = instance
End Function

' プロパティ
Public Property Set Lock(ByVal value As ILock)
    Set mLock = value
End Property

Public Property Set Logger(ByVal value As ILogger)
    Set mLogger = value
End Property

Public Property Set EmergencyLogger(ByVal value As IEmergencyLogger)
    Set mEmergencyLogger = value
End Property

Public Property Set UserNotifier(ByVal value As IUserNotifier)
    Set mUserNotifier = value
End Property

Public Property Set Validator(ByVal value As IValidator)
    Set mValidator = value
End Property

' ======================
' IErrorHandler実装
' ======================
Private Function IErrorHandler_HandleError(ByRef errorDetail As ErrorInfo) As Boolean
    Dim proceed As Boolean
    proceed = False  ' デフォルトでは処理を中断
    
    mLock.AcquireLock
    
    ' エラー情報をログに記録
    LogError errorDetail
    
    ' 入力値の自動補正を試みる
    If errorDetail.HasAdditionalInfo("InputValue") And _
       errorDetail.HasAdditionalInfo("InputType") Then
        
        Dim inputValue As Variant
        Dim inputType As String
        inputValue = errorDetail.GetAdditionalInfo("InputValue")
        inputType = errorDetail.GetAdditionalInfo("InputType")
        
        ' 入力値の自動補正を試みる
        Dim correctedValue As Variant
        If TryCorrectInput(inputValue, inputType, correctedValue) Then
            errorDetail.AddAdditionalInfo "CorrectedValue", correctedValue
            errorDetail.RecoveryAttempted = True
            errorDetail.RecoverySuccessful = True
            proceed = True
        End If
    End If
    
    mLock.ReleaseLock
    
    ' ユーザーに通知
    NotifyUser errorDetail, IIf(proceed, vbInformation, vbExclamation)
    
    IErrorHandler_HandleError = proceed
End Function

' ======================
' プライベートメソッド
' ======================
Private Function TryCorrectInput(ByVal value As Variant, ByVal inputType As String, ByRef correctedValue As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    Select Case LCase(inputType)
        Case "number"
            If TryCorrectNumber(value, correctedValue) Then
                TryCorrectInput = True
                Exit Function
            End If
            
        Case "date"
            If TryCorrectDate(value, correctedValue) Then
                TryCorrectInput = True
                Exit Function
            End If
            
        Case "string"
            If TryCorrectString(value, correctedValue) Then
                TryCorrectInput = True
                Exit Function
            End If
    End Select
    
    TryCorrectInput = False
    Exit Function

ErrorHandler:
    TryCorrectInput = False
End Function

Private Function TryCorrectNumber(ByVal value As Variant, ByRef correctedValue As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    ' 数値への変換を試みる
    If IsNumeric(value) Then
        correctedValue = CDbl(value)
        TryCorrectNumber = True
        Exit Function
    End If
    
    ' カンマや空白を除去して再試行
    Dim cleanValue As String
    cleanValue = Replace(Replace(CStr(value), ",", ""), " ", "")
    
    If IsNumeric(cleanValue) Then
        correctedValue = CDbl(cleanValue)
        TryCorrectNumber = True
        Exit Function
    End If
    
    TryCorrectNumber = False
    Exit Function

ErrorHandler:
    TryCorrectNumber = False
End Function

Private Function TryCorrectDate(ByVal value As Variant, ByRef correctedValue As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    ' 日付への変換を試みる
    If IsDate(value) Then
        correctedValue = CDate(value)
        TryCorrectDate = True
        Exit Function
    End If
    
    ' 一般的な日付形式を試行
    Dim formats() As String
    formats = Array("yyyy/mm/dd", "dd/mm/yyyy", "mm/dd/yyyy", "yyyy-mm-dd", "dd-mm-yyyy", "mm-dd-yyyy")
    
    Dim i As Long
    For i = LBound(formats) To UBound(formats)
        If mValidator.IsValidDate(CStr(value), formats(i)) Then
            correctedValue = CDate(value)
            TryCorrectDate = True
            Exit Function
        End If
    Next i
    
    TryCorrectDate = False
    Exit Function

ErrorHandler:
    TryCorrectDate = False
End Function

Private Function TryCorrectString(ByVal value As Variant, ByRef correctedValue As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    ' 文字列の基本的なクリーニング
    Dim cleanValue As String
    cleanValue = Trim(CStr(value))
    
    ' 制御文字の除去
    Dim i As Long
    Dim result As String
    For i = 1 To Len(cleanValue)
        Dim ch As String
        ch = Mid(cleanValue, i, 1)
        If Asc(ch) >= 32 Or ch = vbTab Then
            result = result & ch
        End If
    Next i
    
    If Len(result) > 0 Then
        correctedValue = result
        TryCorrectString = True
    Else
        TryCorrectString = False
    End If
    Exit Function

ErrorHandler:
    TryCorrectString = False
End Function

Private Sub LogError(ByRef errorDetail As ErrorInfo)
    On Error GoTo ErrorHandler
    
    ' 通常のログ出力
    mLogger.Log MODULE_NAME, "無効な入力: " & errorDetail.Description, errorDetail.Code
    
    ' 重要なエラーは緊急ログにも記録
    If errorDetail.Severity >= ESError Then
        mEmergencyLogger.LogEmergency MODULE_NAME, errorDetail.ToString
    End If
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "入力エラーのログ出力中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "LogError"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

Private Sub NotifyUser(ByRef errorDetail As ErrorInfo, ByVal style As VbMsgBoxStyle)
    On Error GoTo ErrorHandler
    
    Dim message As String
    message = "無効な入力: " & errorDetail.Description
    
    If errorDetail.HasAdditionalInfo("CorrectedValue") Then
        message = message & vbCrLf & vbCrLf & _
                 "推奨される値: " & errorDetail.GetAdditionalInfo("CorrectedValue")
    End If
    
    mUserNotifier.Notify errorDetail, style, "入力エラー"
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    Set errDetail = New ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "入力エラーの通知中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "NotifyUser"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
        .Severity = ESError
        Set .InnerError = errorDetail.Clone
    End With
    modError.HandleError errDetail
End Sub

================
File: modAppInitializer.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modAppInitializer"

' ======================
' 初期化状態管理
' ======================
Private Type InitializationState
    ConfigInitialized As Boolean
    LoggingInitialized As Boolean
    DatabaseInitialized As Boolean
    ErrorHandlersInitialized As Boolean
End Type

Private mInitState As InitializationState

' ======================
' 公開メソッド
' ======================
Public Sub InitializeApplication()
    On Error GoTo ErrorHandler
    
    ' 設定の初期化（最初に実行）
    If Not mInitState.ConfigInitialized Then
        modConfig.InitializeModule
        mInitState.ConfigInitialized = True
    End If
    
    ' ロギングシステムの初期化
    If Not mInitState.LoggingInitialized Then
        InitializeLogging
        mInitState.LoggingInitialized = True
    End If
    
    ' データベース関連の初期化
    If Not mInitState.DatabaseInitialized Then
        InitializeDatabase
        mInitState.DatabaseInitialized = True
    End If
    
    ' エラーハンドラーの初期化（最後に実行）
    If Not mInitState.ErrorHandlersInitialized Then
        InitializeErrorHandlers
        mInitState.ErrorHandlersInitialized = True
    End If
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "アプリケーションの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeApplication"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub InitializeLogging()
    On Error GoTo ErrorHandler
    
    ' ロガー設定の初期化
    Dim loggerSettings As DefaultLoggerSettings
    Set loggerSettings = New DefaultLoggerSettings
    loggerSettings.Initialize modConfig.Settings.DatabaseConnectionString
    
    ' デフォルトロガーの設定
    With New clsLogger
        .Configure loggerSettings, modConfig
        .Log MODULE_NAME, "ロギングシステムが初期化されました", 0
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "ロギングシステムの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeLogging"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub InitializeDatabase()
    On Error GoTo ErrorHandler
    
    ' データベースユーティリティの初期化
    modDatabaseUtils.InitializeModule
    
    ' データベース接続プールの初期化
    With New ConnectionPool
        ' IDatabaseConfigインターフェースを通じて接続文字列を取得
        .Initialize modConfig
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "データベースシステムの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECDatabase
        .Source = MODULE_NAME
        .ProcedureName = "InitializeDatabase"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

Private Sub InitializeErrorHandlers()
    On Error GoTo ErrorHandler
    
    ' エラーハンドラーの初期化
    ' この時点で設定とロギングは初期化済みであることが保証される
    With DatabaseConnectionErrorHandler.Create(modConfig)
        ' 必要な初期化処理があれば実行
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "エラーハンドラーの初期化中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "InitializeErrorHandlers"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
End Sub

================
File: modConfig.bas
================
Option Explicit
Implements IDatabaseConfig

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modConfig"

' ======================
' 定数定義
' ======================
Private Const CONFIG_FILE_PATH As String = "config.ini"
Private Const MAX_BUFFER_SIZE As Long = 1024
Private Const DEFAULT_SECTION As String = "Settings"

' ======================
' 型定義
' ======================
Private Type ConfigurationSettings
    LogLevel As LogLevel
    LogDestination As LogDestination
    LogFilePath As String
    DatabaseConnectionString As String
    SecurityLevel As SecurityLevel
    PerformanceMonitoringEnabled As Boolean
    DiagnosticsEnabled As Boolean
    EncryptionKey As String
    AutoSave As Boolean
End Type

' ======================
' プライベート変数
' ======================
Private settings As ConfigurationSettings
Private settingsLock As clsLock
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean
Private isDirty As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set settingsLock = New clsLock
    Set performanceMonitor = New clsPerformanceMonitor
    
    LoadDefaultSettings
    LoadConfigurationFromFile
    
    isInitialized = True
    
    ' パフォーマンスモニタリング開始
    If settings.PerformanceMonitoringEnabled Then
        performanceMonitor.StartMeasurement "ConfigInitialization"
    End If
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    ' パフォーマンスモニタリング終了
    If settings.PerformanceMonitoringEnabled Then
        performanceMonitor.EndMeasurement "ConfigInitialization"
    End If
    
    ' 変更された設定を保存
    If isDirty And settings.AutoSave Then
        SaveConfigurationToFile
    End If
    Set settingsLock = Nothing
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開プロパティ
' ======================
Public Property Get Settings() As ConfigurationSettings
    If Not isInitialized Then InitializeModule
    
    settingsLock.AcquireLock
    Settings = settings
    settingsLock.ReleaseLock
End Property

Public Property Let Settings(ByVal Value As ConfigurationSettings)
    If Not isInitialized Then InitializeModule
    
    settingsLock.AcquireLock
    settings = Value
    settingsLock.ReleaseLock
    
    isDirty = True
    If settings.AutoSave Then
        SaveConfigurationToFile
    End If
End Property

' ======================
' 公開メソッド
' ======================
Public Function GetConfigValue(ByVal section As String, ByVal key As String, _
                             Optional ByVal defaultValue As String = "") As String
    If Not isInitialized Then InitializeModule
    
    Dim buffer As String
    Dim result As Long
    
    buffer = String$(MAX_BUFFER_SIZE, 0)
    result = modWindowsAPI.GetPrivateProfileString(section, key, defaultValue, buffer, Len(buffer), GetConfigFilePath())
    
    If result > 0 Then
        GetConfigValue = Left$(buffer, result)
    Else
        GetConfigValue = defaultValue
    End If
End Function

Public Function SetConfigValue(ByVal section As String, ByVal key As String, _
                             ByVal Value As String) As Boolean
    If Not isInitialized Then InitializeModule
    
    Dim result As Boolean
    result = (modWindowsAPI.WritePrivateProfileString(section, key, Value, GetConfigFilePath()) <> 0)
    
    If result Then
        isDirty = True
    End If
    SetConfigValue = result
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LoadDefaultSettings()
    With settings
        .LogLevel = LevelInfo
        .LogDestination = DestFile
        .LogFilePath = DEFAULT_LOG_FILE
        .SecurityLevel = LevelMedium
        .PerformanceMonitoringEnabled = True
        .DiagnosticsEnabled = True
        .AutoSave = True
    End With
End Sub

Private Sub LoadConfigurationFromFile()
    On Error GoTo ErrorHandler
    
    With settings
        ' ログ設定
        .LogLevel = CInt(GetConfigValue(DEFAULT_SECTION, "LogLevel", CStr(LevelInfo)))
        .LogDestination = CInt(GetConfigValue(DEFAULT_SECTION, "LogDestination", CStr(DestFile)))
        .LogFilePath = GetConfigValue(DEFAULT_SECTION, "LogFilePath", DEFAULT_LOG_FILE)
        
        ' データベース設定
        .DatabaseConnectionString = GetConfigValue("Database", "ConnectionString", "")
        
        ' セキュリティ設定
        .SecurityLevel = CInt(GetConfigValue("Security", "Level", CStr(LevelMedium)))
        .EncryptionKey = GetConfigValue("Security", "EncryptionKey", "")
        
        ' 診断設定
        .PerformanceMonitoringEnabled = CBool(GetConfigValue("Diagnostics", "PerformanceMonitoring", "True"))
        .DiagnosticsEnabled = CBool(GetConfigValue("Diagnostics", "Enabled", "True"))
        
        ' 自動保存設定
        .AutoSave = CBool(GetConfigValue(DEFAULT_SECTION, "AutoSave", "True"))
    End With
    
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileInvalidFormat
        .Description = "設定ファイルの読み込み中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "LoadConfigurationFromFile"
        .StackTrace = GetCurrentCallStack
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Next
End Sub

Private Sub SaveConfigurationToFile()
    On Error GoTo ErrorHandler
    
    With settings
        ' ログ設定
        SetConfigValue DEFAULT_SECTION, "LogLevel", CStr(.LogLevel)
        SetConfigValue DEFAULT_SECTION, "LogDestination", CStr(.LogDestination)
        SetConfigValue DEFAULT_SECTION, "LogFilePath", .LogFilePath
        
        ' データベース設定
        SetConfigValue "Database", "ConnectionString", .DatabaseConnectionString
        
        ' セキュリティ設定
        SetConfigValue "Security", "Level", CStr(.SecurityLevel)
        SetConfigValue "Security", "EncryptionKey", .EncryptionKey
        
        ' 診断設定
        SetConfigValue "Diagnostics", "PerformanceMonitoring", CStr(.PerformanceMonitoringEnabled)
        SetConfigValue "Diagnostics", "Enabled", CStr(.DiagnosticsEnabled)
        
        ' 自動保存設定
        SetConfigValue DEFAULT_SECTION, "AutoSave", CStr(.AutoSave)
    End With
    
    isDirty = False
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrFileAccessDenied
        .Description = "設定ファイルの保存中にエラーが発生しました: " & Err.Description
        .Category = ECFileIO
        .Source = MODULE_NAME
        .ProcedureName = "SaveConfigurationToFile"
        .StackTrace = GetCurrentCallStack
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    Resume Next
End Sub

Private Function GetConfigFilePath() As String
    GetConfigFilePath = App.Path & "\" & CONFIG_FILE_PATH
End Function

' ======================
' 設定管理
' ======================
Public Sub SaveChanges()
    If Not isInitialized Then InitializeModule
    
    If isDirty Then
        SaveConfigurationToFile
    End If
End Sub

Public Property Get HasUnsavedChanges() As Boolean
    HasUnsavedChanges = isDirty
End Property

Public Property Let AutoSave(ByVal Value As Boolean)
    settings.AutoSave = Value
End Property

' ======================
' ヘルパー関数
' ======================
Private Function GetCurrentCallStack() As String
    Dim callStack As New clsCallStack
    
    ' 現在のプロシージャ情報をスタックに追加
    callStack.Push MODULE_NAME, "GetCurrentCallStack"
    
    ' スタックトレースを取得
    GetCurrentCallStack = callStack.StackTrace
End Function

' ======================
' IDatabaseConfig インターフェースの実装
' ======================
Private Function IDatabaseConfig_GetConnectionString() As String
    If Not isInitialized Then InitializeModule
    
    IDatabaseConfig_GetConnectionString = Me.Settings.DatabaseConnectionString
End Function

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    Public Function ValidateSettings() As Boolean
        With settings
            ValidateSettings = _
                .LogLevel >= LevelDebug And .LogLevel <= LevelFatal And _
                .LogDestination >= DestNone And .LogDestination <= DestEmail And _
                .SecurityLevel >= LevelLow And .SecurityLevel <= LevelExtreme
        End With
    End Function
#End If

================
File: modError.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modError"

' ======================
' プライベート変数
' ======================
Private errorHandlers As Collection
Private isInitialized As Boolean
Private mLock As clsLock
Private Const MAX_ERROR_RECURSION As Long = 3
Private errorRecursionCount As Long
Private mPerformanceMonitor As clsPerformanceMonitor

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set errorHandlers = New Collection
    Set mLock = New clsLock
    Set mPerformanceMonitor = New clsPerformanceMonitor
    errorRecursionCount = 0
    RegisterDefaultHandlers
    
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set errorHandlers = Nothing
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
    errorRecursionCount = 0
    isInitialized = False
End Sub

' ======================
' エラーハンドリング
' ======================
Private Type ErrorContext
    Info As ErrorInfo
    Handler As IErrorHandler
    IsLocked As Boolean
    IsEmergency As Boolean
End Type

Private Function TryHandleError(ByRef context As ErrorContext) As Boolean
    On Error GoTo ErrorHandler
    
    ' パフォーマンス計測開始
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "TryHandleError"
    End If
    
    ' エラー情報の補完
    With context.Info
        If .OccurredAt = #12:00:00 AM# Then .OccurredAt = Now
        If .Category = 0 Then .Category = modErrorCodes.GetErrorCategory(.Code)
        If Len(.StackTrace) = 0 Then .StackTrace = modStackTrace.GetStackTrace()
    End With
    
    ' エラーハンドラの取得
    Set context.Handler = GetErrorHandler(context.Info.Code)
    
    ' パフォーマンス計測終了
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "TryHandleError"
    End If
    
    TryHandleError = True
    Exit Function
    
ErrorHandler:
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "TryHandleError"
    End If
    TryHandleError = False
End Function

Public Sub HandleError(ByRef errInfo As ErrorInfo)
    If Not isInitialized Then InitializeModule
    
    ' パフォーマンス計測開始
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "HandleError"
    End If
    
    Dim context As ErrorContext
    context.Info = errInfo
    
    ' エラーの再帰を防ぐ
    errorRecursionCount = errorRecursionCount + 1
    If errorRecursionCount > MAX_ERROR_RECURSION Then
        EmergencyErrorLog "エラー処理の再帰回数が上限を超えました。処理を中断します。"
        context.IsEmergency = True
        GoTo Cleanup
    End If

    ' ロック取得
    On Error Resume Next
    mLock.AcquireLock
    context.IsLocked = (Err.Number = 0)
    On Error GoTo 0

    ' エラー処理のメイン部分
    If TryHandleError(context) Then
        If Not context.Handler Is Nothing Then
            Dim proceed As Boolean
            proceed = context.Handler.HandleError(context.Info)
            
            ' エラー処理の結果に基づいて処理を継続するかどうかを判断
            If Not proceed Then
                context.IsEmergency = True
                GoTo Cleanup
            End If
        End If
    Else
        context.IsEmergency = True
    End If

Cleanup:
    ' クリーンアップ処理
    If context.IsLocked Then
        mLock.ReleaseLock
    End If

    If context.IsEmergency Then
        EmergencyErrorLog "HandleError中にエラーが発生しました: " & Err.Description
    End If
    
    ' パフォーマンス計測終了
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "HandleError"
    End If

    errorRecursionCount = errorRecursionCount - 1
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub RegisterDefaultHandlers()
    ' データベース接続エラー用ハンドラ
    RegisterErrorHandler ErrDbConnectionFailed, New DatabaseConnectionErrorHandler
    
    ' ファイル不在エラー用ハンドラ
    RegisterErrorHandler ErrFileNotFound, New FileNotFoundErrorHandler
    
    ' 入力検証エラー用ハンドラ
    RegisterErrorHandler ErrInvalidInput, New InvalidInputErrorHandler
End Sub

Private Function GetErrorHandler(ByVal errorCode As ErrorCode) As IErrorHandler
    Dim handler As IErrorHandler
    
    On Error Resume Next
    Set handler = errorHandlers(CStr(errorCode))
    If Err.Number <> 0 Then
        ' 該当するハンドラが見つからない場合は、エラーカテゴリに基づいてデフォルトハンドラを返す
        Set handler = GetDefaultHandlerForCategory(modErrorCodes.GetErrorCategory(errorCode))
    End If
    On Error GoTo 0
    
    Set GetErrorHandler = handler
End Function

Private Function GetDefaultHandlerForCategory(ByVal category As ErrorCodeCategory) As IErrorHandler
    Select Case category
        Case ECDatabase
            Set GetDefaultHandlerForCategory = New DatabaseConnectionErrorHandler
        Case ECFileIO
            Set GetDefaultHandlerForCategory = New FileNotFoundErrorHandler
        Case Else
            Set GetDefaultHandlerForCategory = New InvalidInputErrorHandler
    End Select
End Function

' ======================
' パブリックメソッド
' ======================
Public Sub RegisterErrorHandler(ByVal errorCode As ErrorCode, ByVal handler As IErrorHandler)
    If Not isInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error Resume Next
    errorHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    
    errorHandlers.Add handler, CStr(errorCode)
    mLock.ReleaseLock
End Sub

Public Sub UnregisterErrorHandler(ByVal errorCode As ErrorCode)
    If Not isInitialized Then Exit Sub
    
    mLock.AcquireLock
    On Error Resume Next
    errorHandlers.Remove CStr(errorCode)
    On Error GoTo 0
    mLock.ReleaseLock
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    ' === エラー処理テスト ===
    Public Sub TestErrorHandling()
        Dim testError As ErrorInfo
        With testError
            .Code = ErrUnexpected
            .Description = "テスト用エラー"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "TestErrorHandling"
            .StackTrace = ""
            .OccurredAt = Now
        End With
        
        mPerformanceMonitor.StartMeasurement "ErrorHandlingTest"
        HandleError testError
        mPerformanceMonitor.EndMeasurement "ErrorHandlingTest"
        
        Debug.Print "テスト実行時間: " & _
                   mPerformanceMonitor.GetMeasurement("ErrorHandlingTest")
    End Sub
    
    ' === 再帰制御テスト ===
    Public Sub TestErrorRecursion()
        Dim i As Long
        For i = 1 To MAX_ERROR_RECURSION + 1
            Dim testError As ErrorInfo
            With testError
                .Code = ErrUnexpected
                .Description = "再帰テスト" & i
                .Category = ECGeneral
                .Source = MODULE_NAME
                .ProcedureName = "TestErrorRecursion"
                .StackTrace = ""
                .OccurredAt = Now
            End With
            
            mPerformanceMonitor.StartMeasurement "RecursionTest_" & i
            HandleError testError
            mPerformanceMonitor.EndMeasurement "RecursionTest_" & i
            
            Debug.Print "再帰テスト" & i & "実行時間: " & _
                       mPerformanceMonitor.GetMeasurement("RecursionTest_" & i)
        Next i
    End Sub
    
    ' === リソース管理テスト ===
    Public Sub TestResourceManagement()
        Dim lockCountBefore As Long
        lockCountBefore = GetActiveLockCount()
        
        Dim testError As ErrorInfo
        With testError
            .Code = ErrUnexpected
            .Description = "リソース管理テスト"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "TestResourceManagement"
            .StackTrace = ""
            .OccurredAt = Now
        End With
        
        mPerformanceMonitor.StartMeasurement "ResourceTest"
        
        On Error Resume Next
        HandleError testError
        
        mPerformanceMonitor.EndMeasurement "ResourceTest"
        
        Dim lockCountAfter As Long
        lockCountAfter = GetActiveLockCount()
        
        Debug.Print "リソース管理テスト実行時間: " & _
                   mPerformanceMonitor.GetMeasurement("ResourceTest")
        
        If lockCountBefore <> lockCountAfter Then
            Debug.Print "警告: リソースリークの可能性があります"
            Debug.Print "ロック数 Before: " & lockCountBefore & _
                       ", After: " & lockCountAfter
        End If
    End Sub
    
    ' === パフォーマンスレポート ===
    Public Function GetPerformanceReport() As String
        If Not mPerformanceMonitor Is Nothing Then
            GetPerformanceReport = mPerformanceMonitor.GetAllMeasurements()
        Else
            GetPerformanceReport = "パフォーマンスモニターが初期化されていません。"
        End If
    End Function
    
    ' === 内部状態取得 ===
    Private Function GetRegisteredHandlerCount() As Long
        mLock.AcquireLock
        GetRegisteredHandlerCount = errorHandlers.Count
        mLock.ReleaseLock
    End Function
    
    Private Sub ClearHandlers()
        mLock.AcquireLock
        Set errorHandlers = New Collection
        mLock.ReleaseLock
    End Sub
    
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    Private Function GetActiveLockCount() As Long
        Dim result As Long
        result = 0
        
        If Not mLock Is Nothing Then
            If mLock.IsLocked Then
                result = result + 1
            End If
        End If
        
        GetActiveLockCount = result
    End Function
#End If

' ======================
' エラーログ出力
' ======================
Private Sub EmergencyErrorLog(ByVal message As String)
    On Error Resume Next
    
    ' イベントログへの出力を試みる
    WriteToEventLog message
    
    ' ファイルへの出力を試みる
    WriteToEmergencyFile message
End Sub

Private Sub WriteToEventLog(ByVal message As String)
    ' Windowsイベントログへの出力
    modWindowsAPI.WriteToEventLog "PDI Error", message, EVENTLOG_ERROR_TYPE
End Sub

Private Sub WriteToEmergencyFile(ByVal message As String)
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    fso.OpenTextFile(Environ$("TEMP") & "\PDI_emergency.log", 8, True).WriteLine Now & ": " & message
End Sub

================
File: modErrorCodes.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modErrorCodes"

' ======================
' エラーコード定義
' ======================
Public Enum ErrorCodeCategory
    ECGeneral = 1000    ' 一般エラー
    ECFileIO = 2000     ' ファイル操作エラー
    ECDatabase = 3000   ' データベースエラー
    ECNetwork = 4000    ' ネットワークエラー
    ECSystem = 5000     ' システムエラー
    ECSecurity = 6000   ' セキュリティエラー
End Enum

Public Enum ErrorCode
    ' 一般エラー (1000-1999)
    ErrUnexpected = vbObjectError + 1000             ' 予期せぬエラー
    ErrInvalidInput = vbObjectError + 1001           ' 無効な入力
    
    ' ファイル操作エラー (2000-2999)
    ErrFileNotFound = vbObjectError + 2000           ' ファイルが見つからない
    ErrFileInvalidFormat = vbObjectError + 2001      ' ファイル形式エラー
    ErrFileAccessDenied = vbObjectError + 2002       ' アクセス拒否
    
    ' データベースエラー (3000-3999)
    ErrDbConnectionFailed = vbObjectError + 3000     ' データベース接続エラー
    ErrDbQueryFailed = vbObjectError + 3001         ' データベースクエリエラー
    
    ' ネットワークエラー (4000-4999)
    ErrNetworkError = vbObjectError + 4000          ' ネットワークエラー
    ErrNetworkTimeout = vbObjectError + 4001        ' タイムアウト
    
    ' システムエラー (5000-5999)
    ErrSystemOutOfMemory = vbObjectError + 5000     ' メモリ不足
    ErrSystemResourceUnavailable = vbObjectError + 5001 ' リソース利用不可
    
    ' セキュリティエラー (6000-6999)
    ErrSecurityAccessDenied = vbObjectError + 6000  ' セキュリティアクセス拒否
    ErrSecurityInvalidCredentials = vbObjectError + 6001 ' 無効な認証情報
    
    ' 暗号化エラー (7000-7099)
    ErrCryptoProviderInitFailed = vbObjectError + 7000  ' 暗号化プロバイダーの初期化失敗
    ErrCryptoNotInitialized = vbObjectError + 7001      ' 暗号化プロバイダー未初期化
    ErrCryptoKeyNotSpecified = vbObjectError + 7002     ' 暗号化キー未指定
    ErrCryptoHashCreateFailed = vbObjectError + 7003    ' ハッシュオブジェクト作成失敗
    ErrCryptoHashDataFailed = vbObjectError + 7004      ' データハッシュ化失敗
    ErrCryptoKeyDerivationFailed = vbObjectError + 7005 ' キー生成失敗
    ErrCryptoEncryptionFailed = vbObjectError + 7006    ' 暗号化失敗
    ErrCryptoDecryptionFailed = vbObjectError + 7007    ' 復号化失敗
    ErrCryptoInvalidKeyLength = vbObjectError + 7008    ' 無効なキー長
    
    ' ロック関連エラー (7100-7199)
    ErrLockMutexCreateFailed = vbObjectError + 7100     ' Mutexの作成失敗
    ErrLockAcquireFailed = vbObjectError + 7101         ' ロックの取得失敗
    ErrLockReleaseFailed = vbObjectError + 7102         ' ロックの解放失敗
    
    ' スタックトレース関連エラー (7200-7299)
    ErrStackTracePushFailed = vbObjectError + 7200      ' スタックトレースへの追加失敗
    ErrStackTracePopFailed = vbObjectError + 7201       ' スタックトレースからの取得失敗
    ErrStackTraceGetFailed = vbObjectError + 7202       ' スタックトレース文字列の生成失敗
    
    ' イベントログ関連エラー (7300-7399)
    ErrEventLogCreateFailed = vbObjectError + 7300      ' イベントログオブジェクトの作成失敗
    ErrEventLogWriteFailed = vbObjectError + 7301       ' イベントログへの書き込み失敗
    ErrEventLogSourceInvalid = vbObjectError + 7302     ' イベントログソースが無効
End Enum

' ======================
' エラーカテゴリ取得
' ======================
Public Function GetErrorCategory(ByVal errCode As ErrorCode) As ErrorCodeCategory
    If errCode >= ECGeneral And errCode < ECFileIO Then
        GetErrorCategory = ECGeneral
    ElseIf errCode >= ECFileIO And errCode < ECDatabase Then
        GetErrorCategory = ECFileIO
    ElseIf errCode >= ECDatabase And errCode < ECNetwork Then
        GetErrorCategory = ECDatabase
    ElseIf errCode >= ECNetwork And errCode < ECSystem Then
        GetErrorCategory = ECNetwork
    ElseIf errCode >= ECSystem And errCode < ECSecurity Then
        GetErrorCategory = ECSystem
    ElseIf errCode >= ECSecurity Then
        GetErrorCategory = ECSecurity
    End If
End Function

================
File: PerformanceCounterImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "PerformanceCounterImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IPerformanceCounter

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "PerformanceCounterImpl"

' ======================
' メンバ変数
' ======================
Private mIsInitialized As Boolean
Private mFrequency As Currency
Private mLock As clsLock
Private mIsHighResolutionSupported As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLock = New clsLock
    
    ' 高分解能タイマーのサポートを確認
    mIsHighResolutionSupported = CheckHighResolutionSupport()
    If mIsHighResolutionSupported Then
        ' 周波数の取得
        If Not modWindowsAPI.QueryPerformanceFrequency(mFrequency) Then
            LogError "パフォーマンスカウンターの周波数取得に失敗しました。"
            mIsHighResolutionSupported = False
        End If
    End If
    
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    mIsInitialized = False
End Sub

' ======================
' IPerformanceCounter実装
' ======================
Private Function IPerformanceCounter_QueryPerformanceCounter(ByRef performanceCount As Currency) As Boolean
    If Not mIsInitialized Then Exit Function
    If Not mIsHighResolutionSupported Then Exit Function
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    IPerformanceCounter_QueryPerformanceCounter = modWindowsAPI.QueryPerformanceCounter(performanceCount)
    
CleanUp:
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    LogError "パフォーマンスカウンターの値取得中にエラーが発生しました: " & Err.Description
    IPerformanceCounter_QueryPerformanceCounter = False
    Resume CleanUp
End Function

Private Function IPerformanceCounter_QueryPerformanceFrequency(ByRef frequency As Currency) As Boolean
    If Not mIsInitialized Then Exit Function
    If Not mIsHighResolutionSupported Then Exit Function
    
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' キャッシュされた周波数を返す
    frequency = mFrequency
    IPerformanceCounter_QueryPerformanceFrequency = True
    
CleanUp:
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    LogError "パフォーマンスカウンターの周波数取得中にエラーが発生しました: " & Err.Description
    IPerformanceCounter_QueryPerformanceFrequency = False
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Function CheckHighResolutionSupport() As Boolean
    On Error GoTo ErrorHandler
    
    Dim counter As Currency
    Dim frequency As Currency
    
    ' カウンターと周波数の取得を試みる
    CheckHighResolutionSupport = (modWindowsAPI.QueryPerformanceCounter(counter) <> 0) And _
                                (modWindowsAPI.QueryPerformanceFrequency(frequency) <> 0)
    Exit Function

ErrorHandler:
    CheckHighResolutionSupport = False
End Function

Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' パブリックメソッド
' ======================
Public Function GetResolution() As Double
    ' 分解能を秒単位で返す
    If mIsHighResolutionSupported And mFrequency <> 0 Then
        GetResolution = 1 / CDbl(mFrequency)
    Else
        GetResolution = 0
    End If
End Function

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = mIsInitialized And _
                       Not (mLock Is Nothing) And _
                       mIsHighResolutionSupported And _
                       mFrequency > 0
    End Function
    
    Public Function GetFrequency() As Currency
        GetFrequency = mFrequency
    End Function
    
    Public Function IsHighResolutionSupported() As Boolean
        IsHighResolutionSupported = mIsHighResolutionSupported
    End Function
    
    Public Function TestTimerConsistency() As Boolean
        ' タイマーの一貫性をテスト
        Dim counter1 As Currency
        Dim counter2 As Currency
        
        If Not IPerformanceCounter_QueryPerformanceCounter(counter1) Then
            TestTimerConsistency = False
            Exit Function
        End If
        
        If Not IPerformanceCounter_QueryPerformanceCounter(counter2) Then
            TestTimerConsistency = False
            Exit Function
        End If
        
        ' 2回目のカウンターが1回目より大きいことを確認
        TestTimerConsistency = (counter2 >= counter1)
    End Function
#End If

================
File: PerformanceMonitorImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "PerformanceMonitorImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IPerformanceMonitor

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "PerformanceMonitorImpl"

' ======================
' 型定義
' ======================
Private Type PerformanceData
    StartTime As Currency
    EndTime As Currency
    ElapsedTime As Double
    MemoryUsage As Currency
    PeakMemoryUsage As Currency
    Description As String
End Type

Private Type PROCESS_MEMORY_COUNTERS
    cb As Long
    PageFaultCount As Long
    PeakWorkingSetSize As Currency
    WorkingSetSize As Currency
    QuotaPeakPagedPoolUsage As Currency
    QuotaPagedPoolUsage As Currency
    QuotaPeakNonPagedPoolUsage As Currency
    QuotaNonPagedPoolUsage As Currency
    PagefileUsage As Currency
    PeakPagefileUsage As Currency
End Type

' ======================
' メンバ変数
' ======================
Private mFrequency As Currency
Private mMeasurements As Collection
Private mIsEnabled As Boolean
Private mCurrentOperation As String
Private mLock As clsLock
Private mConfig As IAppConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    modWindowsAPI.QueryPerformanceFrequency mFrequency
    Set mMeasurements = New Collection
    Set mLock = New clsLock
    Set mConfig = modConfig.GetAppConfig()
    mIsEnabled = mConfig.GetSetting("PerformanceMonitorEnabled", True)
End Sub

Private Sub Class_Terminate()
    Set mMeasurements = Nothing
    Set mLock = Nothing
    Set mConfig = Nothing
End Sub

' ======================
' IPerformanceMonitor実装
' ======================
Private Sub IPerformanceMonitor_Start(ByVal measurementName As String)
    If Not mIsEnabled Then Exit Sub
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim perfData As PerformanceData
    Dim memInfo As PROCESS_MEMORY_COUNTERS
    
    ' 現在の時刻を取得
    modWindowsAPI.QueryPerformanceCounter perfData.StartTime
    
    ' メモリ使用量を取得
    memInfo.cb = LenB(memInfo)
    modWindowsAPI.GetProcessMemoryInfo modWindowsAPI.GetCurrentProcess(), memInfo, LenB(memInfo)
    perfData.MemoryUsage = memInfo.WorkingSetSize
    
    perfData.Description = measurementName
    mCurrentOperation = measurementName
    
    ' コレクションに追加
    mMeasurements.Add perfData, measurementName
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "パフォーマンス測定の開始中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IPerformanceMonitor_Start"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Private Sub IPerformanceMonitor_Stop(ByVal measurementName As String)
    If Not mIsEnabled Then Exit Sub
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim perfData As PerformanceData
    Dim memInfo As PROCESS_MEMORY_COUNTERS
    Dim i As Long
    
    ' 対応する測定データを検索
    For i = mMeasurements.Count To 1 Step -1
        If TypeName(mMeasurements(i)) = "PerformanceData" Then
            perfData = mMeasurements(i)
            If perfData.Description = measurementName Then
                ' 終了時刻を記録
                modWindowsAPI.QueryPerformanceCounter perfData.EndTime
                
                ' メモリ情報を更新
                memInfo.cb = LenB(memInfo)
                modWindowsAPI.GetProcessMemoryInfo modWindowsAPI.GetCurrentProcess(), memInfo, LenB(memInfo)
                perfData.PeakMemoryUsage = memInfo.PeakWorkingSetSize
                
                ' 経過時間を計算（ミリ秒単位）
                perfData.ElapsedTime = (perfData.EndTime - perfData.StartTime) * 1000 / mFrequency
                
                ' コレクションを更新
                mMeasurements.Remove i
                mMeasurements.Add perfData, measurementName
                Exit For
            End If
        End If
    Next i
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "パフォーマンス測定の終了中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IPerformanceMonitor_Stop"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Sub

Private Function IPerformanceMonitor_GetMeasurement(ByVal measurementName As String) As Double
    If Not mIsEnabled Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim perfData As PerformanceData
    perfData = mMeasurements(measurementName)
    IPerformanceMonitor_GetMeasurement = perfData.ElapsedTime
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    If Err.Number = 5 Then ' Item not found in collection
        IPerformanceMonitor_GetMeasurement = 0
    Else
        Dim errDetail As ErrorInfo
        With errDetail
            .Code = ErrUnexpected
            .Description = "パフォーマンス測定データの取得中にエラーが発生しました: " & Err.Description
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "IPerformanceMonitor_GetMeasurement"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
    End If
    mLock.ReleaseLock
End Function

Private Function IPerformanceMonitor_GetAllMeasurements() As Variant
    If Not mIsEnabled Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim results() As Double
    ReDim results(0 To mMeasurements.Count - 1)
    
    Dim i As Long
    Dim perfData As PerformanceData
    For i = 1 To mMeasurements.Count
        perfData = mMeasurements(i)
        results(i - 1) = perfData.ElapsedTime
    Next i
    
    IPerformanceMonitor_GetAllMeasurements = results
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "パフォーマンス測定データの一括取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IPerformanceMonitor_GetAllMeasurements"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
End Function

Private Sub IPerformanceMonitor_Clear()
    mLock.AcquireLock
    Set mMeasurements = New Collection
    mLock.ReleaseLock
End Sub

Private Property Get IPerformanceMonitor_IsEnabled() As Boolean
    IPerformanceMonitor_IsEnabled = mIsEnabled
End Property

Private Sub IPerformanceMonitor_Enable()
    mIsEnabled = True
    mConfig.SetSetting "PerformanceMonitorEnabled", True
End Sub

Private Sub IPerformanceMonitor_Disable()
    mIsEnabled = False
    mConfig.SetSetting "PerformanceMonitorEnabled", False
End Sub

' ======================
' パブリックメソッド
' ======================
Public Function GetDetailedMeasurement(ByVal measurementName As String) As String
    If Not mIsEnabled Then Exit Function
    
    mLock.AcquireLock
    
    Dim perfData As PerformanceData
    Dim result As String
    
    On Error Resume Next
    perfData = mMeasurements(measurementName)
    If Err.Number = 0 Then
        result = "Performance Report for: " & measurementName & vbCrLf & _
                "Elapsed Time: " & Format$(perfData.ElapsedTime, "0.000") & " ms" & vbCrLf & _
                "Initial Memory: " & Format$(perfData.MemoryUsage / 1024 / 1024, "0.00") & " MB" & vbCrLf & _
                "Peak Memory: " & Format$(perfData.PeakMemoryUsage / 1024 / 1024, "0.00") & " MB"
    End If
    On Error GoTo 0
    
    mLock.ReleaseLock
    GetDetailedMeasurement = result
End Function

' ======================
' テストサポート機能（開発環境専用）
' ======================
#If DEBUG Then
    ''' <summary>
    ''' パフォーマンスカウンターの有効性を検証（テスト用）
    ''' </summary>
    Private Function ValidatePerformanceCounter() As Boolean
        Dim counter As Currency
        ValidatePerformanceCounter = (modWindowsAPI.QueryPerformanceCounter(counter) <> 0) And (mFrequency <> 0)
    End Function
    
    ''' <summary>
    ''' 測定データの数を取得（テスト用）
    ''' </summary>
    Private Function GetMeasurementCount() As Long
        mLock.AcquireLock
        GetMeasurementCount = mMeasurements.Count
        mLock.ReleaseLock
    End Function
    
    ''' <summary>
    ''' テスト用の測定データを追加（テスト用）
    ''' </summary>
    Private Sub SimulateMeasurement(ByVal description As String, ByVal elapsedTime As Double)
        mLock.AcquireLock
        Dim perfData As PerformanceData
        perfData.Description = description
        perfData.ElapsedTime = elapsedTime
        perfData.MemoryUsage = 1000000 ' 1MB
        perfData.PeakMemoryUsage = 2000000 ' 2MB
        mMeasurements.Add perfData, description
        mLock.ReleaseLock
    End Sub
    
    ''' <summary>
    ''' 現在の操作名を取得します
    ''' </summary>
    Public Property Get CurrentOperation() As String
        CurrentOperation = mCurrentOperation
    End Property
#End If
