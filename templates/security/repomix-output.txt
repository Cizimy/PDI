This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-27T00:46:00.755Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
clsCriticalSectionLock.cls
clsCrypto.cls
clsLock.cls
clsMutexLock.cls
clsSemaphoreLock.cls
CryptographyImpl.cls
MutexImpl.cls
MutexLock.cls
PBKDF2KeyDerivationStrategy.cls

================================================================
Files
================================================================

================
File: clsCriticalSectionLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsCriticalSectionLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILock

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsCriticalSectionLock"

' ======================
' Win32 API宣言
' ======================
Private Type CRITICAL_SECTION
    DebugInfo As Long
    LockCount As Long
    RecursionCount As Long
    OwningThread As Long
    LockSemaphore As Long
    SpinCount As Long
End Type

Private Declare Sub InitializeCriticalSection Lib "kernel32" (lpCriticalSection As CRITICAL_SECTION)
Private Declare Sub DeleteCriticalSection Lib "kernel32" (lpCriticalSection As CRITICAL_SECTION)
Private Declare Sub EnterCriticalSection Lib "kernel32" (lpCriticalSection As CRITICAL_SECTION)
Private Declare Function TryEnterCriticalSection Lib "kernel32" (lpCriticalSection As CRITICAL_SECTION) As Long
Private Declare Sub LeaveCriticalSection Lib "kernel32" (lpCriticalSection As CRITICAL_SECTION)
Private Declare Function GetTickCount Lib "kernel32" () As Long

' ======================
' メンバ変数
' ======================
Private criticalSection As CRITICAL_SECTION
Private isLocked As Boolean
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    InitializeCriticalSection criticalSection
    isInitialized = True
    isLocked = False
End Sub

Private Sub Class_Terminate()
    If isLocked Then ILock_Release
    If isInitialized Then DeleteCriticalSection criticalSection
End Sub

' ======================
' ILock実装
' ======================
Private Function ILock_Acquire(Optional ByVal timeout As Long = -1) As Boolean
    On Error GoTo ErrorHandler
    
    If Not isInitialized Then Exit Function
    
    ' タイムアウトが指定されていない場合は即座に取得を試みる
    If timeout = -1 Then
        EnterCriticalSection criticalSection
        isLocked = True
        ILock_Acquire = True
        Exit Function
    End If
    
    ' タイムアウト付きの取得
    Dim startTime As Long
    startTime = GetTickCount()
    
    Do
        If TryEnterCriticalSection(criticalSection) <> 0 Then
            isLocked = True
            ILock_Acquire = True
            Exit Function
        End If
        
        ' タイムアウトチェック
        If timeout > 0 Then
            If GetTickCount() - startTime >= timeout Then Exit Do
        End If
        
        DoEvents ' 他のスレッドに実行機会を与える
    Loop
    
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockAcquireFailed
        .Description = "クリティカルセクションの取得に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Acquire"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Function

Private Sub ILock_Release()
    If Not isLocked Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    LeaveCriticalSection criticalSection
    isLocked = False
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockReleaseFailed
        .Description = "クリティカルセクションの解放に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Release"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = isLocked
    End Function
    
    Public Sub ForceRelease()
        If isLocked Then ILock_Release
    End Sub
    
    Public Function IsInitialized() As Boolean
        IsInitialized = isInitialized
    End Function
#End If

================
File: clsCrypto.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsCrypto"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' 定数定義
Private Const MS_ENHANCED_PROV As String = "Microsoft Enhanced Cryptographic Provider v1.0"
Private Const PROV_RSA_FULL As Long = 1
Private Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Private Const CALG_SHA_256 As Long = &H800C
Private Const HP_HASHVAL As Long = 2
Private Const HP_HASHSIZE As Long = 4

' メンバ変数
Private mCryptoProvider As LongPtr
Private mInitialized As Boolean
Private mAesKey As LongPtr
Private mPerformanceMonitor As IPerformanceMonitor
Private mLock As ILock
Private mCryptography As ICryptography
Private mKeyDerivation As IKeyDerivationStrategy

' ======================
' コンストラクタ
' ======================
Public Sub Initialize(ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal lock As ILock, _
                     ByVal cryptography As ICryptography, _
                     ByVal keyDerivation As IKeyDerivationStrategy)
    Set mPerformanceMonitor = performanceMonitor
    Set mLock = lock
    Set mCryptography = cryptography
    Set mKeyDerivation = keyDerivation
    InitializeCrypto
End Sub

Private Sub Class_Initialize()
    ' 依存性は Initialize メソッドで注入される
End Sub

Private Sub Class_Terminate()
    If mInitialized Then
        If mAesKey <> 0 Then
            CryptDestroyKey mAesKey
        End If
        CryptReleaseContext mCryptoProvider, 0
    End If
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
End Sub

' ======================
' 内部メソッド
' ======================
Private Sub InitializeCrypto()
    If mCryptography.CryptAcquireContext(vbNullString, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) Then
        mInitialized = True
    Else
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoProviderInitFailed
            .Description = "暗号化プロバイダーの初期化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "InitializeCrypto"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
End Sub

Private Function DeriveAESKey(ByVal key As String) As Boolean
    On Error GoTo ErrorHandler
    
    mLock.AcquireLock
    
    ' 既存のキーを破棄
    If mAesKey <> 0 Then
        CryptDestroyKey mAesKey
        mAesKey = 0
    End If
    
    ' キー導出戦略を使用してキーを生成
    Dim salt() As Byte
    ReDim salt(0 To 15)  ' 16バイトのソルト
    Dim derivedKey() As Byte
    derivedKey = mKeyDerivation.DeriveKey(key, salt, 10000)
    
    ' 導出されたキーからAESキーを生成
    If Not mCryptography.CryptDeriveKey(CALG_AES_256, CRYPT_EXPORTABLE) Then
        GoTo Cleanup
    End If
    DeriveAESKey = True
    
Cleanup:
    mLock.ReleaseLock
    Exit Function
ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrCryptoKeyDerivationFailed
        .Description = "AESキーの生成に失敗しました。"
        .Category = ECSecurity
        .Source = "clsCrypto"
        .ProcedureName = "DeriveAESKey"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
    DeriveAESKey = False
    Resume Cleanup
End Function

' ======================
' パブリックメソッド
' ======================
Public Function EncryptString(ByVal plainText As String, ByVal key As String) As String
    mPerformanceMonitor.StartMeasurement "String Encryption"
    
    mLock.AcquireLock
    
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' キーの検証
    If Len(key) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoKeyNotSpecified
            .Description = "空の暗号化キーが指定されました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' AESキーの生成
    If Not DeriveAESKey(key) Then
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' データの準備
    Dim dataLen As Long
    Dim blockSize As Long
    blockSize = 16 ' AESブロックサイズ
    
    ' パディングを含むデータ長を計算
    dataLen = Len(plainText)
    If (dataLen Mod blockSize) <> 0 Then
        dataLen = dataLen + (blockSize - (dataLen Mod blockSize))
    End If
    
    ' バッファの準備
    Dim buffer() As Byte
    ReDim buffer(0 To dataLen - 1)
    CopyMemory buffer(0), ByVal StrPtr(plainText), Len(plainText) * 2
    
    ' 暗号化
    If CryptEncrypt(mAesKey, 0, True, 0, buffer(0), dataLen, dataLen) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoEncryptionFailed
            .Description = "データの暗号化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "EncryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Encryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim result As String
    result = Base64Encode(buffer)
    
    mPerformanceMonitor.EndMeasurement "String Encryption"
    mLock.ReleaseLock
    EncryptString = result
End Function

Public Function DecryptString(ByVal cipherText As String, ByVal key As String) As String
    mPerformanceMonitor.StartMeasurement "String Decryption"
    
mLock.AcquireLock
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' キーの検証
    If Len(key) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoKeyNotSpecified
            .Description = "空の暗号化キーが指定されました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' AESキーの生成
    If Not DeriveAESKey(key) Then
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' Base64デコード
    Dim buffer() As Byte
    buffer = Base64Decode(cipherText)
   
     ' データ長の取得
    Dim dataLen As Long
    dataLen = UBound(buffer) - LBound(buffer) + 1
    ' 復号化
    If CryptDecrypt(mAesKey, 0, True, 0, buffer(0), dataLen) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoDecryptionFailed
            .Description = "データの復号化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "DecryptString"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "String Decryption"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim result As String
    result = Left$(StrConv(buffer, vbUnicode), dataLen)
    
    mPerformanceMonitor.EndMeasurement "String Decryption"
    mLock.ReleaseLock
    DecryptString = result
End Function

Public Function GenerateHash(ByVal inputString As String) As String
    mPerformanceMonitor.StartMeasurement "Hash Generation"
    mLock.AcquireLock
    
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    Dim hHash As LongPtr
    Dim hashLen As Long
    Dim hashValue() As Byte
    Dim result As String
    
    ' ハッシュオブジェクトの作成
    If modWindowsAPI.CryptCreateHash(mCryptoProvider, CALG_SHA_256, 0, 0, hHash) = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashCreateFailed
            .Description = "ハッシュオブジェクトの作成に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' データのハッシュ化
    If modWindowsAPI.CryptHashData(hHash, ByVal inputString, Len(inputString), 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "データのハッシュ化に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュサイズの取得
    If modWindowsAPI.CryptGetHashParam(hHash, HP_HASHSIZE, hashLen, 4, 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "ハッシュサイズの取得に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュ値の取得
    ReDim hashValue(0 To hashLen - 1)
    If modWindowsAPI.CryptGetHashParam(hHash, HP_HASHVAL, hashValue(0), hashLen, 0) = 0 Then
        modWindowsAPI.CryptDestroyHash hHash
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoHashDataFailed
            .Description = "ハッシュ値の取得に失敗しました。"
            .Category = ECSecurity
            .Source = "clsCrypto"
            .ProcedureName = "GenerateHash"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        mPerformanceMonitor.EndMeasurement "Hash Generation"
        mLock.ReleaseLock
        Exit Function
    End If
    
    ' ハッシュオブジェクトの破棄
    modWindowsAPI.CryptDestroyHash hHash
    
    ' バイト配列を16進数文字列に変換
    result = ""
    Dim i As Long
    For i = 0 To hashLen - 1
        result = result & Right$("0" & Hex$(hashValue(i)), 2)
    Next i
    
    mPerformanceMonitor.EndMeasurement "Hash Generation"
    mLock.ReleaseLock
    GenerateHash = result
    
End Function

' ======================
' ユーティリティメソッド
' ======================
Private Function Base64Encode(ByVal text As String) As String
    Dim xmlDoc As Object
    Dim xmlNode As Object
    
    Set xmlDoc = CreateObject("MSXML2.DOMDocument")
    Set xmlNode = xmlDoc.createElement("b64")
    
    xmlNode.DataType = "bin.base64"
    xmlNode.nodeTypedValue = StringToBytes(text)
    
    Base64Encode = xmlNode.text
    
    Set xmlNode = Nothing
    Set xmlDoc = Nothing
End Function

Private Function Base64Decode(ByVal base64 As String) As String
    Dim xmlDoc As Object
    Dim xmlNode As Object
    
    Set xmlDoc = CreateObject("MSXML2.DOMDocument")
    Set xmlNode = xmlDoc.createElement("b64")
    
    xmlNode.DataType = "bin.base64"
    xmlNode.text = base64
    
    Base64Decode = BytesToString(xmlNode.nodeTypedValue)
    
    Set xmlNode = Nothing
    Set xmlDoc = Nothing
End Function

Private Function StringToBytes(ByVal text As String) As Byte()
    Dim bytes() As Byte
    bytes = text
    StringToBytes = bytes
End Function

Private Function BytesToString(ByRef bytes() As Byte) As String
    BytesToString = bytes
End Function

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    Private Function ValidateProvider() As Boolean
        ' 暗号化プロバイダーの状態を検証（テスト用）
        ValidateProvider = mInitialized And mCryptoProvider <> 0
    End Function
    
    Private Sub ResetProvider()
        ' 暗号化プロバイダーをリセット（テスト用）
        If mInitialized Then
            CryptReleaseContext mCryptoProvider, 0
            mInitialized = False
        End If
        InitializeCrypto
    End Sub
#End If

================
File: clsLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' 定数定義
Private Const INFINITE As Long = -1
Private Const WAIT_OBJECT_0 As Long = 0
Private Const ERROR_ALREADY_EXISTS As Long = 183&
Private Const MUTEX_NAME As String = "Global\MyApp_ModCommon_Mutex"

' メンバ変数
Private mMutexHandle As LongPtr
Private mIsLocked As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mMutexHandle = modWindowsAPI.CreateMutex(0&, 0&, MUTEX_NAME)
    mIsLocked = False
End Sub

Private Sub Class_Terminate()
    If mIsLocked Then modWindowsAPI.ReleaseMutex mMutexHandle
    If mMutexHandle <> 0 Then modWindowsAPI.CloseHandle mMutexHandle
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub AcquireLock()
    If mMutexHandle = 0 Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrLockMutexCreateFailed
            .Description = "Mutexの作成に失敗しました。"
            .Category = ECSystem
            .Source = "clsLock"
            .ProcedureName = "AcquireLock"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
    
    ' ロックの取得を試みる
    Dim result As Long
    result = modWindowsAPI.WaitForSingleObject(mMutexHandle, INFINITE)
    
    If result = WAIT_OBJECT_0 Then
        mIsLocked = True
    Else
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrLockAcquireFailed
            .Description = "ロックの取得に失敗しました。"
            .Category = ECSystem
            .Source = "clsLock"
            .ProcedureName = "AcquireLock"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
End Sub

Public Sub ReleaseLock()
    If mIsLocked Then
        If modWindowsAPI.ReleaseMutex(mMutexHandle) = 0 Then
            Dim errInfo As ErrorInfo
            With errInfo
                .Code = ErrLockReleaseFailed
                .Description = "ロックの解放に失敗しました。"
                .Category = ECSystem
                .Source = "clsLock"
                .ProcedureName = "ReleaseLock"
                .StackTrace = modStackTrace.GetStackTrace()
                .OccurredAt = Now
            End With
            modError.HandleError errInfo
        End If
        mIsLocked = False
    End If
End Sub

' ======================
' プロパティ
' ======================
Public Property Get IsLocked() As Boolean
    IsLocked = mIsLocked
End Property

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = (mMutexHandle <> 0)
    End Function
    
    Public Sub ForceRelease()
        If mMutexHandle <> 0 Then
            If mIsLocked Then modWindowsAPI.ReleaseMutex mMutexHandle
            modWindowsAPI.CloseHandle mMutexHandle
            mMutexHandle = 0
            mIsLocked = False
        End If
    End Sub
#End If

================
File: clsMutexLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsMutexLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILock

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsMutexLock"

' ======================
' メンバ変数
' ======================
Private mutex As IMutex
Private mutexName As String
Private isLocked As Boolean
Private config As IAppConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mutex = New MutexImpl
    Set config = modConfig.GetAppConfig
    ' ミューテックス名を設定から取得
    mutexName = config.GetSetting("MutexName", "Global\MyApp_ModCommon_Mutex")
    isLocked = False
End Sub

Private Sub Class_Terminate()
    If isLocked Then ILock_Release
    Set mutex = Nothing
    Set config = Nothing
End Sub

' ======================
' ILock実装
' ======================
Private Function ILock_Acquire(Optional ByVal timeout As Long = -1) As Boolean
    On Error GoTo ErrorHandler
    
    ' ミューテックスの作成
    If Not mutex.CreateMutex(False, mutexName) Then
        LogError "ミューテックスの作成に失敗しました。"
        Exit Function
    End If
    
    ' ロックの取得を試みる
    If mutex.WaitForSingleObject(timeout) Then
        isLocked = True
        ILock_Acquire = True
    End If
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockAcquireFailed
        .Description = "ロックの取得に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Acquire"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Function

Private Sub ILock_Release()
    If Not isLocked Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    If Not mutex.ReleaseMutex() Then
        LogError "ロックの解放に失敗しました。"
    End If
    isLocked = False
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockReleaseFailed
        .Description = "ロックの解放に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Release"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub Configure(ByVal newMutexName As String)
    mutexName = newMutexName
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = isLocked
    End Function
    
    Public Property Get MutexName() As String
        MutexName = mutexName
    End Property
    
    Public Sub ForceRelease()
        If isLocked Then ILock_Release
    End Sub
#End If

================
File: clsSemaphoreLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsSemaphoreLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILock

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "clsSemaphoreLock"

' ======================
' Win32 API宣言
' ======================
Private Declare Function CreateSemaphore Lib "kernel32" Alias "CreateSemaphoreA" ( _
    ByVal lpSemaphoreAttributes As Long, _
    ByVal lInitialCount As Long, _
    ByVal lMaximumCount As Long, _
    ByVal lpName As String) As Long

Private Declare Function ReleaseSemaphore Lib "kernel32" ( _
    ByVal hSemaphore As Long, _
    ByVal lReleaseCount As Long, _
    ByRef lpPreviousCount As Long) As Long

Private Declare Function WaitForSingleObject Lib "kernel32" ( _
    ByVal hHandle As Long, _
    ByVal dwMilliseconds As Long) As Long

Private Declare Function CloseHandle Lib "kernel32" ( _
    ByVal hObject As Long) As Long

' ======================
' 定数定義
' ======================
Private Const WAIT_OBJECT_0 As Long = 0
Private Const WAIT_TIMEOUT As Long = &H102&
Private Const INFINITE As Long = -1

' ======================
' メンバ変数
' ======================
Private semaphoreHandle As Long
Private semaphoreName As String
Private isLocked As Boolean
Private config As IAppConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set config = modConfig.GetAppConfig
    semaphoreName = config.GetSetting("SemaphoreName", "Global\MyApp_ModCommon_Semaphore")
    isLocked = False
    InitializeSemaphore
End Sub

Private Sub Class_Terminate()
    If isLocked Then ILock_Release
    If semaphoreHandle <> 0 Then CloseHandle semaphoreHandle
    Set config = Nothing
End Sub

' ======================
' ILock実装
' ======================
Private Function ILock_Acquire(Optional ByVal timeout As Long = -1) As Boolean
    On Error GoTo ErrorHandler
    
    If semaphoreHandle = 0 Then
        If Not InitializeSemaphore Then Exit Function
    End If
    
    Dim waitResult As Long
    waitResult = WaitForSingleObject(semaphoreHandle, timeout)
    
    Select Case waitResult
        Case WAIT_OBJECT_0
            isLocked = True
            ILock_Acquire = True
        Case WAIT_TIMEOUT
            ' タイムアウト - 何もしない
        Case Else
            LogError "セマフォの取得に失敗しました。"
    End Select
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockAcquireFailed
        .Description = "セマフォの取得に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Acquire"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Function

Private Sub ILock_Release()
    If Not isLocked Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    Dim previousCount As Long
    If ReleaseSemaphore(semaphoreHandle, 1, previousCount) = 0 Then
        LogError "セマフォの解放に失敗しました。"
    Else
        isLocked = False
    End If
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockReleaseFailed
        .Description = "セマフォの解放に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Release"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub Configure(ByVal newSemaphoreName As String)
    If isLocked Then ILock_Release
    If semaphoreHandle <> 0 Then CloseHandle semaphoreHandle
    semaphoreName = newSemaphoreName
    InitializeSemaphore
End Sub

' ======================
' プライベートメソッド
' ======================
Private Function InitializeSemaphore() As Boolean
    semaphoreHandle = CreateSemaphore(0&, 1, 1, semaphoreName)
    InitializeSemaphore = (semaphoreHandle <> 0)
End Function

Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = isLocked
    End Function
    
    Public Property Get SemaphoreName() As String
        SemaphoreName = semaphoreName
    End Property
    
    Public Sub ForceRelease()
        If isLocked Then ILock_Release
    End Sub
#End If

================
File: CryptographyImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CryptographyImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ICryptography

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "CryptographyImpl"

' ======================
' メンバ変数
' ======================
Private mCryptoProvider As LongPtr
Private mHash As LongPtr
Private mKey As LongPtr
Private mIsInitialized As Boolean
Private mPerformanceMonitor As clsPerformanceMonitor
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mCryptoProvider = 0
    mHash = 0
    mKey = 0
    Set mPerformanceMonitor = New clsPerformanceMonitor
    Set mLock = New clsLock
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    CleanupResources
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
    mIsInitialized = False
End Sub

' ======================
' ICryptography実装
' ======================
Private Function ICryptography_CryptAcquireContext(ByVal container As String, _
                                                 ByVal provider As String, _
                                                 ByVal provType As Long, _
                                                 ByVal flags As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptAcquireContext"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' 既存のプロバイダをクリーンアップ
    If mCryptoProvider <> 0 Then
        modWindowsAPI.CryptReleaseContext mCryptoProvider, 0
        mCryptoProvider = 0
    End If
    
    ' 新しいプロバイダを取得
    Dim result As Boolean
    result = (modWindowsAPI.CryptAcquireContext(mCryptoProvider, container, provider, provType, flags) <> 0)
    
    ICryptography_CryptAcquireContext = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptAcquireContext"
    Exit Function

ErrorHandler:
    LogError "暗号化プロバイダの取得中にエラーが発生しました: " & Err.Description
    ICryptography_CryptAcquireContext = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptCreateHash(ByVal algorithm As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mCryptoProvider = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptCreateHash"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' 既存のハッシュをクリーンアップ
    If mHash <> 0 Then
        modWindowsAPI.CryptDestroyHash mHash
        mHash = 0
    End If
    
    ' 新しいハッシュを作成
    Dim result As Boolean
    result = (modWindowsAPI.CryptCreateHash(mCryptoProvider, algorithm, 0, 0, mHash) <> 0)
    
    ICryptography_CryptCreateHash = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptCreateHash"
    Exit Function

ErrorHandler:
    LogError "ハッシュの作成中にエラーが発生しました: " & Err.Description
    ICryptography_CryptCreateHash = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptHashData(ByRef data As Any, _
                                           ByVal dataLen As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mHash = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptHashData"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptHashData(mHash, data, dataLen, 0) <> 0)
    
    ICryptography_CryptHashData = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptHashData"
    Exit Function

ErrorHandler:
    LogError "データのハッシュ化中にエラーが発生しました: " & Err.Description
    ICryptography_CryptHashData = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptDeriveKey(ByVal algorithm As Long, _
                                            ByVal flags As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mHash = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptDeriveKey"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    ' 既存の鍵をクリーンアップ
    If mKey <> 0 Then
        modWindowsAPI.CryptDestroyKey mKey
        mKey = 0
    End If
    
    ' 新しい鍵を生成
    Dim result As Boolean
    result = (modWindowsAPI.CryptDeriveKey(mCryptoProvider, algorithm, mHash, flags, mKey) <> 0)
    
    ICryptography_CryptDeriveKey = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptDeriveKey"
    Exit Function

ErrorHandler:
    LogError "鍵の生成中にエラーが発生しました: " & Err.Description
    ICryptography_CryptDeriveKey = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptEncrypt(ByRef data As Any, _
                                          ByRef dataLen As Long, _
                                          ByVal bufLen As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mKey = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptEncrypt"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptEncrypt(mKey, 0, True, 0, data, dataLen, bufLen) <> 0)
    
    ICryptography_CryptEncrypt = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptEncrypt"
    Exit Function

ErrorHandler:
    LogError "データの暗号化中にエラーが発生しました: " & Err.Description
    ICryptography_CryptEncrypt = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptDecrypt(ByRef data As Any, _
                                          ByRef dataLen As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mKey = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptDecrypt"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptDecrypt(mKey, 0, True, 0, data, dataLen) <> 0)
    
    ICryptography_CryptDecrypt = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptDecrypt"
    Exit Function

ErrorHandler:
    LogError "データの復号化中にエラーが発生しました: " & Err.Description
    ICryptography_CryptDecrypt = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptDestroyKey() As Boolean
    If Not mIsInitialized Then Exit Function
    If mKey = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptDestroyKey"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptDestroyKey(mKey) <> 0)
    If result Then mKey = 0
    
    ICryptography_CryptDestroyKey = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptDestroyKey"
    Exit Function

ErrorHandler:
    LogError "鍵の破棄中にエラーが発生しました: " & Err.Description
    ICryptography_CryptDestroyKey = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptDestroyHash() As Boolean
    If Not mIsInitialized Then Exit Function
    If mHash = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptDestroyHash"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptDestroyHash(mHash) <> 0)
    If result Then mHash = 0
    
    ICryptography_CryptDestroyHash = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptDestroyHash"
    Exit Function

ErrorHandler:
    LogError "ハッシュの破棄中にエラーが発生しました: " & Err.Description
    ICryptography_CryptDestroyHash = False
    Resume CleanUp
End Function

Private Function ICryptography_CryptReleaseContext() As Boolean
    If Not mIsInitialized Then Exit Function
    If mCryptoProvider = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CryptReleaseContext"
    mLock.AcquireLock
    
    On Error GoTo ErrorHandler
    
    Dim result As Boolean
    result = (modWindowsAPI.CryptReleaseContext(mCryptoProvider, 0) <> 0)
    If result Then mCryptoProvider = 0
    
    ICryptography_CryptReleaseContext = result
    
CleanUp:
    mLock.ReleaseLock
    mPerformanceMonitor.EndMeasurement "CryptReleaseContext"
    Exit Function

ErrorHandler:
    LogError "暗号化コンテキストの解放中にエラーが発生しました: " & Err.Description
    ICryptography_CryptReleaseContext = False
    Resume CleanUp
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub CleanupResources()
    If mKey <> 0 Then
        modWindowsAPI.CryptDestroyKey mKey
        mKey = 0
    End If
    
    If mHash <> 0 Then
        modWindowsAPI.CryptDestroyHash mHash
        mHash = 0
    End If
    
    If mCryptoProvider <> 0 Then
        modWindowsAPI.CryptReleaseContext mCryptoProvider, 0
        mCryptoProvider = 0
    End If
End Sub

Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSecurity
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = mIsInitialized And _
                       Not (mPerformanceMonitor Is Nothing) And _
                       Not (mLock Is Nothing)
    End Function
    
    Public Sub ForceCleanup()
        CleanupResources
    End Sub
    
    Public Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
#End If

================
File: MutexImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "MutexImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IMutex

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "MutexImpl"

' ======================
' プライベート変数
' ======================
Private mMutexHandle As LongPtr
Private mIsInitialized As Boolean
Private mPerformanceMonitor As clsPerformanceMonitor

' ======================
' Win32 APIの再定義
' ======================
Private Const WAIT_OBJECT_0 As Long = 0
Private Const WAIT_FAILED As Long = &HFFFFFFFF
Private Const WAIT_ABANDONED As Long = &H80
Private Const ERROR_ALREADY_EXISTS As Long = 183&

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    mMutexHandle = 0
    Set mPerformanceMonitor = New clsPerformanceMonitor
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    If mMutexHandle <> 0 Then
        modWindowsAPI.CloseHandle mMutexHandle
        mMutexHandle = 0
    End If
    Set mPerformanceMonitor = Nothing
    mIsInitialized = False
End Sub

' ======================
' IMutex実装
' ======================
Private Function IMutex_CreateMutex(ByVal initialOwner As Boolean, ByVal name As String) As Boolean
    If Not mIsInitialized Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "CreateMutex"
    On Error GoTo ErrorHandler
    
    ' 既存のハンドルをクリーンアップ
    If mMutexHandle <> 0 Then
        modWindowsAPI.CloseHandle mMutexHandle
        mMutexHandle = 0
    End If
    
    ' ミューテックスの作成
    mMutexHandle = modWindowsAPI.CreateMutex(0&, IIf(initialOwner, 1&, 0&), name)
    
    If mMutexHandle = 0 Then
        LogError "ミューテックスの作成に失敗しました。"
        IMutex_CreateMutex = False
    Else
        IMutex_CreateMutex = True
    End If
    
    mPerformanceMonitor.EndMeasurement "CreateMutex"
    Exit Function

ErrorHandler:
    LogError "ミューテックスの作成中にエラーが発生しました: " & Err.Description
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "CreateMutex"
    End If
    IMutex_CreateMutex = False
End Function

Private Function IMutex_ReleaseMutex() As Boolean
    If Not mIsInitialized Then Exit Function
    If mMutexHandle = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "ReleaseMutex"
    On Error GoTo ErrorHandler
    
    IMutex_ReleaseMutex = (modWindowsAPI.ReleaseMutex(mMutexHandle) <> 0)
    
    mPerformanceMonitor.EndMeasurement "ReleaseMutex"
    Exit Function

ErrorHandler:
    LogError "ミューテックスの解放中にエラーが発生しました: " & Err.Description
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ReleaseMutex"
    End If
    IMutex_ReleaseMutex = False
End Function

Private Function IMutex_WaitForSingleObject(ByVal timeoutMilliseconds As Long) As Boolean
    If Not mIsInitialized Then Exit Function
    If mMutexHandle = 0 Then Exit Function
    
    mPerformanceMonitor.StartMeasurement "WaitForSingleObject"
    On Error GoTo ErrorHandler
    
    Dim result As Long
    result = modWindowsAPI.WaitForSingleObject(mMutexHandle, timeoutMilliseconds)
    
    Select Case result
        Case WAIT_OBJECT_0, WAIT_ABANDONED
            IMutex_WaitForSingleObject = True
        Case Else
            IMutex_WaitForSingleObject = False
    End Select
    
    mPerformanceMonitor.EndMeasurement "WaitForSingleObject"
    Exit Function

ErrorHandler:
    LogError "ミューテックスの待機中にエラーが発生しました: " & Err.Description
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "WaitForSingleObject"
    End If
    IMutex_WaitForSingleObject = False
End Function

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function GetMutexHandle() As LongPtr
        GetMutexHandle = mMutexHandle
    End Function
    
    Public Function IsValid() As Boolean
        IsValid = (mMutexHandle <> 0)
    End Function
    
    Public Sub ForceRelease()
        If mMutexHandle <> 0 Then
            modWindowsAPI.CloseHandle mMutexHandle
            mMutexHandle = 0
        End If
    End Sub
    
    Public Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
#End If

================
File: MutexLock.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "MutexLock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ILock

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "MutexLock"

' ======================
' メンバ変数
' ======================
Private mMutex As IMutex
Private mMutexName As String
Private mIsLocked As Boolean
Private mConfig As IAppConfig

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mMutex = New MutexImpl
    Set mConfig = modConfig.GetAppConfig
    ' ミューテックス名を設定から取得
    mMutexName = mConfig.GetSetting("MutexName", "Global\MyApp_ModCommon_Mutex")
    mIsLocked = False
End Sub

Private Sub Class_Terminate()
    If mIsLocked Then ILock_Release
    Set mMutex = Nothing
    Set mConfig = Nothing
End Sub

' ======================
' ILock実装
' ======================
Private Function ILock_Acquire(Optional ByVal timeout As Long = -1) As Boolean
    On Error GoTo ErrorHandler
    
    ' ミューテックスの作成
    If Not mMutex.CreateMutex(False, mMutexName) Then
        LogError "ミューテックスの作成に失敗しました。"
        Exit Function
    End If
    
    ' ロックの取得を試みる
    If mMutex.WaitForSingleObject(timeout) Then
        mIsLocked = True
        ILock_Acquire = True
    End If
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockAcquireFailed
        .Description = "ロックの取得に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Acquire"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Function

Private Sub ILock_Release()
    If Not mIsLocked Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    If Not mMutex.ReleaseMutex() Then
        LogError "ロックの解放に失敗しました。"
    End If
    mIsLocked = False
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrLockReleaseFailed
        .Description = "ロックの解放に失敗しました: " & Err.Description
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "ILock_Release"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub Configure(ByVal mutexName As String)
    mMutexName = mutexName
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateLockState() As Boolean
        ValidateLockState = mIsLocked
    End Function
    
    Public Property Get MutexName() As String
        MutexName = mMutexName
    End Property
    
    Public Sub ForceRelease()
        If mIsLocked Then ILock_Release
    End Sub
#End If

================
File: PBKDF2KeyDerivationStrategy.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "PBKDF2KeyDerivationStrategy"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IKeyDerivationStrategy

' 定数定義
Private Const MS_ENHANCED_PROV As String = "Microsoft Enhanced Cryptographic Provider v1.0"
Private Const PROV_RSA_FULL As Long = 1
Private Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Private Const CALG_SHA_256 As Long = &H800C
Private Const CALG_AES_256 As Long = &H6610

' メンバ変数
Private mCryptoProvider As LongPtr
Private mInitialized As Boolean

Private Sub Class_Initialize()
    InitializeCrypto
End Sub

Private Sub Class_Terminate()
    If mInitialized Then
        CryptReleaseContext mCryptoProvider, 0
    End If
End Sub

Private Sub InitializeCrypto()
    If modWindowsAPI.CryptAcquireContext(mCryptoProvider, vbNullString, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) <> 0 Then
        mInitialized = True
    Else
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoProviderInitFailed
            .Description = "暗号化プロバイダーの初期化に失敗しました。"
            .Category = ECSecurity
            .Source = "PBKDF2KeyDerivationStrategy"
            .ProcedureName = "InitializeCrypto"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
    End If
End Sub

Private Function IKeyDerivationStrategy_DeriveKey(ByVal password As String, ByRef salt As Variant, ByVal iterations As Long) As Byte()
    If Not mInitialized Then
        Dim errInfo As ErrorInfo
        With errInfo
            .Code = ErrCryptoNotInitialized
            .Description = "暗号化プロバイダーが初期化されていません。"
            .Category = ECSecurity
            .Source = "PBKDF2KeyDerivationStrategy"
            .ProcedureName = "DeriveKey"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errInfo
        Exit Function
    End If
    
    ' ハッシュオブジェクトの作成
    Dim hHash As LongPtr
    If CryptCreateHash(mCryptoProvider, CALG_SHA_256, 0, 0, hHash) = 0 Then
        RaiseError ErrCryptoHashCreateFailed, "ハッシュオブジェクトの作成に失敗しました。"
        Exit Function
    End If
    
    ' パスワードとソルトを結合
    Dim combinedData() As Byte
    ReDim combinedData(0 To Len(password) + UBound(salt) + 1)
    CopyMemory combinedData(0), ByVal StrPtr(password), Len(password) * 2
    CopyMemory combinedData(Len(password)), salt(0), UBound(salt) + 1
    
    ' 反復処理でキーを生成
    Dim i As Long
    For i = 1 To iterations
        If CryptHashData(hHash, combinedData(0), UBound(combinedData) + 1, 0) = 0 Then
            CryptDestroyHash hHash
            RaiseError ErrCryptoHashDataFailed, "データのハッシュ化に失敗しました。"
            Exit Function
        End If
    Next i
    
    ' ハッシュ値の取得
    Dim hashLen As Long
    If CryptGetHashParam(hHash, HP_HASHSIZE, hashLen, 4, 0) = 0 Then
        CryptDestroyHash hHash
        RaiseError ErrCryptoHashDataFailed, "ハッシュサイズの取得に失敗しました。"
        Exit Function
    End If
    
    Dim derivedKey() As Byte
    ReDim derivedKey(0 To hashLen - 1)
    If CryptGetHashParam(hHash, HP_HASHVAL, derivedKey(0), hashLen, 0) = 0 Then
        CryptDestroyHash hHash
        RaiseError ErrCryptoHashDataFailed, "ハッシュ値の取得に失敗しました。"
        Exit Function
    End If
    
    ' ハッシュオブジェクトの破棄
    CryptDestroyHash hHash
    
    IKeyDerivationStrategy_DeriveKey = derivedKey
End Function

Private Sub RaiseError(ByVal errorCode As Long, ByVal description As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = errorCode
        .Description = description
        .Category = ECSecurity
        .Source = "PBKDF2KeyDerivationStrategy"
        .ProcedureName = "DeriveKey"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub
