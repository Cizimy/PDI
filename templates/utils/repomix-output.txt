This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-27T00:46:16.815Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
clsCallStack.cls
modCommon.bas
modDateUtils.bas
modMathUtils.bas
modStackTrace.bas
modStringUtils.bas
modWindowsAPI.bas
ModWindowsAPIConverter.cls
MsgBoxNotifier.cls
QueueImpl.cls
SleepImpl.cls
StackImpl.cls
StackTraceImpl.cls
VBScriptRegexEngine.cls

================================================================
Files
================================================================

================
File: clsCallStack.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsCallStack"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

'==========================
' モジュール情報
'==========================
Private Const MODULE_NAME As String = "clsCallStack"

'==========================
' メンバ変数
'==========================
Private mStackTrace As IStackTrace
Private mLock As clsLock

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    Set mStackTrace = New StackTraceImpl
    Set mLock = New clsLock
End Sub

Private Sub Class_Terminate()
    Set mStackTrace = Nothing
    Set mLock = Nothing
End Sub

'==========================
' パブリックメソッド
'==========================

''' <summary>
''' 呼び出し履歴にエントリを追加
''' </summary>
''' <param name="ModuleName">モジュール名</param>
''' <param name="ProcedureName">プロシージャ名</param>
''' <remarks>
''' スタックトレースの最大深さを超えた場合、エラーを発生させずに無視します
''' </remarks>
Public Sub Push(ByVal ModuleName As String, ByVal ProcedureName As String)
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    mStackTrace.PushStackEntry ModuleName, ProcedureName
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "Push操作中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "Push"
        .StackTrace = mStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Sub

''' <summary>
''' 呼び出し履歴から最後のエントリを取得して削除
''' </summary>
''' <returns>最後に追加されたプロシージャの完全修飾名、またはスタックが空の場合は空文字列</returns>
Public Function Pop() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Pop = mStackTrace.PopStackEntry()
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "Pop操作中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "Pop"
        .StackTrace = mStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Function

''' <summary>
''' 現在のスタックトレースを文字列として取得
''' </summary>
''' <returns>スタックトレースの文字列表現</returns>
Public Property Get StackTrace() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    StackTrace = mStackTrace.GetStackTrace()
    
    mLock.ReleaseLock
    Exit Property

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = modErrorCodes.ErrUnexpected
        .Description = "スタックトレース取得中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "StackTrace"
        .StackTrace = mStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    mLock.ReleaseLock
    Resume Next
End Property

''' <summary>
''' スタック内のエントリ数を取得
''' </summary>
''' <returns>現在のスタックの深さ</returns>
Public Property Get Count() As Long
    Count = mStackTrace.StackDepth
End Property

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Sub SetStackTrace(ByVal stackTrace As IStackTrace)
        Set mStackTrace = stackTrace
    End Sub
    
    Public Function GetStackTrace() As IStackTrace
        Set GetStackTrace = mStackTrace
    End Function
#End If

================
File: modCommon.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modCommon"

' ======================
' アプリケーション定数
' ======================
Public Const APPLICATION_NAME As String = "MyApp"
Public Const APPLICATION_VERSION As String = "1.0.0"
Public Const DEFAULT_LOG_FILE As String = "app.log"
Public Const DEFAULT_DATE_FORMAT As String = "yyyy/MM/dd"
Public Const DEFAULT_DATETIME_FORMAT As String = "yyyy/MM/dd HH:nn:ss"
Public Const MAX_RETRY_COUNT As Integer = 3

' ======================
' ログ関連の定義
' ======================
Public Enum LogLevel
    LevelDebug
    LevelInfo
    LevelWarning
    LevelError
    LevelFatal
End Enum

Public Enum LogDestination
    DestNone
    DestFile
    DestDatabase
    DestEventLog
    DestConsole
    DestEmail
End Enum

' ======================
' セキュリティレベル
' ======================
Public Enum SecurityLevel
    LevelLow = 1
    LevelMedium = 2
    LevelHigh = 3
    LevelExtreme = 4
End Enum

' ======================
' ファイルアクセスモード
' ======================
Public Enum FileAccessMode
    ModeReadOnly = 1
    ModeReadWrite = 2
    ModeAppend = 3
    ModeExclusive = 4
End Enum

' ======================
' 型定義
' ======================
Public Type ErrorInfo
    Code As ErrorCode
    Category As ErrorCodeCategory
    Description As String
    Source As String
    ProcedureName As String
    StackTrace As String
    OccurredAt As Date
    AdditionalInfo As String
End Type

Public Type FileInfo
    Name As String
    Path As String
    Size As Long
    Created As Date
    LastModified As Date
    FileType As String
    Attributes As Long
End Type

' ======================
' モジュール変数
' ======================
Private mPerformanceMonitor As clsPerformanceMonitor
Private mIsInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = mIsInitialized
End Property

Public Sub InitializeModule()
    If mIsInitialized Then Exit Sub
    
    ' スタックトレースモジュールの初期化
    modStackTrace.InitializeModule
    
    ' パフォーマンスモニターの初期化
    Set mPerformanceMonitor = New clsPerformanceMonitor
    Set mLock = New clsLock
    
    ' 設定の初期化
    modConfig.InitializeModule
    
    mIsInitialized = True
End Sub

Public Sub TerminateModule()
    If Not mIsInitialized Then Exit Sub
    
    ' 設定の終了処理
    modConfig.TerminateModule
    
    ' パフォーマンスモニターの解放
    Set mPerformanceMonitor = Nothing
    Set mLock = Nothing
    
    mIsInitialized = False
End Sub

' ======================
' エラーハンドリング
' ======================
Public Sub HandleError(ByRef errInfo As ErrorInfo)
    If Not mIsInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    ' パフォーマンスモニタリング開始
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.StartMeasurement "ErrorHandling_" & errInfo.Code
    End If
    
    ' エラー情報の補完
    With errInfo
        If .OccurredAt = #12:00:00 AM# Then .OccurredAt = Now
        If .Category = 0 Then .Category = modErrorCodes.GetErrorCategory(.Code)
        If Len(.StackTrace) = 0 Then .StackTrace = modStackTrace.GetStackTrace()
    End With
    
    ' エラー処理をmodErrorに委譲
    modError.HandleError errInfo
    
    ' パフォーマンスモニタリング終了
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ErrorHandling_" & errInfo.Code
    End If
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    If Not mLock Is Nothing Then mLock.ReleaseLock
    Err.Raise Err.Number, Err.Source, "HandleError中にエラーが発生しました: " & Err.Description
End Sub

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    Private Sub ResetModule()
        ' モジュールの状態を初期化（テスト用）
        TerminateModule
        InitializeModule
    End Sub
    
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        ' パフォーマンスモニターの参照を取得（テスト用）
        Set GetPerformanceMonitor = mPerformanceMonitor
    End Function
#End If

================
File: modDateUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modDateUtils"

' ======================
' 定数定義
' ======================
Private Const DEFAULT_DATE_FORMAT As String = "yyyy/mm/dd"
Private Const DEFAULT_TIME_FORMAT As String = "hh:nn:ss"
Private Const DEFAULT_DATETIME_FORMAT As String = "yyyy/mm/dd hh:nn:ss"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 日付の妥当性を確認します
''' </summary>
''' <param name="testDate">確認する日付</param>
''' <returns>有効な日付の場合True</returns>
Public Function IsValidDate(ByVal testDate As Variant) As Boolean
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "IsValidDate"
    End If
    
    On Error Resume Next
    IsValidDate = IsDate(testDate)
    On Error GoTo 0
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "IsValidDate"
    End If
End Function

''' <summary>
''' 日付に指定された期間を加算します
''' </summary>
''' <param name="interval">期間の単位</param>
''' <param name="number">加算する数</param>
''' <param name="dateValue">対象の日付</param>
''' <returns>加算後の日付</returns>
Public Function DateAdd(ByVal interval As String, ByVal number As Double, _
                      ByVal dateValue As Date) As Date
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "DateAdd"
    End If
    
    On Error GoTo ErrorHandler
    
    DateAdd = VBA.DateAdd(interval, number, dateValue)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateAdd"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "日付の加算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "DateAdd"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateAdd"
    End If
    DateAdd = dateValue
End Function

''' <summary>
''' 2つの日付の差分を計算します
''' </summary>
''' <param name="interval">期間の単位</param>
''' <param name="date1">日付1</param>
''' <param name="date2">日付2</param>
''' <returns>日付の差分</returns>
Public Function DateDiff(ByVal interval As String, ByVal date1 As Date, _
                       ByVal date2 As Date) As Long
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "DateDiff"
    End If
    
    On Error GoTo ErrorHandler
    
    DateDiff = VBA.DateDiff(interval, date1, date2)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateDiff"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "日付の差分計算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "DateDiff"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "DateDiff"
    End If
    DateDiff = 0
End Function

''' <summary>
''' 日付を指定された形式でフォーマットします
''' </summary>
''' <param name="dateValue">対象の日付</param>
''' <param name="format">フォーマット文字列（オプション）</param>
''' <returns>フォーマットされた日付文字列</returns>
Public Function FormatDate(ByVal dateValue As Date, _
                         Optional ByVal format As String = DEFAULT_DATE_FORMAT) As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "FormatDate"
    End If
    
    On Error GoTo ErrorHandler
    
    FormatDate = Format$(dateValue, format)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "FormatDate"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "日付のフォーマット中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "FormatDate"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "FormatDate"
    End If
    FormatDate = Format$(dateValue, DEFAULT_DATE_FORMAT)
End Function

''' <summary>
''' 現在の日時を取得します
''' </summary>
''' <returns>現在の日時</returns>
Public Function GetCurrentDateTime() As Date
    If Not isInitialized Then InitializeModule
    GetCurrentDateTime = Now
End Function

''' <summary>
''' 指定された日付が営業日かどうかを確認します
''' </summary>
''' <param name="dateValue">確認する日付</param>
''' <returns>営業日の場合True</returns>
Public Function IsBusinessDay(ByVal dateValue As Date) As Boolean
    If Not isInitialized Then InitializeModule
    
    ' 土曜日(7)または日曜日(1)の場合はFalse
    IsBusinessDay = Not (Weekday(dateValue, vbSunday) = 1 Or _
                        Weekday(dateValue, vbSunday) = 7)
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: modMathUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modMathUtils"

' ======================
' 定数定義
' ======================
Private Const EPSILON As Double = 0.0000000001 ' 浮動小数点比較用の許容誤差

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 安全な除算を行います
''' </summary>
''' <param name="numerator">分子</param>
''' <param name="denominator">分母</param>
''' <param name="defaultValue">分母が0の場合の戻り値</param>
''' <returns>除算結果、またはデフォルト値</returns>
Public Function SafeDivide(ByVal numerator As Double, ByVal denominator As Double, _
                         Optional ByVal defaultValue As Variant = 0) As Variant
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "SafeDivide"
    End If
    
    On Error GoTo ErrorHandler
    
    If Abs(denominator) < EPSILON Then
        ' 分母が0の場合の警告を出力
        Dim errDetail As ErrorInfo
        With errDetail
            .Code = ErrDivisionByZero
            .Description = "分母が0のため、デフォルト値" & CStr(defaultValue) & "を返します。(分子: " & CStr(numerator) & ")"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "SafeDivide"
            .StackTrace = modStackTrace.GetStackTrace()
            .OccurredAt = Now
        End With
        modError.HandleError errDetail
        
        SafeDivide = defaultValue
    Else
        SafeDivide = numerator / denominator
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SafeDivide"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "除算中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "SafeDivide"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SafeDivide"
    End If
    SafeDivide = defaultValue
End Function

''' <summary>
''' 数値が指定された範囲内かどうかを確認します
''' </summary>
''' <param name="value">確認する値</param>
''' <param name="minValue">最小値</param>
''' <param name="maxValue">最大値</param>
''' <returns>範囲内の場合True</returns>
Public Function IsInRange(ByVal value As Double, ByVal minValue As Double, _
                        ByVal maxValue As Double) As Boolean
    If Not isInitialized Then InitializeModule
    
    IsInRange = (value >= minValue And value <= maxValue)
End Function

''' <summary>
''' 値を指定された範囲内に収めます
''' </summary>
''' <param name="value">対象の値</param>
''' <param name="minValue">最小値</param>
''' <param name="maxValue">最大値</param>
''' <returns>範囲内に収められた値</returns>
Public Function Clamp(ByVal value As Double, ByVal minValue As Double, _
                     ByVal maxValue As Double) As Double
    If Not isInitialized Then InitializeModule
    
    If value < minValue Then
        Clamp = minValue
    ElseIf value > maxValue Then
        Clamp = maxValue
    Else
        Clamp = value
    End If
End Function

''' <summary>
''' 指定された精度で四捨五入します
''' </summary>
''' <param name="value">対象の値</param>
''' <param name="decimals">小数点以下の桁数</param>
''' <returns>四捨五入された値</returns>
Public Function Round(ByVal value As Double, Optional ByVal decimals As Long = 0) As Double
    If Not isInitialized Then InitializeModule
    
    Dim factor As Double
    factor = 10 ^ decimals
    Round = Fix(value * factor + 0.5) / factor
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: modStackTrace.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modStackTrace"

' ======================
' 定数定義
' ======================
Private Const MAX_STACK_TRACE_DEPTH As Long = 10 ' スタックトレースの最大深さ

' ======================
' プライベート変数
' ======================
Private stack As Collection
Private isInitialized As Boolean
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Public Property Get IsInitialized() As Boolean
    IsInitialized = isInitialized
End Property

Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set stack = New Collection
    Set mLock = New clsLock
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set stack = Nothing
    Set mLock = Nothing
    isInitialized = False
End Sub

' ======================
' パブリックメソッド
' ======================
Public Sub PushStackEntry(ByVal ModuleName As String, ByVal ProcedureName As String)
    If Not isInitialized Then InitializeModule
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    If stack.Count < MAX_STACK_TRACE_DEPTH Then
        stack.Add ModuleName & "." & ProcedureName
    End If
    
    mLock.ReleaseLock
    Exit Sub

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTracePushFailed
        .Description = "スタックトレースへのエントリ追加に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "PushStackEntry"
        .StackTrace = "モジュール: " & ModuleName & ", プロシージャ: " & ProcedureName
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
End Sub

Public Function PopStackEntry() As String
    If Not isInitialized Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim result As String
    If stack.Count > 0 Then
        result = stack(stack.Count)
        stack.Remove stack.Count
        PopStackEntry = result
    End If
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTracePopFailed
        .Description = "スタックトレースからのエントリ取得に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "PopStackEntry"
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
End Function

Public Function GetStackTrace() As String
    If Not isInitialized Then Exit Function
    
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim i As Long
    Dim trace As String
    
    For i = stack.Count To 1 Step -1
        trace = trace & "  " & stack(i) & vbCrLf
    Next i
    
    GetStackTrace = trace
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrStackTraceGetFailed
        .Description = "スタックトレース文字列の生成に失敗しました。"
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "GetStackTrace"
        .OccurredAt = Now
    End With
    If Not mLock Is Nothing Then mLock.ReleaseLock
    modError.HandleError errInfo
    GetStackTrace = "スタックトレースの取得に失敗しました。"
End Function

Public Property Get StackDepth() As Long
    If Not isInitialized Then Exit Property
    mLock.AcquireLock
    StackDepth = stack.Count
    mLock.ReleaseLock
End Property

' ======================
' テストサポート機能（開発環境専用）
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' スタックの内容をクリア（テスト用）
    ''' </summary>
    Private Sub ClearStack()
        If Not isInitialized Then Exit Sub
        mLock.AcquireLock
        Set stack = New Collection
        mLock.ReleaseLock
    End Sub
    
    ''' <summary>
    ''' スタックの状態が有効かどうかを検証（テスト用）
    ''' </summary>
    ''' <returns>スタックの深さが最大値以下の場合True</returns>
    Private Function ValidateStackState() As Boolean
        If Not isInitialized Then Exit Function
        mLock.AcquireLock
        ValidateStackState = (stack.Count <= MAX_STACK_TRACE_DEPTH)
        mLock.ReleaseLock
    End Function
    
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: modStringUtils.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modStringUtils"

' ======================
' プライベート変数
' ======================
Private performanceMonitor As clsPerformanceMonitor
Private isInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If isInitialized Then Exit Sub
    
    Set performanceMonitor = New clsPerformanceMonitor
    isInitialized = True
End Sub

Public Sub TerminateModule()
    If Not isInitialized Then Exit Sub
    
    Set performanceMonitor = Nothing
    isInitialized = False
End Sub

' ======================
' 公開関数
' ======================

''' <summary>
''' 文字列を左側からパディングします
''' </summary>
''' <param name="baseStr">対象の文字列</param>
''' <param name="totalWidth">目標の長さ</param>
''' <param name="padChar">パディング文字（オプション）</param>
''' <returns>パディングされた文字列</returns>
Public Function PadLeft(ByVal baseStr As String, ByVal totalWidth As Long, _
                      Optional ByVal padChar As String = " ") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "PadLeft"
    End If
    
    On Error GoTo ErrorHandler
    
    If Len(baseStr) >= totalWidth Then
        PadLeft = baseStr
    Else
        PadLeft = String(totalWidth - Len(baseStr), Left$(padChar, 1)) & baseStr
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadLeft"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "文字列のパディング中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "PadLeft"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadLeft"
    End If
    PadLeft = baseStr
End Function

''' <summary>
''' 文字列を右側からパディングします
''' </summary>
''' <param name="baseStr">対象の文字列</param>
''' <param name="totalWidth">目標の長さ</param>
''' <param name="padChar">パディング文字（オプション）</param>
''' <returns>パディングされた文字列</returns>
Public Function PadRight(ByVal baseStr As String, ByVal totalWidth As Long, _
                       Optional ByVal padChar As String = " ") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "PadRight"
    End If
    
    On Error GoTo ErrorHandler
    
    If Len(baseStr) >= totalWidth Then
        PadRight = baseStr
    Else
        PadRight = baseStr & String(totalWidth - Len(baseStr), Left$(padChar, 1))
    End If
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadRight"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "文字列のパディング中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "PadRight"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "PadRight"
    End If
    PadRight = baseStr
End Function

''' <summary>
''' 文字列の前後の空白を削除します
''' </summary>
''' <param name="str">対象の文字列</param>
''' <returns>トリムされた文字列</returns>
Public Function TrimString(ByVal str As String) As String
    If Not isInitialized Then InitializeModule
    
    TrimString = Trim$(str)
End Function

''' <summary>
''' 文字列を指定された区切り文字で分割します
''' </summary>
''' <param name="str">対象の文字列</param>
''' <param name="delimiter">区切り文字</param>
''' <returns>分割された文字列の配列</returns>
Public Function SplitString(ByVal str As String, ByVal delimiter As String) As Variant
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "SplitString"
    End If
    
    On Error GoTo ErrorHandler
    
    SplitString = Split(str, delimiter)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SplitString"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "文字列の分割中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "SplitString"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "SplitString"
    End If
    SplitString = Array()
End Function

''' <summary>
''' 文字列配列を指定された区切り文字で結合します
''' </summary>
''' <param name="arr">文字列配列</param>
''' <param name="delimiter">区切り文字</param>
''' <returns>結合された文字列</returns>
Public Function JoinStrings(ByRef arr As Variant, Optional ByVal delimiter As String = "") As String
    If Not isInitialized Then InitializeModule
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.StartMeasurement "JoinStrings"
    End If
    
    On Error GoTo ErrorHandler
    
    JoinStrings = Join(arr, delimiter)
    
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "JoinStrings"
    End If
    Exit Function

ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "文字列の結合中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "JoinStrings"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    If Not performanceMonitor Is Nothing Then
        performanceMonitor.EndMeasurement "JoinStrings"
    End If
    JoinStrings = ""
End Function

' ======================
' テストサポート機能
' 警告: これらのメソッドは開発時のテスト目的でのみ使用し、
' 本番環境では使用しないでください。
' ======================
#If DEBUG Then
    ''' <summary>
    ''' モジュールの状態を初期化（テスト用）
    ''' </summary>
    Private Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
    
    ''' <summary>
    ''' パフォーマンスモニターの参照を取得（テスト用）
    ''' </summary>
    Private Function GetPerformanceMonitor() As clsPerformanceMonitor
        Set GetPerformanceMonitor = performanceMonitor
    End Function
#End If

================
File: modWindowsAPI.bas
================
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "modWindowsAPI"

' ======================
' Windows API宣言（レガシーサポート用）
' ======================
' 従来のAPI宣言は維持しますが、新規コードでは非推奨です。
' 代わりにインターフェースベースの実装を使用してください。
#If LegacySupport Then
    ' --- INIファイル操作 ---
    Public Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" ( _
        ByVal lpApplicationName As String, ByVal lpKeyName As Any, _
        ByVal lpDefault As String, ByVal lpReturnedString As String, _
        ByVal nSize As Long, ByVal lpFileName As String) As Long
    ' ... (その他のAPI宣言)
#End If

' ======================
' プライベート変数
' ======================
Private mConverter As ModWindowsAPIConverter
Private mIsInitialized As Boolean

' ======================
' 初期化・終了処理
' ======================
Public Sub InitializeModule()
    If mIsInitialized Then Exit Sub
    
    Set mConverter = New ModWindowsAPIConverter
    mIsInitialized = True
End Sub

Public Sub TerminateModule()
    If Not mIsInitialized Then Exit Sub
    
    Set mConverter = Nothing
    mIsInitialized = False
End Sub

' ======================
' パブリック関数
' ======================

' --- ミューテックス操作 ---
Public Function CreateMutex(ByVal lpMutexAttributes As LongPtr, _
                          ByVal bInitialOwner As Long, _
                          ByVal lpName As String) As LongPtr
    InitializeIfNeeded
    
    Dim mutex As IMutex
    Set mutex = mConverter.Mutex
    
    If mutex.CreateMutex(bInitialOwner <> 0, lpName) Then
        CreateMutex = GetHandleFromMutex(mutex)
    End If
End Function

Public Function ReleaseMutex(ByVal hMutex As LongPtr) As Long
    InitializeIfNeeded
    
    Dim mutex As IMutex
    Set mutex = mConverter.Mutex
    
    ReleaseMutex = IIf(mutex.ReleaseMutex(), 1, 0)
End Function

Public Function WaitForSingleObject(ByVal hHandle As LongPtr, _
                                  ByVal dwMilliseconds As Long) As Long
    InitializeIfNeeded
    
    Dim mutex As IMutex
    Set mutex = mConverter.Mutex
    
    WaitForSingleObject = IIf(mutex.WaitForSingleObject(dwMilliseconds), 0, &HFFFFFFFF)
End Function

' --- 暗号化操作 ---
Public Function CryptAcquireContext(ByRef phProv As LongPtr, _
                                  ByVal pszContainer As String, _
                                  ByVal pszProvider As String, _
                                  ByVal dwProvType As Long, _
                                  ByVal dwFlags As Long) As Long
    InitializeIfNeeded
    
    Dim crypto As ICryptography
    Set crypto = mConverter.Crypto
    
    CryptAcquireContext = IIf(crypto.CryptAcquireContext(pszContainer, pszProvider, dwProvType, dwFlags), 1, 0)
End Function

' ... (他の暗号化関数も同様にインターフェース経由に変更)

' --- INIファイル操作 ---
Public Function GetPrivateProfileString(ByVal lpApplicationName As String, _
                                      ByVal lpKeyName As Any, _
                                      ByVal lpDefault As String, _
                                      ByVal lpReturnedString As String, _
                                      ByVal nSize As Long, _
                                      ByVal lpFileName As String) As Long
    InitializeIfNeeded
    
    Dim iniFile As IIniFile
    Set iniFile = mConverter.IniFile
    
    Dim result As String
    result = iniFile.GetPrivateProfileString(lpApplicationName, lpKeyName, lpDefault, lpFileName)
    
    If Len(result) > 0 Then
        If Len(result) > nSize - 1 Then result = Left$(result, nSize - 1)
        Mid$(lpReturnedString, 1, Len(result)) = result
        GetPrivateProfileString = Len(result)
    End If
End Function

' --- パフォーマンスカウンター ---
Public Function QueryPerformanceCounter(ByRef lpPerformanceCount As Currency) As Long
    InitializeIfNeeded
    
    Dim perfCounter As IPerformanceCounter
    Set perfCounter = mConverter.PerformanceCounter
    
    QueryPerformanceCounter = IIf(perfCounter.QueryPerformanceCounter(lpPerformanceCount), 1, 0)
End Function

Public Function QueryPerformanceFrequency(ByRef lpFrequency As Currency) As Long
    InitializeIfNeeded
    
    Dim perfCounter As IPerformanceCounter
    Set perfCounter = mConverter.PerformanceCounter
    
    QueryPerformanceFrequency = IIf(perfCounter.QueryPerformanceFrequency(lpFrequency), 1, 0)
End Function

' --- スリープ操作 ---
Public Sub Sleep(ByVal dwMilliseconds As Long)
    InitializeIfNeeded
    
    Dim sleeper As ISleep
    Set sleeper = mConverter.Sleep
    
    sleeper.Sleep dwMilliseconds
End Sub

' ======================
' プライベート関数
' ======================
Private Sub InitializeIfNeeded()
    If Not mIsInitialized Then InitializeModule
End Sub

Private Function GetHandleFromMutex(ByVal mutex As IMutex) As LongPtr
    ' 実装クラス固有のハンドル取得
    If TypeOf mutex Is MutexImpl Then
        GetHandleFromMutex = DirectCast(mutex, MutexImpl).GetMutexHandle()
    End If
End Function

' ======================
' エラー処理
' ======================
Public Function MapWindowsErrorToAppError(ByVal windowsError As Long) As ErrorCode
    Select Case windowsError
        Case 2, 3 ' ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND
            MapWindowsErrorToAppError = ErrFileNotFound
        Case 5 ' ERROR_ACCESS_DENIED
            MapWindowsErrorToAppError = ErrFileAccessDenied
        Case 32 ' ERROR_SHARING_VIOLATION
            MapWindowsErrorToAppError = ErrFileAccessDenied
        Case 8, 14 ' ERROR_NOT_ENOUGH_MEMORY, ERROR_OUTOFMEMORY
            MapWindowsErrorToAppError = ErrSystemOutOfMemory
        Case Else
            MapWindowsErrorToAppError = ErrUnexpected
    End Select
End Function

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function TestAPIAvailability() As Boolean
        InitializeIfNeeded
        
        Dim result As Boolean
        result = True
        
        ' 基本的なAPI機能のテスト
        Dim counter As Currency
        result = result And (QueryPerformanceCounter(counter) <> 0)
        
        ' ファイル操作APIのテスト
        Dim attr As Long
        attr = GetFileAttributes("C:\")
        result = result And (attr <> INVALID_FILE_ATTRIBUTES)
        
        TestAPIAvailability = result
    End Function
    
    Public Sub ResetModule()
        TerminateModule
        InitializeModule
    End Sub
#End If

================
File: ModWindowsAPIConverter.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ModWindowsAPIConverter"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

''' <summary>
''' modWindowsAPIの関数呼び出しを新しいインターフェースベースの実装に変換するヘルパークラス
''' </summary>
''' <remarks>
''' このクラスは、従来のmodWindowsAPI関数呼び出しを新しいインターフェースベースの
''' 実装に橋渡しする機能を提供します。既存のコードとの互換性を維持しながら、
''' 新しいインターフェースベースの実装への段階的な移行を支援します。
''' </remarks>

Private mMutex As IMutex
Private mCrypto As ICryptography
Private mIniFile As IIniFile
Private mPerformanceCounter As IPerformanceCounter
Private mEventLog As IEventLog
Private mSleep As ISleep

' エラー情報の保持用
Private mLastError As Long
Private mLock As clsLock

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mLock = New clsLock
    
    ' 各インターフェースの実装クラスをインスタンス化
    Set mMutex = New MutexImpl
    Set mCrypto = New CryptographyImpl
    Set mIniFile = New IniFileImpl
    Set mPerformanceCounter = New PerformanceCounterImpl
    Set mEventLog = New EventLogImpl
    Set mSleep = New SleepImpl
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mMutex = Nothing
    Set mCrypto = Nothing
    Set mIniFile = Nothing
    Set mPerformanceCounter = Nothing
    Set mEventLog = Nothing
    Set mSleep = Nothing
End Sub

' ======================
' パブリックメソッド
' ======================

''' <summary>
''' 最後に発生したWin32エラーコードを取得します
''' </summary>
Public Property Get LastError() As Long
    LastError = mLastError
End Property

''' <summary>
''' ミューテックスインターフェースを取得します
''' </summary>
Public Property Get Mutex() As IMutex
    Set Mutex = mMutex
End Property

''' <summary>
''' 暗号化インターフェースを取得します
''' </summary>
Public Property Get Crypto() As ICryptography
    Set Crypto = mCrypto
End Property

''' <summary>
''' INIファイルインターフェースを取得します
''' </summary>
Public Property Get IniFile() As IIniFile
    Set IniFile = mIniFile
End Property

''' <summary>
''' パフォーマンスカウンターインターフェースを取得します
''' </summary>
Public Property Get PerformanceCounter() As IPerformanceCounter
    Set PerformanceCounter = mPerformanceCounter
End Property

''' <summary>
''' イベントログインターフェースを取得します
''' </summary>
Public Property Get EventLog() As IEventLog
    Set EventLog = mEventLog
End Property

''' <summary>
''' スリープインターフェースを取得します
''' </summary>
Public Property Get Sleep() As ISleep
    Set Sleep = mSleep
End Property

' ======================
' エラー処理
' ======================
Private Sub UpdateLastError()
    #If Win64 Then
        mLastError = CLng(CreateObject("WScript.Shell").Environment("PROCESS")("ERROR_CODE"))
    #Else
        mLastError = Err.LastDllError
    #End If
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Sub ResetInterfaces()
        Class_Terminate
        Class_Initialize
    End Sub
    
    Public Function ValidateInterfaces() As Boolean
        ValidateInterfaces = Not (mMutex Is Nothing Or _
                                mCrypto Is Nothing Or _
                                mIniFile Is Nothing Or _
                                mPerformanceCounter Is Nothing Or _
                                mEventLog Is Nothing Or _
                                mSleep Is Nothing)
    End Function
#End If

================
File: MsgBoxNotifier.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "MsgBoxNotifier"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "MsgBoxNotifier"

' ======================
' インターフェース実装
' ======================
Implements IUserNotifier

' ======================
' プライベート変数
' ======================
Private mNotificationStyle As VbMsgBoxStyle
Private mDefaultTitle As String
Private mLock As ILock
Private mPerformanceMonitor As IPerformanceMonitor
Private mAppConfig As IAppConfig
Private mMessageFormatter As IMessageFormatter

' ======================
' 型定義
' ======================
Private Type NotificationContext
    ErrorDetail As ErrorInfo
    Buttons As VbMsgBoxStyle
    Title As String
    Message As String
    Icon As VbMsgBoxStyle
    IsLocked As Boolean
    Result As VbMsgBoxResult
    ExecutionTime As Double
End Type

' ======================
' 初期化・終了処理
' ======================
''' <summary>
''' クラスの初期化を行います。
''' </summary>
''' <param name="lock">排他制御を提供するILockインターフェース</param>
''' <param name="performanceMonitor">パフォーマンス監視を提供するIPerformanceMonitorインターフェース</param>
''' <param name="appConfig">アプリケーション設定を提供するIAppConfigインターフェース</param>
''' <param name="messageFormatter">メッセージフォーマットを提供するIMessageFormatterインターフェース</param>
Public Sub Initialize(ByVal lock As ILock, _
                     ByVal performanceMonitor As IPerformanceMonitor, _
                     ByVal appConfig As IAppConfig, _
                     ByVal messageFormatter As IMessageFormatter)
    If lock Is Nothing Or performanceMonitor Is Nothing Or _
       appConfig Is Nothing Or messageFormatter Is Nothing Then
        Err.Raise 5, MODULE_NAME & ".Initialize", "必要なインターフェースがNothingです。"
    End If
    
    mNotificationStyle = vbOKOnly Or vbInformation
    mDefaultTitle = "エラー"
    Set mLock = lock
    Set mPerformanceMonitor = performanceMonitor
    Set mAppConfig = appConfig
    Set mMessageFormatter = messageFormatter
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
    Set mPerformanceMonitor = Nothing
End Sub

' ======================
' IUserNotifier実装
' ======================
Private Function IUserNotifier_Notify(ByRef errorDetail As ErrorInfo, _
                                   Optional ByVal buttons As VbMsgBoxStyle = vbOKOnly, _
                                   Optional ByVal title As String = "エラー") As VbMsgBoxResult
    ' パフォーマンス計測開始
    mPerformanceMonitor.StartMeasurement "Notify"
    
    ' 通知コンテキストの初期化
    Dim context As NotificationContext
    context.ErrorDetail = errorDetail
    context.Buttons = buttons
    context.Title = IIf(title = "", mDefaultTitle, title)

    ' ロック取得
    On Error Resume Next
    mLock.AcquireLock
    context.IsLocked = (Err.Number = 0)
    On Error GoTo 0

    ' 通知処理の実行
    If TryPrepareNotification(context) Then
        context.Result = ShowNotification(context)
    Else
        ' 通知準備に失敗した場合のフォールバック
        context.Result = vbAbort
    End If

    ' クリーンアップ処理
    If context.IsLocked Then
        mLock.ReleaseLock
    End If

    ' パフォーマンス計測終了
    mPerformanceMonitor.EndMeasurement "Notify"
    
    IUserNotifier_Notify = context.Result
End Function

Private Property Let IUserNotifier_NotificationStyle(ByVal style As VbMsgBoxStyle)
    mNotificationStyle = style
End Property

Private Property Get IUserNotifier_NotificationStyle() As VbMsgBoxStyle
    IUserNotifier_NotificationStyle = mNotificationStyle
End Property

Private Property Let IUserNotifier_DefaultTitle(ByVal title As String)
    mDefaultTitle = title
End Property

Private Property Get IUserNotifier_DefaultTitle() As String
    IUserNotifier_DefaultTitle = mDefaultTitle
End Property

' ======================
' プライベートメソッド
' ======================
Private Function TryPrepareNotification(ByRef context As NotificationContext) As Boolean
    On Error GoTo ErrorHandler
    
    mPerformanceMonitor.StartMeasurement "PrepareNotification"
    
    ' アイコンの設定
    context.Icon = GetIconForErrorCategory(context.ErrorDetail.Category)
    
    ' メッセージの組み立て
    context.Message = mMessageFormatter.FormatMessage("", context.ErrorDetail)
    
    mPerformanceMonitor.EndMeasurement "PrepareNotification"
    TryPrepareNotification = True
    Exit Function
    
ErrorHandler:
    ' エラー情報のログ記録
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "通知の準備中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "TryPrepareNotification"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "PrepareNotification"
    End If
    
    TryPrepareNotification = False
End Function

Private Function ShowNotification(ByRef context As NotificationContext) As VbMsgBoxResult
    On Error GoTo ErrorHandler
    
    mPerformanceMonitor.StartMeasurement "ShowNotification"
    
    ' メッセージボックスの表示（NotificationStyleを適用）
    ShowNotification = MsgBox(context.Message, _
                            mNotificationStyle Or context.Buttons Or context.Icon, _
                            context.Title)
    
    mPerformanceMonitor.EndMeasurement "ShowNotification"
    Exit Function
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "メッセージボックスの表示中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "ShowNotification"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    If Not mPerformanceMonitor Is Nothing Then
        mPerformanceMonitor.EndMeasurement "ShowNotification"
    End If
    
    ShowNotification = vbAbort
End Function

Private Function GetIconForErrorCategory(ByVal category As ErrorCodeCategory) As VbMsgBoxStyle
    Select Case category
        Case ECSystem, ECSecurity
            GetIconForErrorCategory = vbCritical
        Case ECDatabase, ECNetwork
            GetIconForErrorCategory = vbExclamation
        Case Else
            GetIconForErrorCategory = vbInformation
    End Select
End Function


' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    ' === 通知テスト ===
    Public Sub TestNotification()
        ' テスト用の依存性を注入
        Dim testLock As New MockLock
        Dim testMonitor As New MockPerformanceMonitor
        Dim testConfig As New MockAppConfig
        Dim testFormatter As New DefaultMessageFormatter
        
        ' 初期化
        Initialize testLock, testMonitor, testConfig, testFormatter
        
        ' テスト用エラー情報の作成
        Dim testError As ErrorInfo
        With testError
            .Code = ErrUnexpected
            .Description = "テスト通知"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "TestNotification"
            .StackTrace = "テストスタックトレース"
            .OccurredAt = Now
        End With
        
        ' 各種スタイルでのテスト
        TestNotificationStyle testError, vbOKOnly, "OKのみ"
        TestNotificationStyle testError, vbOKCancel, "OK/キャンセル"
        TestNotificationStyle testError, vbYesNo, "はい/いいえ"
    End Sub
    
    Private Sub TestNotificationStyle(ByRef testError As ErrorInfo, _
                                    ByVal style As VbMsgBoxStyle, _
                                    ByVal description As String)
        mPerformanceMonitor.StartMeasurement "NotificationTest_" & description
        
        Dim result As VbMsgBoxResult
        result = IUserNotifier_Notify(testError, style, "テスト: " & description)
        
        mPerformanceMonitor.EndMeasurement "NotificationTest_" & description
        
        Debug.Print description & " テスト結果:"
        Debug.Print "  - 実行時間: " & _
                   mPerformanceMonitor.GetMeasurement("NotificationTest_" & description)
        Debug.Print "  - ユーザー応答: " & result
    End Sub
    
    ' === リソース管理テスト ===
    Public Sub TestResourceManagement()
        Dim lockCountBefore As Long
        lockCountBefore = GetActiveLockCount()
        
        Dim testError As ErrorInfo
        With testError
            .Code = ErrUnexpected
            .Description = "リソース管理テスト"
            .Category = ECGeneral
            .Source = MODULE_NAME
            .ProcedureName = "TestResourceManagement"
            .StackTrace = ""
            .OccurredAt = Now
        End With
        
        mPerformanceMonitor.StartMeasurement "ResourceTest"
        
        On Error Resume Next
        IUserNotifier_Notify testError, vbOKOnly, "リソーステスト"
        
        mPerformanceMonitor.EndMeasurement "ResourceTest"
        
        Dim lockCountAfter As Long
        lockCountAfter = GetActiveLockCount()
        
        Debug.Print "リソース管理テスト結果:"
        Debug.Print "  - 実行時間: " & _
                   mPerformanceMonitor.GetMeasurement("ResourceTest")
        
        If lockCountBefore <> lockCountAfter Then
            Debug.Print "  警告: リソースリークの可能性があります"
            Debug.Print "  - ロック数 Before: " & lockCountBefore
            Debug.Print "  - ロック数 After: " & lockCountAfter
        End If
    End Sub
    
    ' === パフォーマンスレポート ===
    Public Function GetPerformanceReport() As String
        If Not mPerformanceMonitor Is Nothing Then
            GetPerformanceReport = mPerformanceMonitor.GetAllMeasurements()
        Else
            GetPerformanceReport = "パフォーマンスモニターが初期化されていません。"
        End If
    End Function
    
    ' === 内部状態取得 ===
    Private Function GetActiveLockCount() As Long
        Dim result As Long
        result = 0
        
        If Not mLock Is Nothing Then
            If mLock.IsLocked Then
                result = result + 1
            End If
        End If
        
        GetActiveLockCount = result
    End Function
#End If

================
File: QueueImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "QueueImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements IQueue

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "QueueImpl"

' ======================
' メンバ変数
' ======================
Private mItems As Collection

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mItems = New Collection
End Sub

Private Sub Class_Terminate()
    Set mItems = Nothing
End Sub

' ======================
' IQueue実装
' ======================
Private Sub IQueue_Enqueue(ByVal item As Variant)
    mItems.Add item
End Sub

Private Function IQueue_Dequeue() As Variant
    If mItems.Count = 0 Then
        Err.Raise vbObjectError + 1, MODULE_NAME, "キューが空です"
    End If
    
    If IsObject(mItems(1)) Then
        Set IQueue_Dequeue = mItems(1)
    Else
        IQueue_Dequeue = mItems(1)
    End If
    mItems.Remove 1
End Function

Private Function IQueue_IsEmpty() As Boolean
    IQueue_IsEmpty = (mItems.Count = 0)
End Function

Private Property Get IQueue_Count() As Long
    IQueue_Count = mItems.Count
End Property

Private Function IQueue_Peek() As Variant
    If mItems.Count = 0 Then
        Err.Raise vbObjectError + 1, MODULE_NAME, "キューが空です"
    End If
    
    If IsObject(mItems(1)) Then
        Set IQueue_Peek = mItems(1)
    Else
        IQueue_Peek = mItems(1)
    End If
End Function

Private Sub IQueue_Clear()
    Set mItems = New Collection
End Sub

================
File: SleepImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SleepImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

Implements ISleep

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "SleepImpl"

' ======================
' メンバ変数
' ======================
Private mIsInitialized As Boolean
Private mPerformanceCounter As IPerformanceCounter
Private mIsHighPrecision As Boolean

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    ' 高精度タイマーが利用可能か確認
    Set mPerformanceCounter = New PerformanceCounterImpl
    mIsHighPrecision = (TypeOf mPerformanceCounter Is PerformanceCounterImpl)
    mIsInitialized = True
End Sub

Private Sub Class_Terminate()
    Set mPerformanceCounter = Nothing
    mIsInitialized = False
End Sub

' ======================
' ISleep実装
' ======================
Private Sub ISleep_Sleep(ByVal milliseconds As Long)
    If Not mIsInitialized Then Exit Sub
    If milliseconds <= 0 Then Exit Sub
    
    On Error GoTo ErrorHandler
    
    If mIsHighPrecision Then
        HighPrecisionSleep milliseconds
    Else
        StandardSleep milliseconds
    End If
    
    Exit Sub

ErrorHandler:
    LogError "スリープ処理中にエラーが発生しました: " & Err.Description
    StandardSleep milliseconds  ' エラー時は標準のSleepにフォールバック
End Sub

' ======================
' プライベートメソッド
' ======================
Private Sub HighPrecisionSleep(ByVal milliseconds As Long)
    Dim startCount As Currency
    Dim currentCount As Currency
    Dim frequency As Currency
    Dim targetCount As Currency
    
    ' 周波数とカウンターの取得
    If Not mPerformanceCounter.QueryPerformanceFrequency(frequency) Then
        StandardSleep milliseconds
        Exit Sub
    End If
    
    If Not mPerformanceCounter.QueryPerformanceCounter(startCount) Then
        StandardSleep milliseconds
        Exit Sub
    End If
    
    ' 目標カウントの計算
    targetCount = startCount + (frequency * milliseconds) / 1000
    
    ' 高精度ウェイト
    Do
        If Not mPerformanceCounter.QueryPerformanceCounter(currentCount) Then
            StandardSleep milliseconds
            Exit Sub
        End If
    Loop While currentCount < targetCount
End Sub

Private Sub StandardSleep(ByVal milliseconds As Long)
    modWindowsAPI.Sleep milliseconds
End Sub

Private Sub LogError(ByVal message As String)
    Dim errInfo As ErrorInfo
    With errInfo
        .Code = ErrUnexpected
        .Description = message
        .Category = ECSystem
        .Source = MODULE_NAME
        .ProcedureName = "Unknown"  ' スタックトレースから取得可能
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errInfo
End Sub

' ======================
' テストサポート機能
' ======================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = mIsInitialized And Not (mPerformanceCounter Is Nothing)
    End Function
    
    Public Function IsHighPrecision() As Boolean
        IsHighPrecision = mIsHighPrecision
    End Function
    
    Public Function TestSleepAccuracy(ByVal milliseconds As Long) As Double
        Dim startTime As Currency
        Dim endTime As Currency
        
        ' 開始時刻を取得
        If Not mPerformanceCounter.QueryPerformanceCounter(startTime) Then
            TestSleepAccuracy = -1
            Exit Function
        End If
        
        ' スリープ実行
        ISleep_Sleep milliseconds
        
        ' 終了時刻を取得
        If Not mPerformanceCounter.QueryPerformanceCounter(endTime) Then
            TestSleepAccuracy = -1
            Exit Function
        End If
        
        ' 実際の経過時間を計算（ミリ秒）
        Dim frequency As Currency
        If Not mPerformanceCounter.QueryPerformanceFrequency(frequency) Then
            TestSleepAccuracy = -1
            Exit Function
        End If
        
        TestSleepAccuracy = (endTime - startTime) * 1000 / frequency
    End Function
#End If

================
File: StackImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "StackImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

Implements IStack

'==========================
' 定数
'==========================
Private Const DEFAULT_CAPACITY As Long = 10
Private Const MODULE_NAME As String = "StackImpl"

'==========================
' メンバ変数
'==========================
Private mItems() As String
Private mCount As Long
Private mMaxSize As Long
Private mLock As clsLock

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    mMaxSize = DEFAULT_CAPACITY
    ReDim mItems(0 To mMaxSize - 1)
    Set mLock = New clsLock
End Sub

Private Sub Class_Terminate()
    Set mLock = Nothing
End Sub

'==========================
' プロパティ
'==========================
Public Property Let MaxSize(ByVal value As Long)
    If value <= 0 Then
        Err.Raise vbObjectError + 1, MODULE_NAME, "最大サイズは1以上である必要があります。"
    End If
    mMaxSize = value
    ReDim Preserve mItems(0 To mMaxSize - 1)
End Property

'==========================
' IStack実装
'==========================
Private Function IStack_Push(ByVal Item As String) As Boolean
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    If mCount >= mMaxSize Then
        IStack_Push = False
        mLock.ReleaseLock
        Exit Function
    End If
    
    mItems(mCount) = Item
    mCount = mCount + 1
    IStack_Push = True
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "Push操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStack_Pop() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    If mCount = 0 Then
        IStack_Pop = ""
        mLock.ReleaseLock
        Exit Function
    End If
    
    mCount = mCount - 1
    IStack_Pop = mItems(mCount)
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "Pop操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStack_Peek() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    If mCount = 0 Then
        IStack_Peek = ""
        mLock.ReleaseLock
        Exit Function
    End If
    
    IStack_Peek = mItems(mCount - 1)
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "Peek操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStack_IsEmpty() As Boolean
    IStack_IsEmpty = (mCount = 0)
End Function

Private Property Get IStack_Count() As Long
    IStack_Count = mCount
End Property

Private Sub IStack_Clear()
    mLock.AcquireLock
    mCount = 0
    mLock.ReleaseLock
End Sub

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = (mCount >= 0 And mCount <= mMaxSize)
    End Function
    
    Public Property Get Capacity() As Long
        Capacity = mMaxSize
    End Property
#End If

================
File: StackTraceImpl.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "StackTraceImpl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = True
Option Explicit

Implements IStackTrace

'==========================
' 定数
'==========================
Private Const MODULE_NAME As String = "StackTraceImpl"
Private Const CONFIG_KEY_STACK_DEPTH As String = "MaxStackTraceDepth"

'==========================
' メンバ変数
'==========================
Private mStack As IStack
Private mConfig As IAppConfig
Private mLock As clsLock

'==========================
' 初期化・終了処理
'==========================
Private Sub Class_Initialize()
    Set mStack = New StackImpl
    Set mConfig = modConfig.GetAppConfig
    Set mLock = New clsLock
    
    ' スタックの最大サイズを設定から取得
    Dim maxDepth As Long
    maxDepth = mConfig.GetSetting(CONFIG_KEY_STACK_DEPTH, 10)  ' デフォルト値は10
    StackImpl(mStack).MaxSize = maxDepth
End Sub

Private Sub Class_Terminate()
    Set mStack = Nothing
    Set mConfig = Nothing
    Set mLock = Nothing
End Sub

'==========================
' IStackTrace実装
'==========================
Private Function IStackTrace_PushStackEntry(ByVal ClassName As String, ByVal MethodName As String, Optional ByVal Parameters As Variant) As Boolean
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim entry As String
    entry = FormatStackEntry(ClassName, MethodName, Parameters)
    IStackTrace_PushStackEntry = mStack.Push(entry)
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "PushStackEntry操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStackTrace_PopStackEntry() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    IStackTrace_PopStackEntry = mStack.Pop()
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "PopStackEntry操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStackTrace_GetStackTrace() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    Dim tempStack As New StackImpl
    Dim trace As String
    Dim entry As String
    
    ' オリジナルスタックの内容を保持しながらトレースを生成
    Do While Not mStack.IsEmpty
        entry = mStack.Pop()
        tempStack.Push entry
        trace = entry & vbCrLf & trace
    Loop
    
    ' オリジナルスタックを復元
    Do While Not tempStack.IsEmpty
        mStack.Push tempStack.Pop()
    Loop
    
    IStackTrace_GetStackTrace = trace
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "GetStackTrace操作でエラーが発生しました: " & Err.Description
End Function

Private Function IStackTrace_StackDepth() As Long
    IStackTrace_StackDepth = mStack.Count
End Function

Private Sub IStackTrace_ClearStack()
    mLock.AcquireLock
    mStack.Clear
    mLock.ReleaseLock
End Sub

Private Function IStackTrace_IsEmpty() As Boolean
    IStackTrace_IsEmpty = mStack.IsEmpty()
End Function

Private Function IStackTrace_Peek() As String
    mLock.AcquireLock
    On Error GoTo ErrorHandler
    
    IStackTrace_Peek = mStack.Peek()
    
    mLock.ReleaseLock
    Exit Function

ErrorHandler:
    mLock.ReleaseLock
    Err.Raise Err.Number, MODULE_NAME, "Peek操作でエラーが発生しました: " & Err.Description
End Function

'==========================
' プライベートメソッド
'==========================
Private Function FormatStackEntry(ByVal ClassName As String, ByVal MethodName As String, ByVal Parameters As Variant) As String
    Dim result As String
    result = ClassName & "." & MethodName
    
    ' パラメータが指定されている場合は追加
    If Not IsMissing(Parameters) Then
        result = result & "("
        
        If IsArray(Parameters) Then
            Dim i As Long
            For i = LBound(Parameters) To UBound(Parameters)
                If i > LBound(Parameters) Then result = result & ", "
                result = result & CStr(Parameters(i))
            Next i
        Else
            result = result & CStr(Parameters)
        End If
        
        result = result & ")"
    End If
    
    FormatStackEntry = result
End Function

'==========================
' テストサポート（開発環境用）
'==========================
#If DEBUG Then
    Public Function ValidateState() As Boolean
        ValidateState = StackImpl(mStack).ValidateState()
    End Function
    
    Public Property Get MaxStackDepth() As Long
        MaxStackDepth = StackImpl(mStack).Capacity
    End Property
#End If

================
File: VBScriptRegexEngine.cls
================
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "VBScriptRegexEngine"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredefinedId = False
Attribute VB_Exposed = False
Option Explicit

' ======================
' モジュール情報
' ======================
Private Const MODULE_NAME As String = "VBScriptRegexEngine"

' ======================
' インターフェース実装
' ======================
Implements IRegexEngine

' ======================
' プライベート変数
' ======================
Private mRegex As Object ' VBScript.RegExp

' ======================
' 初期化・終了処理
' ======================
Private Sub Class_Initialize()
    Set mRegex = CreateObject("VBScript.RegExp")
End Sub

Private Sub Class_Terminate()
    Set mRegex = Nothing
End Sub

' ======================
' メソッド
' ======================
Private Function IRegexEngine_Test(ByVal pattern As String, ByVal text As String, Optional ByVal ignoreCase As Boolean = True) As Boolean
    On Error GoTo ErrorHandler
    
    With mRegex
        .Pattern = pattern
        .Global = True
        .IgnoreCase = ignoreCase
        IRegexEngine_Test = .Test(text)
    End With
    Exit Function
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "正規表現のテスト中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IRegexEngine_Test"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    Err.Raise Err.Number, Err.Source, "正規表現のテスト中にエラーが発生しました: " & Err.Description
End Function

Private Function IRegexEngine_Replace(ByVal pattern As String, ByVal text As String, ByVal replacement As String, Optional ByVal ignoreCase As Boolean = True) As String
    On Error GoTo ErrorHandler
    
    With mRegex
        .Pattern = pattern
        .Global = True
        .IgnoreCase = ignoreCase
        IRegexEngine_Replace = .Replace(text, replacement)
    End With
    Exit Function
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "正規表現による置換中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IRegexEngine_Replace"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    Err.Raise Err.Number, Err.Source, "正規表現による置換中にエラーが発生しました: " & Err.Description
End Function

Private Function IRegexEngine_Match(ByVal pattern As String, ByVal text As String, Optional ByVal ignoreCase As Boolean = True) As Variant
    On Error GoTo ErrorHandler
    
    With mRegex
        .Pattern = pattern
        .Global = True
        .IgnoreCase = ignoreCase
        
        Dim matches As Object
        Set matches = .Execute(text)
        
        If matches.Count = 0 Then
            IRegexEngine_Match = Array()
            Exit Function
        End If
        
        Dim result() As String
        ReDim result(matches.Count - 1)
        
        Dim i As Long
        For i = 0 To matches.Count - 1
            result(i) = matches(i).Value
        Next i
        
        IRegexEngine_Match = result
    End With
    Exit Function
    
ErrorHandler:
    Dim errDetail As ErrorInfo
    With errDetail
        .Code = ErrUnexpected
        .Description = "正規表現によるマッチング中にエラーが発生しました: " & Err.Description
        .Category = ECGeneral
        .Source = MODULE_NAME
        .ProcedureName = "IRegexEngine_Match"
        .StackTrace = modStackTrace.GetStackTrace()
        .OccurredAt = Now
    End With
    modError.HandleError errDetail
    
    Err.Raise Err.Number, Err.Source, "正規表現によるマッチング中にエラーが発生しました: " & Err.Description
End Function
